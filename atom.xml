<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大卫和小王的博客园</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="http://david-luge.cn/atom.xml" rel="self"/>
  
  <link href="http://david-luge.cn/"/>
  <updated>2023-03-24T07:38:39.000Z</updated>
  <id>http://david-luge.cn/</id>
  
  <author>
    <name>DavidGu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>低功耗设计简述</title>
    <link href="http://david-luge.cn/2023/03/24/IC/Basic/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/"/>
    <id>http://david-luge.cn/2023/03/24/IC/Basic/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-03-24T07:38:39.000Z</published>
    <updated>2023-03-24T07:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h1><p>芯片的整体功耗从根本上可以分为静态功耗和动态功耗；</p><p>静态功耗，又称漏电流功耗，是器件特性，和晶体管的阈值电压及其自身特性有关；</p><p>动态功耗，主要是芯片中的寄生RC电路的充放电引起的。换言之，当芯片中的电路出现任何信号翻转，都会产生动态功耗，其中所占最大比例的是时钟信号的翻转。</p><p>动态功耗还可以分为翻转功耗和短路功耗。翻转功耗和电压、翻转率和负载电容有关，所以降翻转功耗的措施就是降压、降翻转率和减负载电容；</p><p>短路功耗是指在晶体管翻转时，nMOS和pMOS会存在同时导通的情况，这时候产生的功耗称为短路功耗。</p><p>现代SoC的功耗主要集中在：时钟树功耗(40%)、CPU、GPU、存储器等；<br>功耗的整体计算公式为：</p><p>$$P&#x3D;(C{\times}V^2{\times}f)+(t{\times}V{\times}I{\times}f)$$</p><p>前面的部分是翻转功耗，后面的部分是短路功耗；</p><h2 id="静态低功耗技术"><a href="#静态低功耗技术" class="headerlink" title="静态低功耗技术"></a>静态低功耗技术</h2><p><strong>电源门控</strong>是直接切断电源来减少漏电流；</p><p>而<strong>多阈值工艺</strong>和<strong>体偏置</strong>则是通过改变CMOS管的阈值电压来减少静态功耗；</p><h3 id="电源门控"><a href="#电源门控" class="headerlink" title="电源门控"></a>电源门控</h3><p>指直接关掉某一不用模块的电源，这样可以直接关闭动态和静态功耗；</p><p>局限：会引入额外的开销；模块的唤醒需要时间，功耗达到最终的power gating功耗(即使power gating仍然会有少量的漏电流)也需要时间。如果芯片一直在工作，则power gating的收益就有些小。总结而言就是需要考虑唤醒开销和power gating节省的功耗哪个大。</p><p>实际做法：<br>1、两个电源域，每个电源域引出单独的物理管脚，直接物理关断；适合长时间的关断；<br>2、内部关断：在片上实现一个电源控制器，类似于一个开关，进行电压切换；</p><p>为了关断power，我们可以把Vdd换成Vss，也可以将Vss换成Vdd。但一般情况下最好把Vdd换成Vss，因为多电源域一般共地，但Vdd各不相同。<br>(注，Vdd中d&#x3D;device，指器件的工作电压；Vss中s&#x3D;series表示公共连接的意思，也就是公共接地端)</p><p>需添加专用的隔离单元(isolation cell)，如特殊处理的与门(输出与隔离信号相与，输出低电平)，隔离单元处于源模块，但电源一般不关；或者需要给出主电源和备用电源，保证在power down的时候隔离单元还能继续工作；</p><p>典型的门控电源的过程：<br>1、关闭时钟；<br>2、打开隔离信号；<br>3、发出save脉冲，提示保存好相关寄存器；<br>4、拉低rst_n；<br>5、关闭电源；<br>6、打开该电源域时，在复位信号拉高后发出恢复信号脉冲；</p><p>对于门控电源，具体的实现是在后端，对于架构来讲需要分清楚有几个电压域，有几种低功耗模式；对于前端来讲，要搞清楚接口信号，同时需要实现一个控制器来断电和唤醒电源域，且加上隔离模块；</p><h3 id="多阈值工艺"><a href="#多阈值工艺" class="headerlink" title="多阈值工艺"></a>多阈值工艺</h3><p>为了满足工作频率越来越高的要求，厂商逐渐降低晶体管的阈值电压Vt，使得晶体管能高速翻转；但是如果阈值电压Vt太低，则晶体管不能完全关断，这将产生很大的静态功耗；</p><p>相关名词：<br>HVT(High V threshold) 高电压阈值<br>LVT (Low V threshold)  低电压阈值<br>SVT(Standard V threshold) 标准电压阈值</p><p>阈值电压与器件速度和泄露功率的关系：<br>阈值电压↓ &#x3D;&gt; 器件速度↑ 泄露功率↑<br>阈值电压↑ &#x3D;&gt; 器件速度↓ 泄露功率↓</p><p>总结：在设计中可以在关键路径上使用低阈值的标准逻辑单元来优化时序；在非关键路径上使用高阈值标准逻辑单元来优化漏电流；</p><p>优点：<br>大大减少系统的静态功耗；<br>没有任何面积开销，工艺库设计是将两种阈值库中的相应单元的面积设计成一样的，这样可以方便替换；</p><h3 id="体偏置"><a href="#体偏置" class="headerlink" title="体偏置"></a>体偏置</h3><p>对同一晶体管而言，阈值电压也会发生变化。晶体管的阈值电压随着CMOS管衬底的偏置电压变化而变化，而阈值电压影响我们的静态功耗，所以我们可以通过改变偏置电压来改变阈值电压。<br>在工作模式下，MOS管的体偏置为0，MOS管处于低阈值状态，翻转速度快；<br>在等待模式下，MOS管的体偏置为反向偏置，处于高阈值状态，漏电流小；</p><p>注意：MOS管的体偏置需要时间，电路由等待模式转为工作模式的时间较长；</p><h2 id="动态低功耗技术"><a href="#动态低功耗技术" class="headerlink" title="动态低功耗技术"></a>动态低功耗技术</h2><h3 id="多电压域"><a href="#多电压域" class="headerlink" title="多电压域"></a>多电压域</h3><p>动态功耗的主要组成部分—翻转功耗，是Vdd的平方，静态功耗中的主要组成部分漏电流和Vdd成正比，所以降功耗最有效的方法就是降电压。<br>但降电压会增加延时，降低门单元的性能，所以很多低功耗技术就是在满足芯片性能要求的前提下，尽可能地降低芯片的工作电压Vdd。<br>如果不同电压域之间的驱动信号与接收信号距离很远，则需插入特殊的驱动单元(Repenter)来增强信号的驱动能力；如果不同的电压域可以单独断电，则需要考虑添加保持寄存器和电压隔离单元；</p><p>代价：<br>需要变压器；因为你拿0.7v的电压域信号去驱动1.0v的电压域很容易导致1.0v的晶体管时时刻刻在漏电，且变压器会造成延时；<br>时序分析不好做；<br>布局时电源网络更加复杂；<br>上电断电顺序可能是有要求的；<br>对于架构设计者而言，主要就是搞清楚电压是影响时序的，确保不会因为多电源域影响系统功能就好；</p><p>多电压域技术可以分为四种：<br>静态多电压技术(MSV)，对不同的模块固定为不同的电压；<br>动态电压频率缩放技术(DVFS)，对于该模块可以选择几种不同的电压配置，同时电压调整一般会同时调整频率，所以就称为动态电压频率缩放技术；<br>自适应电压频率缩放技术(AVFS)，DVFS需要软件根据不同的应用场景选择不同的电压频率配置，如果更进一步，对改模块的电压频率能够自适应地调整，那么就是自适应电压频率缩放技术；<br>电压关断技术(PSO)，如果某个模块在有些情况下不使用了，我们可以关掉这个模块的电压，需要的时候再打开，又称为电源门控，本质上是一种电压调节的特例；</p><h3 id="门控时钟"><a href="#门控时钟" class="headerlink" title="门控时钟"></a>门控时钟</h3><p>直接停掉时钟，这样可以减少动态功耗。实际上在数字芯片中时钟网络占用了很大功耗，可能超过50%。</p><p>举例说明门控时钟的概念：比如寄存器，当EN信号有效的时候才进行寄存，不如用EN信号将时钟信号进行屏蔽。<br>注意！门控时钟虽然是很直接的办法，但一般来说不用自己RTL层面写门控时钟，工具会自动优化，自己写的门控时钟有可能产生毛刺影响性能；</p><p>如果仅将时钟信号和时钟使能信号相与之后的输出作为模块的时钟输入，则可能存在毛刺；避免毛刺的方式有两种：<br>采用锁存门控；若锁存器和与门相差很远，则延迟差别较大，仍可能存在毛刺；若时钟使能信号距离锁存器关断信号很近，可能会不满足锁存器的建立时间从而出现亚稳态；<br>采用寄存门控；用寄存器来寄存EN信号再与上时钟信号得到门控时钟信号；此时需要寄存EN信号的寄存器满足建立时间要求；</p><p>实际中看起来寄存结构的门控时钟问题要少，但在实际的SoC中，使用最多的还是锁存结构的门控时钟；<br>最主要的原因是节省面积！一个DFF由两个锁存器组成，当大量的门控时钟插入到SoC芯片中时，这个节省的面积就相当可观了。<br>当然，这里说的是SoC芯片中使用的标准库单元。如果是FPGA或者用RTL实现，个人认为还是使用寄存器门控+setup约束来实现比较稳妥；</p><p>那在SoC中锁存门控的问题如何解决呢？在实际的SoC芯片中，要使用大量的门控时钟单元，所以通常会把门控时钟做成一个标准单元，由工艺厂商来提供。所以锁存器结构中线延时带来的问题就不存在了，因为是做成一个单元，线延时是可控和不变的，而且还可以通过挑选锁存器和增加延时，总是能满足锁存器的建立时间。这样通过工艺厂预先把门控时钟做成标准单元，这些问题都解决了。</p><p>做门控时钟的时候需要注意以下两点：<br>通常在位宽较大的寄存器上加时钟门控，因为加门控时钟本身也会增加面积和功耗，所以要综合考虑；<br>加了门控时钟之后要保证原本的电路功能不变；</p><p>Tips：<br>RTL编码中，将不用的数据设置成0并不能减少功耗，保持数据不变才能减少翻转，降低功耗。</p><h2 id="RTL级低功耗技术"><a href="#RTL级低功耗技术" class="headerlink" title="RTL级低功耗技术"></a>RTL级低功耗技术</h2><p>对于前端RTL设计而言，<strong>降低功耗无非两点</strong>：<br>对于寄存器，不工作的时候关闭时钟；<br>对于组合逻辑，减少无效的跳变；</p><p>设计中可以考虑的点：</p><ol><li><strong>状态机的编解码</strong>：在各种状态机的编码中，格雷码是最适合低功耗设计的。因为它在状态转换过程中每次只有一个触发器变化，同时，格雷码编码的状态机也消除了依赖于状态组合等式中存在毛刺的风险；</li><li><strong>门控时钟</strong>：编码方式   if（~rst_n） else if（en_load）；</li><li><strong>独热码多路器</strong>：将多输入MUX采用独热码编码方式，可以综合为与门和或门，降低功耗；</li><li><strong>操作数隔离</strong>，操作数隔离就是增加一些选择器件，如果这个操作数不需要的话就不选择它以及不进行这个操作数所需要的相应计算。在sel信号之前通过将sel和数据信号相与可以降低mux前端信号的翻转率；</li><li><strong>资源共享</strong>，将相同的处理使用组合逻辑预先产生，在调用的时候直接调用，不需要把相同的操作复制；</li><li><strong>总线翻转编码</strong>，在当前数据和下一个数据之间的汉明距离（汉明距离指的是两个数中不相同位的数量）大于N&#x2F;2的时，将下一个数据取反后再传输，以减少总线上出现转换的位数量，即总线反转编码；该技术的缺点是需要传输一个额外的控制位，用以表征总线数据是否进行了翻转编码，消耗了系统总线的带宽；</li></ol><p>当模块在某段时间完全不工作的时候，你可以：1、在这段时间里关掉这个模块的时钟；2、检查这个模块的输入，对于还在跳变的输入，将其全部固定为恒定值，这样才能根除这个模块的动态功耗；</p><h2 id="门级优化技术"><a href="#门级优化技术" class="headerlink" title="门级优化技术"></a>门级优化技术</h2><p>个人感觉节省的功耗比较鸡肋，仅做了解即可；</p><h3 id="毛刺的消除"><a href="#毛刺的消除" class="headerlink" title="毛刺的消除"></a>毛刺的消除</h3><p>毛刺指由于电路中信号的传输延迟引起的不必要的翻转；通过插入缓冲器改变信号的传输延迟从而消除信号的毛刺；</p><h3 id="逻辑级优化"><a href="#逻辑级优化" class="headerlink" title="逻辑级优化"></a>逻辑级优化</h3><p>引脚的重分配：对同一个门而言，有可能各Pin的功耗不一致，我们将变化率低的信号连接到低功耗的Pin上就有好处。用负载电容低的引脚去连接快速翻转的信号，降低系统的动态功耗；<br>重排序操作：通过对门级电路的重排序，使得其驱动的门数量降低，从而降低系统的动态功耗；</p><h3 id="物理级优化"><a href="#物理级优化" class="headerlink" title="物理级优化"></a>物理级优化</h3><p>使用低功耗的库；<br>使用低功耗的布局规划；<br>通过布局布线来减少毛刺；<br>在优化布局的时候调整缓冲器和连线的大小；<br>调整晶体管的大小减少负载电容；</p><h3 id="控制输入向量"><a href="#控制输入向量" class="headerlink" title="控制输入向量"></a>控制输入向量</h3><p>系统在睡眠状态下，控制输入向量可以明显减少系统的漏电流。（选择最小漏电流的向量作为组合逻辑的输入）</p><h1 id="以反相器为例解释静态-x2F-动态功耗"><a href="#以反相器为例解释静态-x2F-动态功耗" class="headerlink" title="以反相器为例解释静态&#x2F;动态功耗"></a>以反相器为例解释静态&#x2F;动态功耗</h1><p>反相器的结构如下图所示，由一个PMOS和一个NMOS串联而成，负载电容记为$C_L$。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241657743.png" alt="1"></p><h2 id="动态功耗"><a href="#动态功耗" class="headerlink" title="动态功耗"></a>动态功耗</h2><h3 id="电容充放电引起的动态功耗"><a href="#电容充放电引起的动态功耗" class="headerlink" title="电容充放电引起的动态功耗"></a>电容充放电引起的动态功耗</h3><p>当$C_L$通过PMOS充电时，$V_{C_L}$从0V上升至$V_{DD}$，电路从电源$V_{DD}$上抽取一定的能量，一部分消耗在PMOS上，另一部分被电容$C_L$存储。$V_{out}$由高至低进行电平翻转时，$C_L$通过NMOS放电，之前存储在$C_L$中的能量被NMOS消耗。</p><p>下面计算$V_{out}$由低至高电平翻转的过程从电源上抽走的能量，假设$V_{in}$的电平上升和下降时间为零，即NMOS和PMOS不可能同时导通，此时CMOS反相器可以等效为下图所示的电路。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241704535.png" alt="2"></p><p>$i_{VDD}$和$V_{out}$是随时间变化的，可以看做是时间的函数，在0—dt时间范围内从电源上抽取的能量微元为：</p><p>$$dE_{VDD}&#x3D;i_{VDD}V_{DD}dt$$</p><p>理论上$C_L$充电至$V_{DD}$所用的时间为无穷大，因此$C_L$充电过程中从电源上抽取的总能量为：<br>$$<br>E_{VDD}&#x3D;\int_{0}^{\infty}i_{VDD}(t)V_{DD},dt&#x3D;V_{DD}\int_{0}^{\infty}C_L\frac{d_{V_{out}(t)}}{dt},dt&#x3D;C_LV_{DD}\int_{0}^{\infty},dV_{out}&#x3D;C_LV_{DD}^2<br>$$<br>电容$C_L$在0—dt时间范围内存储的能量微元为：<br>$$<br>d_{E_C}&#x3D;i_{VDD}(t)V_{out}(t)dt<br>$$<br>电容$C_L$充电至$V_{DD}$存储的能量为：<br>$$<br>E_C&#x3D;\int_{0}^{\infty}i_{VDD}(t)V_{out}(t),dt&#x3D;\int_{0}^{\infty}V_{out}(t)C_L\frac{dV_{out}}{dt},dt&#x3D;C_L\int_{0}^{V_{DD}}V_{out},dV_{out}&#x3D;\frac{1}{2}C_LV_{DD}^2<br>$$<br>由$E_{VDD}$和$E_{C}$可以看出，电容$C_L$充电期间从电源抽取的能量只有一半存储到$C_L$中了，另一半被PMOS消耗，而存储到电容$C_L$中的这一半能量将在电容放电期间被NMOS消耗掉，也就是说CMOS反相器每经过一次开关周期（“0”→“1”→“0”）所消耗的能量为$C_LV_{DD}^2$，如果一个反相器每秒开关f次，则功耗为：<br>$$<br>P_{dyn}&#x3D;\frac{E_{VDD}}{T}&#x3D;C_LV_{DD}^2f<br>$$<br>其中，T为开关周期，f为开关频率。</p><h3 id="NMOS和PMOS同时导通（过渡区）引起的功耗"><a href="#NMOS和PMOS同时导通（过渡区）引起的功耗" class="headerlink" title="NMOS和PMOS同时导通（过渡区）引起的功耗"></a>NMOS和PMOS同时导通（过渡区）引起的功耗</h3><p>前面假假设了输入波形的上升、下降时间为零，这是个理想状态，实际上$V_{in}$的上升、下降时间不可能为零，当CMOS反相器处于两个管子同时导通的过渡区时，电源对地有一条直流通路，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241728158.png" alt="3"></p><p>当直流脉冲可近似看做三角形以及输入电平上升与下降时间相等时，每经过一个开关周期（“0” →“1” →“0”）所消耗的能量为：<br>$$<br>E_{dp}&#x3D;E_{dpr}+E_{dpf}<br>$$<br>$E_{dpr}$即$V_{in}$电平上升期间的直流通路能耗，通过上图(b)可以发现，$0{\sim}{\frac{t_{sc}}{2}}$这段时间的瞬时电流$i(t)&#x3D;2\frac{I_{peak}}{t_{sc}}t$，在$\frac{t_{sc}}{2}{\sim}t_{sc}$的这段时间瞬时电流$i(t)&#x3D;-2\frac{I_{peak}}{t_{sc}}t$，$V_{in}$从低至高电平转换期间的能耗为：<br>$$<br>E_{dpr}&#x3D;\int_{0}^{t_{sc}}i(t)V_{DD},dt&#x3D;2\int_{0}^{\frac{t_{sc}}{2}}i(t)V_{DD},dt&#x3D;4V_{DD}\frac{I_{peak}}{t_{sc}}\int_{0}^{\frac{t_{sc}}{2}}t,dt&#x3D;\frac{1}{2}V_{DD}I_{peak}t_{sc}<br>$$<br>同理可得$V_{in}$从高至低电平转换期间的能耗为：<br>$$<br>E_{dpf}&#x3D;\frac{1}{2}V_{DD}I_{peak}t_{sc}<br>$$<br>由此可知电路在过渡区的总能耗为：<br>$$<br>E_{dp}&#x3D;E_{dpr}+E_{dpf}&#x3D;V_{DD}I_{peak}t_{sc}<br>$$<br>所以$V_{in}$一个周期内的平均功耗为：<br>$$<br>P_{dp}&#x3D;\frac{E_{dp}}{T}&#x3D;E_{dp}f&#x3D;V_{DD}I_{peak}t_{sc}f&#x3D;C_{sc}V_{DD}^2f<br>$$<br>从平均功耗的表达式可以看出过渡区的动态功耗是一个类电容功耗，$C_{sc}$为过渡区的等效电容，$t_{sc}$为过渡区时长，f为$V_{in}$的电平跳变频率。</p><h2 id="静态功耗"><a href="#静态功耗" class="headerlink" title="静态功耗"></a>静态功耗</h2><p>理想情况下，CMOS反相器在稳态工作时PMOS与NMOS不会同时导通，这就意味着稳态时电源与地之间没有通路，不会形成通路电流，静态功耗为零，可实际电路里总有一些微弱的泄漏电流$I_{stat}$流过源或漏与衬底之间的反偏二极管，如下图所示，此时的静态功耗为：<br>$$<br>P_{stat}&#x3D;V_{DD}I_{stat}<br>$$<br><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303242223033.png" alt="4"></p><h2 id="总功耗"><a href="#总功耗" class="headerlink" title="总功耗"></a>总功耗</h2><p>显然，CMOS反相器的总功耗可以表示成三个部分的和，即:<br>$$<br>P_{total}&#x3D;P_{dyn}+P_{dp}+P_{stat}&#x3D;(C_LV_{DD}^2+V_{DD}I_{peak}t_{sc})f+V_{DD}I_{stat}<br>$$<br>最主要的功耗是等效电容的充放电造成的$P_{dyn}$，过渡区的功耗$P_{dp}$可以通过调整过渡区宽度控制在限定范围内，静态功耗目前可忽略。</p><blockquote><p>Reference</p><p>Jan M. Rabaey, Anantha Chandrakasan, Borivoje Nikolic, 2004. Digital Integrated Circuits :A Design Perspective ,Second Edition.</p></blockquote>]]></content>
    
    
    <summary type="html">简述芯片的低功耗设计</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>FPGA与ASIC的区别</title>
    <link href="http://david-luge.cn/2023/03/24/IC/Basic/FPGA%E4%B8%8EASIC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://david-luge.cn/2023/03/24/IC/Basic/FPGA%E4%B8%8EASIC%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-03-24T03:39:39.000Z</published>
    <updated>2023-03-24T03:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPGA与ASIC的区别"><a href="#FPGA与ASIC的区别" class="headerlink" title="FPGA与ASIC的区别"></a>FPGA与ASIC的区别</h1><ul><li><p><strong>测试逻辑</strong>：ASIC要考虑SCAN测试和BIST的问题；（DFT：Design For Test）</p></li><li><p><strong>存储资源</strong>：一般而言，ASIC设计中使用的memory是SRAM与Flop&#x2F;Latch Array，前端工程师可以根据不同的存储规模选择合适的类型；而FPGA中memory的种类较多且资源受限，一般有Distributed RAM&#x2F;Block RAM&#x2F;Ultra RAM等，FPGA设计者一般会在微架构设计中根据存储规模更细致地考虑好各memory使用的资源类型；</p></li><li><p><strong>计算资源</strong>：ASIC设计的计算资源主要采用<strong>synopsys designware</strong>、其他vendor或者自主设计的IP；而FPGA设计则主要使用片上的<strong>DSP单元</strong>，DSP单元在FPGA上是hardwired，时序比较好，但功能相对也比较固定，所以FPGA设计者一般会充分DSP单元中固定位宽的乘法器与加法器。在ASIC设计中，累加一般采用加法树设计，而FPGA中则更倾向于使用级联设计，这样可以利用DSP单元间专用的进位布线资源，提高设计的时序；</p></li><li><p><strong>逻辑资源</strong>：ASIC设计中的逻辑资源是标准单元库中的logic cell，而FPGA设计中的逻辑资源是CLB中的LUT（4&#x2F;5&#x2F;6输入LUT，具体看FPGA型号）与MUX。<strong>这里就体现了ASIC和FPGA一个最大区别</strong>：估算逻辑深度的方法不同：FPGA没有逻辑深度，就是一个查找表，查找表的深度仅和输入信号的数目有关；而ASIC是有逻辑深度的，在RTL Coding的时候，需要预估逻辑综合出来的级数，哪怕输入信号不多，但逻辑复杂度大的话，也需要拆成2拍；</p></li><li><p><strong>低功耗设计</strong>：ASIC的低功耗设计可以采用clock gating与power gating，但FPGA无法做到power gating，clock信号在FPGA中有专用的布线资源，因此也不建议使用clock gating的方式，但可以用clock enable的方式替代；</p></li><li><p><strong>时钟复位</strong>：clock信号在FPGA中有专用的布线资源，而ASIC内的时钟为了更小的skew会专门进行CTS；ASIC设计中一般使用异步复位，由后端负责处理复位树，FPGA设计中则建议使用同步复位；</p></li></ul><h2 id="FPGA与ASIC在代码层面的区别"><a href="#FPGA与ASIC在代码层面的区别" class="headerlink" title="FPGA与ASIC在代码层面的区别"></a>FPGA与ASIC在代码层面的区别</h2><ul><li><p>ASIC更趋于保守，对逻辑的任何改动都要三思，并要做备选的选择，以防改错，RTL的任何修改几乎都是增量修改；</p></li><li><p>ASIC对coding style的要求更高，所有模块的coding风格要求一致，这样有利于后端以及后续的check；</p></li><li><p>ASIC要考虑SCAN测试和BIST的问题，所以设计的时候需要为SRAM做BIST插入，需要为SCAN预留接口；虽然大部分都是工具干的，但是RTL作者也需要手动做一些顶层工作，比如SCAN时钟的来源等逻辑；</p></li><li><p>ASIC时序预见性更好，可调整度高，所以可以写很大的逻辑；</p><p><strong>关键词：保守改动、代码风格、测试逻辑、逻辑级数</strong></p></li></ul>]]></content>
    
    
    <summary type="html">简述芯片与FPGA的区别</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>芯片设计流程简述</title>
    <link href="http://david-luge.cn/2023/03/24/IC/Basic/%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
    <id>http://david-luge.cn/2023/03/24/IC/Basic/%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</id>
    <published>2023-03-24T03:38:39.000Z</published>
    <updated>2023-03-24T03:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="芯片设计流程简述"><a href="#芯片设计流程简述" class="headerlink" title="芯片设计流程简述"></a>芯片设计流程简述</h1><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>分析用户或市场的需求，并将其翻译成对芯片产品的技术要求；</p><h3 id="2、算法-x2F-架构设计"><a href="#2、算法-x2F-架构设计" class="headerlink" title="2、算法&#x2F;架构设计"></a>2、算法&#x2F;架构设计</h3><ul><li>算法设计：设计和优化芯片中所使用的算法；这一阶段一般使用高级编程语言(如C、C++)，利用算法级建模和仿真工具(如MATLAB)进行浮点和定点的仿真，进而对算法进行评估和优化；</li><li>架构设计：根据设计的功能需求和算法分析的结果，设计芯片的架构，并对不同的方案进行比较，选择性能价格最优的方案。这一阶段可以用SystemC语言对芯片架构进行模拟和分析；</li></ul><h3 id="3、RTL设计"><a href="#3、RTL设计" class="headerlink" title="3、RTL设计"></a>3、RTL设计</h3><p>使用HDL语言(Verilog、VHDL)完成对设计实体的RTL级描述。</p><h3 id="4、RTL验证-功能仿真-x2F-前仿"><a href="#4、RTL验证-功能仿真-x2F-前仿" class="headerlink" title="4、RTL验证(功能仿真&#x2F;前仿)"></a>4、RTL验证(功能仿真&#x2F;前仿)</h3><p>使用仿真工具或者其他RTL代码分析工具，验证RTL代码的质量和性能；</p><h3 id="5、综合"><a href="#5、综合" class="headerlink" title="5、综合"></a>5、综合</h3><p>从RTL代码生成描述实际电路的门级网表文件；</p><h3 id="6、门级验证-后仿"><a href="#6、门级验证-后仿" class="headerlink" title="6、门级验证(后仿)"></a>6、门级验证(后仿)</h3><p>对综合产生的门级网表进行验证，这一阶段通常会使用仿真、静态时序分析和形式验证等工具；</p><h3 id="7、布局布线"><a href="#7、布局布线" class="headerlink" title="7、布局布线"></a>7、布局布线</h3><p>后端对综合产生的门级网表进行布局规划(FloorPlanning)、布局(Placement)、布线(Routing)，生成生产用的版图；</p><h3 id="8、电路参数提取"><a href="#8、电路参数提取" class="headerlink" title="8、电路参数提取"></a>8、电路参数提取</h3><p>确定芯片中互连线的寄生参数，从而获得门级的延时信息；用于更准确地后仿以及静态时序分析；</p><h3 id="9、版图后验证"><a href="#9、版图后验证" class="headerlink" title="9、版图后验证"></a>9、版图后验证</h3><p>根据后端设计后取得的新的延时信息，再次验证设计能否可以实现所有的功能、是否达到所有的性能指标；</p><h3 id="10、芯片生产"><a href="#10、芯片生产" class="headerlink" title="10、芯片生产"></a>10、芯片生产</h3><p>在特定的芯片工艺线上制造出芯片；</p><h3 id="11、芯片测试"><a href="#11、芯片测试" class="headerlink" title="11、芯片测试"></a>11、芯片测试</h3><p>对制造好的芯片进行测试，检测生产中产生的缺陷和问题；</p>]]></content>
    
    
    <summary type="html">简述芯片的设计流程</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>修Timing Violation的若干方法</title>
    <link href="http://david-luge.cn/2023/03/23/IC/Basic/%E4%BF%AETiming%20Violation%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%96%B9%E6%B3%95/"/>
    <id>http://david-luge.cn/2023/03/23/IC/Basic/%E4%BF%AETiming%20Violation%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-23T01:15:39.000Z</published>
    <updated>2023-03-23T01:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://mp.weixin.qq.com/s/DCMRXW-bF8Z7r7SPnRC5jQ">探STA|修timing violation的二十一种方法</a></p><p>如有任何版权问题请联系博主。</p></blockquote><p>其实修setup violation和hold violation是对立统一的，例如我们通过insert buffer修一个setup violation，那么有时我们也可以通过remove buffer修一个hold violation。</p><h1 id="Fix-setup-violation"><a href="#Fix-setup-violation" class="headerlink" title="Fix setup violation"></a>Fix setup violation</h1><p>Setup violation的本质是一个时钟周期内上一级寄存器锁存的数据无法正确地传输到下一级寄存器并被正确地锁存，也就是数据跑的太慢了。或者换个思路，是当前寄存器的时钟跑的快了。</p><p>插buffer来fix setup violation主要从信号的slew考虑，减buffer来fix setup violation主要从cell delay的角度考虑。选择何种方式主要看load capacitance。</p><p>首先看一下slew的解释，以及与cell delay的相关参数。</p><blockquote><p>A slew rate is defined as a rate of change.</p><p>A simple timing model is a linear delay model, where the delay and the output transition time of the cell are represented as linear functions of the two parameters: input transition time and the output load capacitance.</p><p>—《Static timing analysis for nanometer designs》</p></blockquote><p>下面两个评论是从插buffer的角度考虑</p><blockquote><p>Buffers increases drive strength of signal and so delay decreases. This is like a repeater in a communication systems .  where repeater will re-shape the signal to match it to ideal one and thus time taken by signal to transition from 1-&gt;0 and 0-&gt;1 decreases.</p></blockquote><blockquote><p>If you insert the buffer, the signal strength will be improved. This will charge the load Cap fast. When the Cap gets charged fast, you will have less rise &amp; fall delay. This will reduce the delay. That’s it.</p></blockquote><p>下面的评论是从减buffer的角度考虑</p><blockquote><p>Decrese the load Cap. can decrease the cell delay. until the load Cap, is much smaller than the output Cap, of the cell itself, the delay will nearly not change at all. We can call the delay instrinsic delay.<br>If a timing path consists of cells with instrinsic delay, insert buffer will just increase the delay.</p></blockquote><h2 id="减少Data-Path上的Buffer数量"><a href="#减少Data-Path上的Buffer数量" class="headerlink" title="减少Data Path上的Buffer数量"></a>减少Data Path上的Buffer数量</h2><p>这会减少cell delay。cell级数减少了，这种减小也不是单纯地几何倍数的减小，减小的程度应该是<strong>小于</strong>remove buffer的数量×原来的cell delay；因为net wire变长之后，电流从net一端传播到net另一端衰减更加严重，对器件的充电速度变慢。</p><p>但是该方式会增加net delay，net wire总长度变大，RC参数变大，RC曲线更加绵长。</p><h2 id="使用一对inverter替换Buffer"><a href="#使用一对inverter替换Buffer" class="headerlink" title="使用一对inverter替换Buffer"></a>使用一对inverter替换Buffer</h2><p>我们知道buffer的结构基本上等价于两个inverter，使用一对inverter替换buffer可以减少data path上总的delay。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241516536.png" alt="1"></p><p>和只用一个buffer相比，一对反相器会两倍的减少信号的transition time，这会减少RC delay。而一个buffer的cell delay约等于一对inverter的cell delay，所以总的delay减少了。</p><h2 id="Swap-VT"><a href="#Swap-VT" class="headerlink" title="Swap VT"></a>Swap VT</h2><p>这就是换cell的阈值电压(voltage threshold)，就是把HVT(High)换成SVT&#x2F;RVT(Standard&#x2F;Regular)或者LVT(Low)。</p><p>相同情况下low VT的cell的栅极阈值电压更低，所以对于该cell本身其slew更小；相同情况下low VT的cell的栅极导通电流更大，所以其对于后续的net wire的充电速度更快。</p><p>所以low VT的cell相当于从cell delay和net delay两种角度去减小了总的delay。</p><p>不过，Low VT的cell静态电流更大，静态功耗也更大。</p><h2 id="Size-up-cell"><a href="#Size-up-cell" class="headerlink" title="Size-up cell"></a>Size-up cell</h2><p>一般来说大驱动的cell具有更高的speed，但是可能某些cell类型，更大的cell可能速度更慢。</p><p>不过，这样也会使得power更高，area更大。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241522391.png" alt="2"></p><h2 id="Insert-buffer"><a href="#Insert-buffer" class="headerlink" title="Insert buffer"></a>Insert buffer</h2><p>插buffer会减小transition time，这会减小net delay。如果总的net delay的减小 大于 cell delay的增加；那么总的delay就会减小。</p><p>不过，这也会导致power和area增加。</p><h2 id="Insert-repeater"><a href="#Insert-repeater" class="headerlink" title="Insert repeater"></a>Insert repeater</h2><p>这跟insert buffer类似，不过区别在于场景的不同。</p><p>Long net wire会导致大的RC delay，如果insert repeater可以将net wire切分成多段可以减少总的net delay；因为总的net delay的减少 大于 cell delay的增加，所以这是一种有效的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241525219.png" alt="3"></p><h2 id="调整cell在版图的location"><a href="#调整cell在版图的location" class="headerlink" title="调整cell在版图的location"></a>调整cell在版图的location</h2><p>本质也是减少net delay.</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241527977.png" alt="4"></p><h2 id="调整clock-skew"><a href="#调整clock-skew" class="headerlink" title="调整clock skew"></a>调整clock skew</h2><p>就是通过skew的调整向后一级接setup的余量。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241531184.png" alt="5"></p><h2 id="给critial-path用NDR走线"><a href="#给critial-path用NDR走线" class="headerlink" title="给critial path用NDR走线"></a>给critial path用NDR走线</h2><p>与CTS绕线原理类似，就是减少net wire的RC和cross-talk。</p><p>NDR全称是Non default routing rule，非默认绕线规则。默认的绕线规则都是单位宽度，对于clock path或者critial path可以采取双倍宽度的绕线宽度。</p><h2 id="手动走线"><a href="#手动走线" class="headerlink" title="手动走线"></a>手动走线</h2><p>手动换高层走线或者手动把net wire捋直。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241552917.jpg" alt="6"></p><p>直观感受一下，上图中橘色的为金属，高层的走线粗，电阻小，所以RC小，delay小。</p><h2 id="修crosstalk"><a href="#修crosstalk" class="headerlink" title="修crosstalk"></a>修crosstalk</h2><p>修crosstalk除了加shielding和NDR rule以外，还有一种方法是：违例点周围的各种走线remove掉或者拉的远一点。</p><h2 id="降频"><a href="#降频" class="headerlink" title="降频"></a>降频</h2><p>如果实在修不下去，该降就降吧。</p><h2 id="换库"><a href="#换库" class="headerlink" title="换库"></a>换库</h2><p>实在不行，也可以选用一些speed更快的库，或者自己定做一些库。</p><p>该方法也分全局换库和局部换库，全局就是整个design都换，局部就是让critical path用一些特殊的库。</p><h2 id="调整floorplan"><a href="#调整floorplan" class="headerlink" title="调整floorplan"></a>调整floorplan</h2><p>通过调整floorplan使得具有交互的module的位置更合理。</p><h2 id="split-multi-bit-flip-flop"><a href="#split-multi-bit-flip-flop" class="headerlink" title="split multi-bit flip-flop"></a>split multi-bit flip-flop</h2><p>因为MBFF cell内部的<strong>公共</strong>走线和<strong>公共</strong>的晶体管更多，所以其本身的load Cap更大，则transition time就更大，delay就更大。因此可以通过拆分MBFF Cell来fix setup violation。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241557552.png" alt="7"></p><h2 id="使用PBA代替GBA"><a href="#使用PBA代替GBA" class="headerlink" title="使用PBA代替GBA"></a>使用PBA代替GBA</h2><p>GBA 的全称是（Graph Base Analysis）。STA工具计算 timing 时，默认是采用 GBA 模式来报 timing 的，是工具默认的分析方式。它是说工具在从lib中读取cell的delay的时候，永远是读取<strong>由最差transition产生的delay</strong>。PBA是path based analysis，指的是我要分析哪条timing path，就用这条timing path的transition来查cell的delay。pba算法复杂，分析时间大大提高，但结果更为精确。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241558706.png" alt="8"></p><h2 id="打拍"><a href="#打拍" class="headerlink" title="打拍"></a>打拍</h2><p>打拍就是在reg2reg path中间再加一个reg，一个周期搞不定的事情，分成两个周期来做。</p><h2 id="改RTL"><a href="#改RTL" class="headerlink" title="改RTL"></a>改RTL</h2><p>如果RTL综合出来本身的timing path逻辑级数太长或者组合逻辑太多，可以考虑改RTL。</p><h1 id="Fix-Hold-violation"><a href="#Fix-Hold-violation" class="headerlink" title="Fix Hold violation"></a>Fix Hold violation</h1><h2 id="Add-Delay"><a href="#Add-Delay" class="headerlink" title="Add Delay"></a>Add Delay</h2><p>可以使用buffer、inverter pairs、delay cell来修hold violation。</p><p>由于hold violation path的start point和end point可能对应着别的setup violation path（或者setup slack比较紧张），所以add delay时需要格外小心。</p><p>此外，一般不在两条timing path的common path增加delay。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241604159.png" alt="9"></p><h2 id="Size-down-cell"><a href="#Size-down-cell" class="headerlink" title="Size-down cell"></a>Size-down cell</h2><p>尽可能去size end-point附近的cell，这样对别的path影响较小。</p><p>另外修crosstalk和手动走线也可修hold。</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>有时候面试官会问，流片完了还是有setup&#x2F;hold violation怎么办，可以从以下角度去考虑回答。</p><p>Fix setup violation：降频使用；</p><p>Fix hold violation：在setup margin比较足的情况下可以降压，不足的情况下可以降频降压使用；</p>]]></content>
    
    
    <summary type="html">简要介绍了修Timing Violation的若干方法</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>Physical aware synthesis是什么</title>
    <link href="http://david-luge.cn/2022/11/04/IC/Basic/Physical%20Synthesis%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://david-luge.cn/2022/11/04/IC/Basic/Physical%20Synthesis%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2022-11-04T01:15:39.000Z</published>
    <updated>2022-11-04T01:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://mp.weixin.qq.com/s/wX1rPgGrn4IwHfXc-f_e9Q">论综合：为什么做physical aware synthesis</a></p><p>如有任何版权问题请联系博主。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工艺的更新给整个半导体行业带来了巨大的挑战，从生产设备、EDA再到芯片设计实现都需要紧跟更新的工艺点亮新技能。下图直观地呈现了从65nm到16&#x2F;14nm由工艺进步引入的需要额外考虑的因素。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202211032356068.jpg" alt="phsy"></p><p>在芯片设计实现流程中，P&amp;R工程师对工艺带来的挑战感受会更直接，综合、STA、DFT 也都有新的方法学的更新，但大都被 EDA 工具严实地包了起来，就拿综合来说，相对于传统综合而言最大的更新莫过于physical aware synthesis。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>最根本的目的就是减少前后端的迭代次数，前后端迭代次数多的根本原因是前后端的关联度(correlation)差，而correlation需要从timing 和 congestion 两个方面来看：</p><h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><p>综合优化的对象是 timing path，而 Timing path delay &#x3D; net delay + cell delay，90nm之前 timing path delay 由cell delay 主导，而进入65nm，net delay所占比例日渐增加，进入40nm之后几乎跟cell delay平分秋色。所以从40nm开始physical synthesis 被硅农熟知，因为physical aware synthesis在优化过程中可以看到更精确的net delay。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092022883.jpeg" alt="preview"></p><p><strong>那么为什么logical synthesis不能精确计算net delay呢？</strong>这就要回看一下传统综合是如何估算 net delay 的。传统综合俗称logic synthesis，它根据WLM 来估算net delay。WLM (wire load model) 由foundry 提供，WLM通常包括面积系数、电容系数和单位长度的电阻系数，以及一个用于估计net长度的表格，表的index是 fanout，直白地说就是将net的长度拟合成fanout 的函数。</p><p>按照WLM来计算，下图中的blue器件到red器件的所有net长度都一样，net delay也一样，而实际上 net 行走的姿势五花八门，根本就不可能一样，缺点显而易见。另一个缺陷是WLM 的单位电容电阻是一个常值，无法模拟不同layer RC 值的差异，而工艺进入16nm 之后，必须要考虑 layer aware 的 net delay。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092025068.jpeg" alt="preview"></p><p>在40nm甚至28nm，依然有人在用传统的方式来做综合，做法简单粗暴加时钟周期30%甚至更多的过约，这样做是可以cover net delay，但是实在是过犹不及。据统计在一颗芯片里80%以上的线都是短线，为了cover那不到20%的线，付出的代价就是更大的面积及更多的功耗。</p><p><strong>那Physical synthesis是如何更精确的计算net delay？</strong>要精确计算net delay必须要知道net的行走姿势，而要知道net 的行走姿势必需要知道：它来自哪里？要去向何方？这就需要知道cell 的位置，cell 位置确定了之后，综合工具会做global 绕线，根据global 绕线的结果来估算net delay。cell 位置由placement 确定，所以如今综合工具都集成了 placement 引擎，这也是做 physical synthesis 的关键所在。目前大概有两种做place的方式：</p><ul><li>做完优化跟mapping之后，再做place，操作对象是std cell；</li><li>在elaborate 之后优化之初就做place, 即所谓的 early physical, 早期阶段针对module 做palce，mapping之后再以std cell为对象做place；</li></ul><p>下图是谷歌上随便找的一张图，只为显示什么是module place,  从Layout 上看每一个颜色对应一个 module。综合工具基本都按 translation + optimization + mapping 三大步来走， 所有结构的选择跟大部分优化的动作都在 optimization 这一步完成，如果可以在 optimization 时就知道 module 的位置信息，优化会更有的放矢会更能『精准打击』，所以 Early physical 十分必要。现在看到的趋势是把更多的物理信息拿到前端来，越早考虑物理信息得到的结果会越好。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092031003.jpeg" alt="preview"></p><p>结论：physial synthesis根据真实的物理信息，用跟P&amp;R一致的 place 引擎跟 global route 引擎，可以精确估算 net delay，并且是layer aware的。通常physical synthesis 只需过约时钟周期5%~10%即可，用于cover legalization跟detail route 的影响。</p><h3 id="Congestion"><a href="#Congestion" class="headerlink" title="Congestion"></a>Congestion</h3><p>同样由于工艺进步，集成度提高，单位面积上要走的线骤增，所以 congestion 成了一个从RTL 设计就要开始关注的问题，否则到了绕线的时候绕不通，前面所做的一切都成了无用功。很显然，logical 综合是无法考虑 congestion 的，要在综合阶段做congestion优化必须要 physical synthesis.</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092033144.jpeg" alt="preview"></p><p>其实不论PPA还是congestion主导决定权都在进实现之前，<strong>架构算法设计</strong>，才是真正决定一切的『权贵』，所以才说实现是个没有灵魂的工种，只要按着 设计&#x2F;EDA&#x2F;foundry 定的规则往下走就可以，切忌的就是『发挥』。</p><p>对于congestion，综合工具能做的基本只有两件事：选结构跟推cell。至于选结构，一个例子就是把一个大MUX 拆成多级MUX用于解congestion。推cell这一点完全依赖于EDA 工具，如果你不知道如何做，那就找AE要变量或 option 让工具在综合做place时将 congestion 严重区域的cell推散。除此之外，还有一点可以人为干预，禁用或让工具少用size 小的复杂cell。</p><p>要特别说明一点，在16nm之后，layer的影响特别大，所以综合用的DEF一定要有special net 部分，也就是你的power plan，让工具在综合时清楚地知道哪些layer的绕线资源已经被占用。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cse.unl.edu/~seth/990/Pubs/What%20is%20physical%20synthesis.pdf">What is Physical Synthesis_IBM</a></p><p><a href="https://www.synopsys.com/glossary/what-is-physical-synthesis.html">What is Physical Synthesis?_synopsys</a></p>]]></content>
    
    
    <summary type="html">简要介绍了Physical aware synthesis的目的及优势</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>RTL Coding Style</title>
    <link href="http://david-luge.cn/2022/10/10/IC/Basic/RTL%20Coding%20Style/"/>
    <id>http://david-luge.cn/2022/10/10/IC/Basic/RTL%20Coding%20Style/</id>
    <published>2022-10-10T11:15:39.000Z</published>
    <updated>2022-10-10T11:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RTL-Coding-Style"><a href="#RTL-Coding-Style" class="headerlink" title="RTL Coding Style"></a>RTL Coding Style</h1><h2 id="标准的文件头"><a href="#标准的文件头" class="headerlink" title="标准的文件头"></a>标准的文件头</h2><p>在每一个版块的开头一定要使用统一的文件头，其中包括作者名，模块名，创建日期，概要，更改记录，版权等必要信息。</p><p>建议使用以下的文件头</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************************************************</span></span><br><span class="line"><span class="comment">// COPYRIGHT(c) XDU ImgLab</span></span><br><span class="line"><span class="comment">// All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Module name  :  Module_name of this file just as “tx_fifo”</span></span><br><span class="line"><span class="comment">// Full name    :  Full English name of this abbreviation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Author       :  Athor/ID </span></span><br><span class="line"><span class="comment">// Email        :  Author’s email</span></span><br><span class="line"><span class="comment">// Abstract     :  Describe the function of the module briefly </span></span><br><span class="line"><span class="comment">// Character Set:  GB-2312</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Modification history</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Date       By        Version       Change Description            </span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------- </span></span><br><span class="line"><span class="comment">// 22/10/10   David     v0.1          first try </span></span><br><span class="line"><span class="comment">// *********************************************************************</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标准的module格式"><a href="#标准的module格式" class="headerlink" title="标准的module格式"></a>标准的module格式</h2><p>对于模块的书写采用统一的格式便于项目内部成员的理解和维护，其内容解释如下：</p><ul><li>端口定义按照输入，输出，双向的顺序；</li><li>模块名、模块例化名统一，例化名前加小写u_以区分 （ 多次例化另加标识 ），三者关系：<ul><li>文件名 ：xxx .v  (小写)</li><li>模块名 ：xxx      (小写)</li><li>例化名 ：u_xxx</li></ul></li></ul><h2 id="一致的排版"><a href="#一致的排版" class="headerlink" title="一致的排版"></a>一致的排版</h2><h3 id="一致的缩排"><a href="#一致的缩排" class="headerlink" title="一致的缩排"></a>一致的缩排</h3><ul><li><p>统一的缩排取4个空格宽度（注意尽量别使用TAB键缩进，不同的IDE对TAB缩进的解释可能不同）</p></li><li><p>输入输出信号的宽度定义与关键字之间，信号名与宽度之间要用空格分开；所有宽度定义对所有信号名对齐，代码风格统一如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>   [<span class="number">3</span>:<span class="number">0</span>]    input_a   ;    <span class="comment">// *****</span></span><br><span class="line"><span class="keyword">input</span>            input_b   ;    <span class="comment">// *****</span></span><br><span class="line">       …</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">127</span>:<span class="number">0</span>]  output_a ;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]   output_b ;</span><br><span class="line"><span class="keyword">output</span>           output_c ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="一致的begin-end书写方式"><a href="#一致的begin-end书写方式" class="headerlink" title="一致的begin  end书写方式"></a>一致的begin  end书写方式</h3><p>always中，一定要用begin end区分，格式和代码风格统一如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (postedge clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">        syn_rst&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            syn_rst&lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            syn_rst&lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>if else中仅有一个语句行时，不要使用begin end；如果有多个语句行时，注意缩进四个空格。</p><h2 id="一致的信号命名风格"><a href="#一致的信号命名风格" class="headerlink" title="一致的信号命名风格"></a>一致的信号命名风格</h2><table><thead><tr><th align="center">全称</th><th align="center">缩写</th><th align="center">中文含义</th></tr></thead><tbody><tr><td align="center">acknowledge</td><td align="center">ack</td><td align="center">应答</td></tr><tr><td align="center">address</td><td align="center">addr(ad)</td><td align="center">地址</td></tr><tr><td align="center">arbiter</td><td align="center">arb</td><td align="center">仲裁</td></tr><tr><td align="center">check</td><td align="center">chk</td><td align="center">校验，如CRC校验</td></tr><tr><td align="center">clock</td><td align="center">clk</td><td align="center">时钟</td></tr><tr><td align="center">config</td><td align="center">cfg</td><td align="center">配置信息</td></tr><tr><td align="center">control</td><td align="center">ctrl</td><td align="center">控制</td></tr><tr><td align="center">count</td><td align="center">cnt</td><td align="center">计数</td></tr><tr><td align="center">data  in</td><td align="center">din(di)</td><td align="center">数据输入</td></tr><tr><td align="center">data  out</td><td align="center">dout(do)</td><td align="center">数据输出</td></tr><tr><td align="center">decode</td><td align="center">de</td><td align="center">译码</td></tr><tr><td align="center">decrease</td><td align="center">dec</td><td align="center">减一</td></tr><tr><td align="center">delay</td><td align="center">dly</td><td align="center">延迟</td></tr><tr><td align="center">disable</td><td align="center">dis</td><td align="center">不使能</td></tr><tr><td align="center">error</td><td align="center">err</td><td align="center">错误（指示）</td></tr><tr><td align="center">enable</td><td align="center">en</td><td align="center">使能</td></tr><tr><td align="center">frame</td><td align="center">frm</td><td align="center">帧</td></tr><tr><td align="center">generate</td><td align="center">gen</td><td align="center">生成，如CRC生成</td></tr><tr><td align="center">grant</td><td align="center">gnt</td><td align="center">申请通过</td></tr><tr><td align="center">increase</td><td align="center">inc</td><td align="center">加一</td></tr><tr><td align="center">input</td><td align="center">in(i)</td><td align="center">输入信号</td></tr><tr><td align="center">length</td><td align="center">len</td><td align="center">（帧、包）长</td></tr><tr><td align="center">output</td><td align="center">out(o)</td><td align="center">输出信号</td></tr><tr><td align="center">priority</td><td align="center">pri</td><td align="center">优先级</td></tr><tr><td align="center">pointer</td><td align="center">ptr</td><td align="center">指针</td></tr><tr><td align="center">rd  enable</td><td align="center">ren</td><td align="center">读使能</td></tr><tr><td align="center">read</td><td align="center">rd</td><td align="center">读（操作）</td></tr><tr><td align="center">ready</td><td align="center">rdy</td><td align="center">应答信号或准备好</td></tr><tr><td align="center">receive</td><td align="center">rx</td><td align="center">（帧数据）接收</td></tr><tr><td align="center">request</td><td align="center">req</td><td align="center">（服务、仲裁）请求</td></tr><tr><td align="center">reset</td><td align="center">rst</td><td align="center">复位信号</td></tr><tr><td align="center">souce</td><td align="center">scr</td><td align="center">源（端口）</td></tr><tr><td align="center">ststistics</td><td align="center">stat</td><td align="center">统计</td></tr><tr><td align="center">timer</td><td align="center">tmr</td><td align="center">定时器</td></tr><tr><td align="center">temporary</td><td align="center">tmp</td><td align="center">临时</td></tr><tr><td align="center">transmit</td><td align="center">tx</td><td align="center">发送（帧数据）相关</td></tr><tr><td align="center">valid</td><td align="center">vld(v)</td><td align="center">有效、校验正确</td></tr><tr><td align="center">wr enable</td><td align="center">wen</td><td align="center">写使能</td></tr><tr><td align="center">write</td><td align="center">wr</td><td align="center">写操作</td></tr></tbody></table><ol><li>端口、信号、变量名的所有字母小写；函数名、宏定义、参数定义用大写；</li><li>使用简称、缩略词（加上列表）；</li><li>基于含义命名（避免以数字命名的简单做法），含义可分段（最多分三段），每一小段之间加下划线”_”，如tx_data_val；命名长度一般限制在20个字符以内；</li><li>低电平有效信号，加后缀”_n”，如 rst_n；</li><li>无条件寄存的寄存信号在原信号上加d1、d2… 如原信号 data_in，寄存一拍data_in_d1，寄存两拍data_in_d2；</li><li><strong>不能用 ”reg”作为最后的后缀名</strong>，因为综合工具会给寄存器自动加上reg后缀, 如果命名里就用reg作为后缀名则扰乱了网表的可读性。</li></ol><h2 id="统一的表达式书写"><a href="#统一的表达式书写" class="headerlink" title="统一的表达式书写"></a>统一的表达式书写</h2><h3 id="括号的使用"><a href="#括号的使用" class="headerlink" title="括号的使用"></a>括号的使用</h3><p>如果一个表达式的分组情况不是很明显时，加上括号有助于理解。</p><p>例如下面的代码加上括号就清晰很多。</p><p><code>if (&amp;a==1’b1&amp;&amp;!flag==1’b1||b==1’b1)</code></p><p>改为：</p><p><code>if ((&amp;a==1’b1)&amp;&amp;(!flag==1’b1)||(b==1’b1))</code></p><h3 id="适当的使用空格"><a href="#适当的使用空格" class="headerlink" title="适当的使用空格"></a>适当的使用空格</h3><p>一般表达式在运算符的两侧要各留出一个空格，但定义比较长的表达式，去掉优先级高的运算符前的空格，使其与运算对象紧连在一起，可以更清晰的显示表达式结构。</p><p>还是上面的例子</p><p><code>if ((&amp;a==1’b1)&amp;&amp;(!flag==1’b1)||(b==1’b1))</code></p><p>改为</p><p><code>if ( (&amp;a==1’b1) &amp;&amp; (!flag==1’b1) || (b==1’b1) )</code></p><p><strong>”&lt;&#x3D;”, ”&#x3D;”,运算符前后都要加空格。</strong></p><h3 id="赋值要指明比特宽度"><a href="#赋值要指明比特宽度" class="headerlink" title="赋值要指明比特宽度"></a>赋值要指明比特宽度</h3><p><strong>赋值或者条件判断时要注明比特宽度，注意表达式的位宽匹配。</strong>如：</p><p>reg [4:0] signal_a;</p><p>错误情况：  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal_a &lt;= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signal_a == <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">signal_a &lt;= signal_b[<span class="number">3</span>:<span class="number">0</span>]+<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>正确情况：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal_a &lt;= <span class="number">5&#x27;d5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(signal_a == <span class="number">5&#x27;d5</span>)</span><br><span class="line"></span><br><span class="line">signal_a &lt;= &#123;<span class="number">1&#x27;b0</span>, signal_b[<span class="number">3</span>:<span class="number">0</span>]+<span class="number">5&#x27;d4</span>;</span><br></pre></td></tr></table></figure><p>因为工具默认是32位宽，如果不注明位宽，工具检查会报warning，而且这样增加了设计的严谨性。</p><h2 id="统一的语句书写―条件判断结构书写方式"><a href="#统一的语句书写―条件判断结构书写方式" class="headerlink" title="统一的语句书写―条件判断结构书写方式"></a>统一的语句书写―条件判断结构书写方式</h2><h3 id="条件的完整性"><a href="#条件的完整性" class="headerlink" title="条件的完整性"></a>条件的完整性</h3><p>if else搭配使用，对于缺省的条件要写”else；”；</p><p>if else的条件判别式要全面，比如”if(a &#x3D;&#x3D; 1’b0)”;</p><p>case中的缺省条件要写”default”；</p><h3 id="”if-else”结构：适用于复杂条件判断的语句"><a href="#”if-else”结构：适用于复杂条件判断的语句" class="headerlink" title="”if else”结构：适用于复杂条件判断的语句"></a>”if else”结构：适用于复杂条件判断的语句</h3><p>对于复杂的条件判断，使用” ? : “如果不仔细分析条件的每一条路径，就让读代码的人搞不清它是到底要做什么。例如：</p><p><code>C = (!Ic&amp;&amp;!rc)?1&#39;b0:(Ic?rc:Ic);</code></p><p>改为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(Ic <span class="keyword">or</span> rc) <span class="keyword">begin</span>    <span class="comment">//if else</span></span><br><span class="line">    <span class="keyword">if</span> ( (Ic==<span class="number">0</span>) &amp;&amp; (rc==<span class="number">0</span>) )</span><br><span class="line">        c = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ic==<span class="number">1</span>)</span><br><span class="line">        c = rc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = Ic;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>简单的条件判断，我们可以使用三目符；当涉及复杂的条件判断，使用IF-ELSE结构以获得清晰的结构便于理解和维护。</p><h3 id="IF-ELSE结构-VS-CASE结构"><a href="#IF-ELSE结构-VS-CASE结构" class="headerlink" title="IF-ELSE结构 VS CASE结构"></a>IF-ELSE结构 VS CASE结构</h3><p>IF-ELSE综合的结果可能是与或非门，也可能是一组多路选择器；而CASE综合结果一般会是多路选择器，但对于可以优化的CASE综合工具会综合出更简单的结构。</p><p>所有对于可以写出平行结构的条件，优先写成case结构，例如地址译码等。条件之间有重复和嵌套的情况则是写成IF-ELSE结构。</p><h3 id="Finite-State-Machine"><a href="#Finite-State-Machine" class="headerlink" title="Finite State Machine"></a>Finite State Machine</h3><p>不允许有模糊不清的状态机模式，所有的状态机必须清晰明了。</p><p>我们要求将状态机的时序部分和组合逻辑部分分开，建议采用三段式结构。</p><h2 id="统一格式的always程序块的书写"><a href="#统一格式的always程序块的书写" class="headerlink" title="统一格式的always程序块的书写"></a>统一格式的always程序块的书写</h2><h3 id="always-中的变量的赋值方式―阻塞与非阻塞赋值"><a href="#always-中的变量的赋值方式―阻塞与非阻塞赋值" class="headerlink" title="always 中的变量的赋值方式―阻塞与非阻塞赋值"></a>always 中的变量的赋值方式―阻塞与非阻塞赋值</h3><p>当进行时序逻辑建模时，always块中使用非阻塞赋值，“&lt;&#x3D;”；</p><p>参考如下代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">if</span> (rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">        myreg &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        myreg &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当进行组合逻辑建模时，always块中使用阻塞赋值，“&#x3D;”；</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(addr) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (addr)</span><br><span class="line">        <span class="number">2&#x27;b00</span> : cs0_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="number">2&#x27;b01</span> : cs0_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="number">2&#x27;b10</span> : cs0_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="number">2&#x27;b11</span> : cs0_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">default</span>: cs0_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="always中变量赋值的唯一性"><a href="#always中变量赋值的唯一性" class="headerlink" title="always中变量赋值的唯一性"></a>always中变量赋值的唯一性</h3><p>组合always块一定要注意敏感量列表中的触发项完整且不冗余；如果不是这样，综合的电路会与实际设计不符合，会报warning；这边建议使用<code>always @(*)</code>的写法描述组合always块。</p><p>不要再多个always模块中对同一个reg型变量进行赋值；</p><p>建议不要在一个always块里给多个变量赋值。如果将一组条件相同的变量写在一个always块中更有利于可读性的提高和功能的实现时候，可有例外情况，但请尽量多加注释，以增加可读性，并注意在组合always块中不要出现LATCH；</p><h3 id="always复位的书写"><a href="#always复位的书写" class="headerlink" title="always复位的书写"></a>always复位的书写</h3><p>异步复位和同步复位模块内要统一，异步复位的条件表达式及命名要和always敏感列表中的描述相统一，所有的复位有效电平必须统一。</p><h2 id="合理的注释"><a href="#合理的注释" class="headerlink" title="合理的注释"></a>合理的注释</h2><ul><li>代码中建议采用英文作详细的注释；</li><li>注释应该与代码一致，修改程序的时候一定要修改相应的注释；</li><li>注释不应重复代码已经表明的内容，而是简明地点明程序的突出特征；</li><li>注释应该提取程序的线索和关键词，它整合程序中分散的信息并它帮助理解程序中不能表明的部分。</li><li>注释中可以加入TODO、FIXME等标签来提示代码中的待办事项；</li></ul><h2 id="重用化设计"><a href="#重用化设计" class="headerlink" title="重用化设计"></a>重用化设计</h2><h3 id="层次结构与模块划分"><a href="#层次结构与模块划分" class="headerlink" title="层次结构与模块划分"></a>层次结构与模块划分</h3><ul><li>层次设计的原理以简单为主―尽量避免不必要的层次；层次结构设计得好，在综合中就不需要太多的优化过程；</li><li>模块的划分根据层次设计来决定―模块化对于布线有很大帮助，模块化的设计中要尽量减少全局信号的使用；</li><li>通用的部分尽量提取出来作为一个共用模块；</li></ul><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul><li>需要传递参数的模块，在多次例化的时候统一都传递参数，不要例化同一个模块，有的传参数，有的不传。</li></ul><h3 id="模块划分的技巧"><a href="#模块划分的技巧" class="headerlink" title="模块划分的技巧"></a>模块划分的技巧</h3><ul><li>将不同的时钟域分离开来；</li><li>按照不同的设计目标划分成块，分块时应在数据流方向上进行切分；</li><li>在同一模块中实现逻辑资源和算术资源的共享；</li></ul>]]></content>
    
    
    <summary type="html">简要介绍了RTL的编码风格及注意事项</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>FPGA输入输出信号的IOB约束方式</title>
    <link href="http://david-luge.cn/2022/10/09/FPGA/FPGA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7%E7%9A%84IOB%E7%BA%A6%E6%9D%9F%E6%96%B9%E5%BC%8F/"/>
    <id>http://david-luge.cn/2022/10/09/FPGA/FPGA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7%E7%9A%84IOB%E7%BA%A6%E6%9D%9F%E6%96%B9%E5%BC%8F/</id>
    <published>2022-10-09T08:54:39.000Z</published>
    <updated>2022-10-09T08:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者在做实验室FPGA项目时，遇到输入输出信号相关的约束问题。在请教老师后，总结以下内容，供以后遇到类似问题时翻阅。</p><p>对于FPGA的输入信号，我们要以异步信号来看待，输入信号进来先打拍，使用打拍后的数据。第一次打拍的FF要约束到IOB中的IFF中，第二个FF就可以放到Slice中，这样每次布局布线不会因为FF的位置不同导致时序出问题，且解决了输入信号的异步问题；</p><p>对于FPGA的输出信号，我们也要打拍输出，确保扇出为1，将其放到IOB中的OFF中。这样OFF到PAD的路径延迟固定，每次布局布线不会因为FF位置不同导致时序出问题。</p><p>对于inout信号，当该信号作为输入信号时，我们需要对其打两拍进行使用；当需要向总线上放数据时，需注意要用三态的方式放置数据<code>assign inout_data = sel ? dout : &#39;bz;</code>，且要保证sel信号是reg类型。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入信号没有使用IOB约束，在ISE的IOB Properties中未见输入信号部署到IFF中。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091732502.png" alt="img"></p><h2 id="尝试步骤"><a href="#尝试步骤" class="headerlink" title="尝试步骤"></a>尝试步骤</h2><p>在ISE工具的Implement的property选项中，对-pr选项要选择For Inputs and Outputs选项；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091735357.png" alt="img"></p><p>修复跟输入相关的模块，对输入信号要做打拍处理，使用打拍后的数据进行内部的逻辑运算；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091736236.png" alt="img"></p><h3 id="修改Implement的选项报错"><a href="#修改Implement的选项报错" class="headerlink" title="修改Implement的选项报错"></a>修改Implement的选项报错</h3><p>修复后在Map阶段报错，报错具体位置在8b10b解码IP：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091737591.png" alt="img"></p><p>打开8b10b的IP网表进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091737650.png" alt="img"></p><p>其中rx为输入的多光谱数据线，<strong>猜测为8b10b的IP网表中对ff_c0和ff_d1有布局上的约束，ff_c0和ff_d1需要pack在一起，而如果使用输入IOB的话，ff_c0需要布局在IOB中，而ff_d1无法布局在IOB中，导致报错。</strong></p><p>所以解决方案中不能使用Implement的property。</p><h3 id="Inout信号的处理方式"><a href="#Inout信号的处理方式" class="headerlink" title="Inout信号的处理方式"></a>Inout信号的处理方式</h3><p>要改变总线上的数据时，使用三态控制；</p><p><code>assign   cpu_data       = (rd_latchn == 1&#39;b0) ? cpu_rdata_mux : 16&#39;bz;</code></p><p>要使用总线上的数据时，直接打拍总线上的数据（cpu_data）使用；</p><p>增加上述约束后，查看ISE报告，cpu_data仍然是OFF，输入信号没有约束到IFF上。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091738262.png" alt="img"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="对于输入信号"><a href="#对于输入信号" class="headerlink" title="对于输入信号"></a>对于输入信号</h3><p>对于输入信号而言，进来先打两拍，第一拍的数据别用，用第二拍的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091738401.png" alt="img"></p><p>如果在ISE的Implement选项里可以选择<code>For Input and Outputs</code>的选项的话，那后续可以不用管了，注意该选项是针对全局的设计的。如果像上文这种有个lvds接口无法放置到IOB中的话，需要考虑以下的做法。</p><p>1、使用Verilog的attribute语法</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091739313.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091739332.png" alt="img"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* IOB = <span class="string">&quot;TRUE&quot;</span> *) <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] cpu_data_d1;</span><br></pre></td></tr></table></figure><p>2、在UCF文件里添加约束</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091741530.png" alt="img"></p><p>ISE工具默认会把接口上的数据放置到IOB内。如果默认的放置方式没有起作用的话，我们这里采用的是第二种做法。</p><h3 id="对于输出信号"><a href="#对于输出信号" class="headerlink" title="对于输出信号"></a>对于输出信号</h3><p><strong>保证扇出为1</strong>，在ISE的Implement选项中设置-pr选项，使用I&#x2F;O Register；或者使用verilog中attribute的方式或是UCF文件中添加约束的方式；</p><h3 id="对于inout信号"><a href="#对于inout信号" class="headerlink" title="对于inout信号"></a>对于inout信号</h3><p>把inout信号当输入使用时，注意打两拍再使用；</p><p>把inout信号当输出时，注意采用三态写法，且sel信号需要是reg类型；</p><p><code>assign   cpu_data       = (rd_latchn == 1&#39;b0) ? cpu_rdata_mux : 16&#39;bz;</code></p><p>对于inout信号，最好在UCF文件中显式的对io信号做IOB的约束；</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INST <span class="string">&quot;u_cpu_top/cpu_data_d1*&quot;</span> IOB=FORCE;</span><br></pre></td></tr></table></figure><p>ps：PR之后的信号名可以到ISE中的FPGA Editor去查询。 </p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091743114.png" alt="img"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>input、output、inout信号均正确约束到IOB中。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091743675.png" alt="img"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.xilinx.com/content/dam/xilinx/support/documents/sw_manuals/xilinx14_7/cgd.pdf">UG625</a></p>]]></content>
    
    
    <summary type="html">FPGA输入输出信号的IOB约束方式</summary>
    
    
    
    <category term="FPGA" scheme="http://david-luge.cn/categories/FPGA/"/>
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/categories/FPGA/FPGA-Tools/"/>
    
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/tags/FPGA-Tools/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要门级仿真</title>
    <link href="http://david-luge.cn/2022/10/07/IC/Basic/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%97%A8%E7%BA%A7%E4%BB%BF%E7%9C%9F/"/>
    <id>http://david-luge.cn/2022/10/07/IC/Basic/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%97%A8%E7%BA%A7%E4%BB%BF%E7%9C%9F/</id>
    <published>2022-10-07T07:14:39.000Z</published>
    <updated>2022-10-07T07:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当时面试百度昆仑芯的时候，面试官问我这样一个场景。各Corner下的Timing已经Clean了，Formality已经保证RTL和门电路保持一致了，为什么要需要去做GLS（Gate Level Simulation）呢？</p><p>当时问的一下愣住，没想明白，下来搜集资料发现以下几点原因。其中部分原因自己也还不能理解到位，期待后续实际工作中加深理解。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071537119.jpg" alt="GLS"></p><ol><li>解决STA工具的局限性，如STA工具无法分析异步接口信号，STA工具也会放宽对False Path和Multi-cycle Path的检查，用GLS来复查一下；</li><li>核实一下系统初始化是否正常进行，复位链是否正确；</li><li>验证所有电源域的上电和复位操作是否符合要求，并且检查设计不依赖于设计的初始条件；</li><li>利用最坏和最佳的时序信息的组合来揭示边缘敏感信号上的Glitch情况；</li><li>执行DFT验证，因为扫描链是在RTL综合后插入的；</li><li>验证时钟树综合（CTS）是否满足要求；（Skew、Jitter等）</li><li>获取翻转率参数来更准确地估计功耗；</li><li>在RTL或者GLS中以悲观&#x2F;乐观来分析X态；（不太理解）</li><li>检查最终的性能以确保设计工作在所需的频率，路径上实际的延迟需考虑在内，包括部分结构元素不被STA或者Formality检查，或者在PR阶段在路径上插入的Buffer或者其他的电路元素。</li></ol>]]></content>
    
    
    <summary type="html">门级仿真的必要性</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>Blog图像加载失败解决方法</title>
    <link href="http://david-luge.cn/2022/10/07/Misc/Blog%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://david-luge.cn/2022/10/07/Misc/Blog%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-10-07T04:50:00.000Z</published>
    <updated>2022-10-07T04:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果你没有用科学上网方式的话，可能本博客中部分内容的图像是看不了的，因为后期我文章中的图像托管到了Github仓库里。此时需要根据系统配置一下DNS来进行图像的查看，找了部分资料链接放在下面，个人比较推荐修改DNS的方式，快捷简单。以后访问Github时也比较方便。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/368689473">Github访问速度慢,图片无法加载的解决方法</a></p><p><a href="https://zhuanlan.zhihu.com/p/107334179">修改Hosts解决Github访问失败</a></p>]]></content>
    
    
    <summary type="html">Blog图像加载失败解决方法</summary>
    
    
    
    <category term="Misc" scheme="http://david-luge.cn/categories/Misc/"/>
    
    <category term="Git" scheme="http://david-luge.cn/categories/Misc/Git/"/>
    
    
    <category term="Git" scheme="http://david-luge.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>摄影入门知识</title>
    <link href="http://david-luge.cn/2022/10/07/Misc/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://david-luge.cn/2022/10/07/Misc/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</id>
    <published>2022-10-07T02:50:00.000Z</published>
    <updated>2022-10-07T02:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摄影入门知识"><a href="#摄影入门知识" class="headerlink" title="摄影入门知识"></a>摄影入门知识</h1><h2 id="曝光三要素"><a href="#曝光三要素" class="headerlink" title="曝光三要素"></a>曝光三要素</h2><h3 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h3><p>光圈大小、快门速度、ISO大小</p><ul><li>光圈大小：同时能进多少光</li><li>快门速度：遮光板<strong>打开和关闭</strong>一次的时长，速度越慢遮光板打开时间越久，进光越多</li><li>ISO：理解为额外增加的小手电，强行添加额外亮度（电子信号），会增加颗粒感</li></ul><h3 id="参数对应的数值说明"><a href="#参数对应的数值说明" class="headerlink" title="参数对应的数值说明"></a>参数对应的数值说明</h3><ul><li>光圈数值，与大小相反，F1.8为大光圈，F22为小光圈，以此类推…</li><li>快门速度，单位为秒（16，1&#x2F;2，1&#x2F;8000 秒等），数值越小，遮光板打开时间越短，进光越少；</li><li>iso 数值  （100，800，1600等），数值越大，额外强行补光越多，颗粒感越重</li></ul><h3 id="亮暗环境下的调整步骤"><a href="#亮暗环境下的调整步骤" class="headerlink" title="亮暗环境下的调整步骤"></a>亮暗环境下的调整步骤</h3><ul><li>暗环境下：1、首先调大光圈；2、其次减慢快门；3、最后还不行再调大iso；优先级逐渐降低；</li><li>亮环境下：1、调低ISO；2、加快快门；3、最后还不行再调小光圈；</li></ul><h2 id="光圈和快门对照片的其他影响"><a href="#光圈和快门对照片的其他影响" class="headerlink" title="光圈和快门对照片的其他影响"></a>光圈和快门对照片的其他影响</h2><h3 id="光圈大小影响亮度、景深、虚化"><a href="#光圈大小影响亮度、景深、虚化" class="headerlink" title="光圈大小影响亮度、景深、虚化"></a>光圈大小影响亮度、景深、虚化</h3><ul><li>景深：从镜头发散出去，只有一部分区域的景象是清晰的，其他的会模糊。<strong>清晰的区域，就叫做景深。</strong>大光圈，浅景深，清晰的区域小，背景会模糊；小光圈，深景深，清晰的区域大，背景也清晰；</li><li>虚化：光圈越大，背景虚化越强（与景深联系起来，大光圈，浅景深，背景模糊→背景虚化）；光圈越小，背景虚化越弱；<ul><li>虚化强弱的理解：一盏小灯在大光圈下，灯会虚化成大光斑；小光圈，灯虚化成的光斑也小；（光斑的形状来源于光圈扇叶形成的圆洞，<strong>假如用卡纸剪出心形置于镜头前，光斑也成心形</strong>）；</li><li>虚化的不止背景，还有前景；可应用前景虚化，拍摄梦幻感的照片。</li><li>景深与对焦的理解：对焦，就是让清晰的区域（景深）与拍摄主体有重合。因此，<strong>小光圈易于对焦运动中的主体</strong>。</li></ul></li></ul><h3 id="快门速度影响亮度，动态模糊"><a href="#快门速度影响亮度，动态模糊" class="headerlink" title="快门速度影响亮度，动态模糊"></a>快门速度影响亮度，动态模糊</h3><ul><li>慢快门时，假如相机抖动，将导致光在CMOS上有运动轨迹，进而导致照片糊掉；</li><li>自动挡时，使用大光圈，增大ISO，或者用闪光灯或补光灯照亮主体，可以尽可能避免相机使用慢快门，进而避免拍摄时，相机抖动导致照片糊掉；</li><li>慢速快门拍摄技巧，可用于拍摄光绘，星轨，车流，火花；可使用三脚架保持相机稳定，防止糊掉</li></ul><h3 id="在强光下如何虚化-动态模糊？"><a href="#在强光下如何虚化-动态模糊？" class="headerlink" title="在强光下如何虚化+动态模糊？"></a>在强光下如何虚化+动态模糊？</h3><p>虚化就需要光圈调大-&gt;浅景深-&gt;背景模糊，动态模糊需要慢快门-&gt;让光在CMOS上运动，那么就会导致进光量太多的问题，本质上是矛盾的。</p><p>这时我们引入ND滤镜（控光工具），可理解为相机用墨镜🕶可以降低画面亮度，有可变和固定参数两种。</p><h2 id="相机档位"><a href="#相机档位" class="headerlink" title="相机档位"></a>相机档位</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>相机档位本质上是用来控制光圈、ISO和快门速度的，只不过不同的档位下你能把握的变量不同；</p><ul><li>M：自由控制所有参数；</li><li>A&#x2F;AV：只能控制光圈参数，其它参数相机自适应（用途：（画面有大光圈虚化）人、微距、特写。条件：光线、亮度足够好。）</li><li>S&#x2F;TV：只能控制快门速度，其他参数相机自适应。（用途：1、慢速快门；2、快速抓拍：打鸟、小孩、速度快的物体&#x2F;事件；）</li><li>P：定向自适应模式，相机通过你的修改参数来自动调整其它参数。例如：光圈（你），ISO，快门速度（相机）；相机会通过你的自变量（x&#x3D;光圈&#x2F;快门速度），来调整另一个参数（快门速度&#x2F;光圈），前提：ISO为auto 。</li></ul><h3 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h3><p>程序算法，根据你的选择，调整三要素数值，改变画面亮度；</p><p>在不同的档位模式下，曝光补偿能改变的参数不同；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210031850425.png" alt="曝光补偿说明"></p><h3 id="图像直方图"><a href="#图像直方图" class="headerlink" title="图像直方图"></a>图像直方图</h3><table><thead><tr><th align="center">画面</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">暗</td><td align="center">偏左</td></tr><tr><td align="center">亮</td><td align="center">偏右</td></tr><tr><td align="center">正常曝光</td><td align="center">均匀平铺</td></tr><tr><td align="center">没有过渡部分</td><td align="center">分散两边</td></tr></tbody></table><p>如果场景敏感比例不平衡的话，直方图不能直观的显示，就要做取舍，注意拍摄主题的质量；</p><h2 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h2><p>当我们拍摄低色温环境如3500k（偏蓝），白平衡k值设置要高如7000k（偏黄），两者综合才能还原物体原来颜色，这就是白平衡的用处。</p><p>简单来说就是：白平衡设置低k值，相机会认为外部环境偏黄，所以加蓝；设置高k值，相机会认为外部环境偏蓝，所以加红。傍晚拍摄照片时用3500k，没什么问题，如果想要拍摄绚丽黄昏，高k值也是不错的选择，这取决于最终想怎么表现一张图想表达的情绪。</p><h2 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h2><p>主要调整对象：光圈快门ISO、曝光补偿、测光模式</p><p>亮度太高&#x2F;亮度不足：看直方图判断、曝光补偿小管家（在M档位下）（看+&#x2F;-数值）；</p><p>测光模式：评价&#x2F;多重测光（拍人像）、中央测光（对象在画面中央，跟拍vlog）、点测光（对象一直在画面某个位置，如会议记录）；</p><p>固定测光的亮度：亮度锁（*）、Sony（ael）；</p><h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2><ul><li><p>景深通俗的来说就是画面中前后清晰的范围，但对焦并不等于移动景深，而是移动焦点。</p></li><li><p>同时景深也并不只是一个简单的范围，而是由三个部分组成：大概示意图：</p><p>🎥  &lt;         (   前景深｜焦点|       后景深 )</p></li><li><p>为什么要把景深分为三个部分？</p><p>景深范围内并不是所有东西都同样清晰！</p><p>从物理理论上来说，只有焦点上的物体才是“绝对”清晰的 而前景深与后景深只是“相对清晰”（轻微模糊，但人眼分辨不出） 这似乎都是清晰 但假如在一些需要放大几倍的特殊情况下 这个问题就会显现：比如在拍摄人像的时候，对焦到鼻尖 。好像眼睛和鼻尖都在景深内，但放大后眼睛是可能会感觉到轻微模糊的。</p><p>所以盲目把对焦理解为“只要落在这个范围里”是非常危险的！！！正确方法应该是将最主要的物体（例如人像的眼睛）放在焦点上，而至于其他区域（例如耳朵、鼻子等）如果想要清晰的话，再通过调整光圈或焦距的方法改变景深大小来实现清晰！</p></li><li><p>拍照时先定焦点，再去构图；</p></li></ul>]]></content>
    
    
    <summary type="html">摄影入门知识小结</summary>
    
    
    
    <category term="Misc" scheme="http://david-luge.cn/categories/Misc/"/>
    
    <category term="photography" scheme="http://david-luge.cn/categories/Misc/photography/"/>
    
    
    <category term="photography" scheme="http://david-luge.cn/tags/photography/"/>
    
  </entry>
  
  <entry>
    <title>我的秋招小结</title>
    <link href="http://david-luge.cn/2022/09/30/Interview/%E7%A7%8B%E6%8B%9B%E5%B0%8F%E7%BB%93/"/>
    <id>http://david-luge.cn/2022/09/30/Interview/%E7%A7%8B%E6%8B%9B%E5%B0%8F%E7%BB%93/</id>
    <published>2022-09-30T02:54:39.000Z</published>
    <updated>2022-09-30T02:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>2022年，不知道是不是未来十年最好的一年，不过应该是过去十年最差的一年。听完任总的“寒气论”和字节梁总的“去肥增瘦”理论后，每个2023的应届生应该都能感受到这刺骨的寒意。</p><p>我的秋招经历开始较早，6月陆续开始投递各公司的提前批，7-8月份为面试高峰期，9月陆续收到各家的offer。文章的后面我会大概回忆各面试的问题，梳理校招时面试官关心的共性问题，仅供大家参考，准备后续的秋招笔试面试。</p><p>本文整理的一些知识点后续会慢慢在自己的博客更新（给自己挖了一波大坑），希望后面慢慢填上；</p><h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><ul><li>准备项目的简要系统架构介绍。可以包括以下要素：项目框图、各模块功能介绍、系统接口、时钟复位网络；可以用Xmind或者MarkDown工具去梳理项目架构。</li><li>提取项目的亮点、难点。部分面试时间不够的话面试官不会给充足的时间详尽介绍项目，可以从时序约束、算法设计、优化方式、计算性能等方向去整理；</li><li>项目中涉及到的点要拓展延伸，了解相关的基础知识。举例说明，我的项目接口信号使用了8b10b编码方式，自己可以考虑如下几点：1、8b10b编码是什么？2、为什么需要8b10b编码，该编码是用来解决什么问题的？3、有其他方式可以解决该问题吗？要带入面试官的角度去思考自己的项目；</li><li>总结在做项目过程中遇到的棘手问题，在给面试官叙述自己解决问题的思路和方式的过程中展现自己的能力。</li><li>项目的验证方式；了解项目涉及的IC&#x2F;FPGA的工艺，面积；</li><li>统计项目中自己负责部分的代码量；</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="跨时钟域"><a href="#跨时钟域" class="headerlink" title="跨时钟域"></a>跨时钟域</h2><ul><li>基本的CMOS、PMOS结构；</li><li>跨时钟域的原因，亚稳态的定义；</li><li>建立时间、保持时间；</li><li>单bit信号跨时钟域，考虑快慢时钟域；</li><li>多bit信号跨时钟域；<ul><li>异步FIFO的假空假满；</li><li>格雷码跨时钟域问题；</li><li>如何考虑FIFO深度；</li><li>FIFO和DMUX的相关时序约束；</li></ul></li><li>何时需要跨时钟，跨时钟方式如何选择；</li><li>关于复位信号的跨时钟域；</li><li>Time Borrow&#x2F;Steal（进阶）</li></ul><h2 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h2><ul><li>功耗的分类、影响因素、计算公式</li><li>静态低功耗技术，降静态功耗的方法；</li><li>动态低功耗技术，降动态功耗的方法；</li><li>RTL设计中降功耗的方式；</li><li>以反相器为例解释静态功耗和动态功耗；</li></ul><h2 id="时序约束"><a href="#时序约束" class="headerlink" title="时序约束"></a>时序约束</h2><ul><li>时钟相关<ul><li>周期、占空比、管脚；</li><li>Primary Clock、Virtual Clock、Generated Clock、Clock Groups；</li><li>Clock Latency、Jitter、Uncertainty；</li></ul></li><li>IO Delay<ul><li>Input Delay；</li><li>Output Delay；</li></ul></li><li>Time Exceptions<ul><li>Multicycle；</li><li>False Path；</li><li>Max&#x2F;Min Delay；</li></ul></li></ul><h2 id="IC相关"><a href="#IC相关" class="headerlink" title="IC相关"></a>IC相关</h2><ul><li>简述IC设计流程，了解各步骤的目的；</li><li>IC和FPGA的区别；</li><li>修Time Violation的方式；</li></ul><h2 id="AMBA协议"><a href="#AMBA协议" class="headerlink" title="AMBA协议"></a>AMBA协议</h2><ul><li><p>读写架构，信号列表及含义；</p></li><li><p>跨4K问题；</p></li><li><p>握手间的依赖关系；</p></li><li><p>能否提前结束突发传输；</p></li><li><p>窄位宽数据传输、非对齐传输、混合大小端传输；</p></li><li><p>Outstanding的含义，如何考虑Outstanding深度；</p></li><li><p>Out of Order的含义，跟ID信号是否有联系；</p></li><li><p>Interconnect的结构；</p></li><li><p>AXI3、AXI4的区别；</p></li><li><p>AXI Full、AXI Lite的区别；</p></li><li><p>AXI的死锁场景；</p></li></ul><h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><ul><li>状态机相关：红绿灯、自动售货机、序列检测；</li><li>分频相关：奇偶分频、半整数分频、小数分频；</li><li>仲裁相关：优先级仲裁、固定优先级仲裁、变优先级仲裁、轮询仲裁、加权轮询；</li><li>存储：单口RAM、简单双口RAM、真双口RAM；</li><li>CDC<ul><li>同步FIFO：基于单口RAM、基于双口RAM；</li><li>异步FIFO：Bin2Gray、Gray2Bin；</li><li>脉冲同步器、带反馈的脉冲同步器；</li><li>前向&#x2F;后向Pipe；</li></ul></li><li>门级电路：计数器、全加器、二&#x2F;三分频、占空比1:3的二分频；</li><li>其它：Generate、For语法相关；</li></ul>]]></content>
    
    
    <summary type="html">关于我的秋招小节</summary>
    
    
    
    <category term="interview" scheme="http://david-luge.cn/categories/interview/"/>
    
    
    <category term="interview" scheme="http://david-luge.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>跨复位域小结</title>
    <link href="http://david-luge.cn/2022/09/29/Interview/%E8%B7%A8%E5%A4%8D%E4%BD%8D%E5%9F%9F%E5%B0%8F%E7%BB%93/"/>
    <id>http://david-luge.cn/2022/09/29/Interview/%E8%B7%A8%E5%A4%8D%E4%BD%8D%E5%9F%9F%E5%B0%8F%E7%BB%93/</id>
    <published>2022-09-29T07:00:39.000Z</published>
    <updated>2022-09-29T07:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨复位域小结"><a href="#跨复位域小结" class="headerlink" title="跨复位域小结"></a>跨复位域小结</h1><p>跨时钟域我们比较熟悉，但跨复位域可能就比较陌生了。在平头哥实习的一面中，面试官问了我较多跨复位域的问题，主要还是自己在简历里挖了个坑（就不该写设计复位网络的TAT），所以这篇文章就来简要介绍一下跨复位域中存在的一些问题及解决方法。</p><h2 id="异步复位导致的亚稳态"><a href="#异步复位导致的亚稳态" class="headerlink" title="异步复位导致的亚稳态"></a>异步复位导致的亚稳态</h2><h3 id="异步复位的释放"><a href="#异步复位的释放" class="headerlink" title="异步复位的释放"></a>异步复位的释放</h3><p>复位如果在时钟采样沿的前后的一个时间窗口内释放的话会导致输出的Q端存在亚稳态问题，<strong>本质上也是触发器建立时间和保持时间的要求</strong>，对复位而言就是Recovery Time和Removal Time的要求。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121969.png" alt="1"></p><p>为解决异步复位释放的亚稳态问题，我们可以使用异步复位，同步释放的方式来解决。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121355.png" alt="2"></p><h3 id="异步复位的置位"><a href="#异步复位的置位" class="headerlink" title="异步复位的置位"></a>异步复位的置位</h3><p>复位的置位也可能导致亚稳态问题，主要场景是电路中有多复位域，我们分析一下下图所示场景。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121206.png" alt="3"></p><p>dff1和dff2分别使用不同的时钟和复位信号，dff1先复位，之后dff2再复位。可能存在的问题是arst1置位时，<strong>dff1的Q端数据从data向Reset-value跳变时可能不满足dff2的建立&#x2F;保持时间要求</strong>，从而使dff2的Q端出现亚稳态。</p><p>以下关于时钟复位的5种情形<strong>都可能导致亚稳态</strong>：</p><p>1、clk1和clk2是一样的&#x2F;同步的；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121776.png" alt="4"></p><p>2、clk1和clk2是异步的；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122669.png" alt="5"></p><p>3&#x2F;4、对arst1和arst2均做异步复位，同步释放操作；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122118.png" alt="6"></p><p>5、rst2做同步复位；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122155.png" alt="7"></p><h2 id="如何安全地处理跨复位域"><a href="#如何安全地处理跨复位域" class="headerlink" title="如何安全地处理跨复位域"></a>如何安全地处理跨复位域</h2><h3 id="1、对复位的顺序提出要求"><a href="#1、对复位的顺序提出要求" class="headerlink" title="1、对复位的顺序提出要求"></a>1、对复位的顺序提出要求</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122904.png" alt="8"></p><p>arst2在arst1之前置位的话，就不存在dff2的亚稳态问题，<strong>这种先复位后级模块的策略可以有效避免亚稳态。</strong></p><h3 id="2、增加数据隔离单元"><a href="#2、增加数据隔离单元" class="headerlink" title="2、增加数据隔离单元"></a>2、增加数据隔离单元</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122542.png" alt="9"></p><p>在dff1的arst1置位前隔离dff1的输出，将输出钳位到0，避免arst1置位时导致dff2出现亚稳态；</p><h3 id="3、通过时钟门控进行数据隔离"><a href="#3、通过时钟门控进行数据隔离" class="headerlink" title="3、通过时钟门控进行数据隔离"></a>3、通过时钟门控进行数据隔离</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122095.png" alt="10"></p><p>与数据隔离单元的思想类似，只不过通过门控dff2的方式来完成数据隔离。（<strong>门控时钟也可以有效解决异步复位的recovery和removal time的问题，异步复位后再开时钟就不用考虑上述time的检查。</strong>）</p><h3 id="4、通过打拍降低亚稳态概率"><a href="#4、通过打拍降低亚稳态概率" class="headerlink" title="4、通过打拍降低亚稳态概率"></a>4、通过打拍降低亚稳态概率</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122793.png" alt="11"></p><p>通过增加一个dff3来减少亚稳态发生的概率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>安全处理跨复位域的做法：</p><ul><li><strong>依序</strong>对模块进行复位，<strong>后级模块先复位</strong>；</li><li>通过<strong>数据隔离单元或门控时钟</strong>进行数据隔离，避免出现亚稳态；</li><li>后级模块通过<strong>两级同步寄存器</strong>降低亚稳态发生的概率；</li></ul><p>平头哥一面中，面试官提问我，ASIC中复位网络的扇出很大，很难保证所有寄存器都满足recovery和removal time的要求，异步复位&#x2F;同步释放的方式也解决不了该问题，因为有Skew存在，问此时<strong>如何保证正常的异步复位功能，且不用考虑recovery和removal time？</strong></p><p>当时面试过程中没答出来，于是问了面试官，面试官说<strong>异步复位前先把clock关了，复位后再开clock</strong>，这样就可以避免考虑recovery和removal time，这个答案震惊到我了，作下记录，感谢平头哥的面试官！</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.youtube.com/watch?v=G_37fwOVnik">Reset Domain Crossing</a></p>]]></content>
    
    
    <summary type="html">关于我实习被平头哥面试官问复位问到怕这件事</summary>
    
    
    
    <category term="interview" scheme="http://david-luge.cn/categories/interview/"/>
    
    
    <category term="interview" scheme="http://david-luge.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Questasim安装与破解教程</title>
    <link href="http://david-luge.cn/2022/09/29/FPGA/Questasim%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://david-luge.cn/2022/09/29/FPGA/Questasim%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2022-09-29T06:54:39.000Z</published>
    <updated>2022-09-29T06:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Questasim安装与破解教程"><a href="#Questasim安装与破解教程" class="headerlink" title="Questasim安装与破解教程"></a>Questasim安装与破解教程</h1><h2 id="安装前提："><a href="#安装前提：" class="headerlink" title="安装前提："></a>安装前提：</h2><p>系统要求：Win10 64位</p><p>注意：安装路径及以后的项目路径、文件路径等都不要有中文和空格。</p><h2 id="安装破解步骤："><a href="#安装破解步骤：" class="headerlink" title="安装破解步骤："></a>安装破解步骤：</h2><ol><li><p>关闭电脑的杀毒软件和防火墙，双击安装包中的<code>questasim-win64-10.6c.exe</code>进行安装，推荐安装目录：<code>D:/questasim64_10.6c</code>。安装完成后不要打开软件先进行破解。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055355.png" alt="1"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055257.png" alt="2"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055020.png" alt="3"></p></li><li><p>复制和此文档同一压缩包内的’patch_dll.bat’ 和’MentorKG.exe’和’license.dat’和’MakeLic.bat’（所有文件）到 <path_to_questasim_win64>文件夹(即安装目录里的win64文件夹，（举例：本人安装在<code>D:\Program Files\Questasim</code>，所以复制到文件夹<code>D:\Program Files\Questasim\win64</code>）</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055285.png" alt="4"></p></li><li><p>找到安装路径下<code>win64/mgls64.dll</code> 去掉其只读属性</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055378.png" alt="5"></p></li><li><p>双击运行安装路径下<code>win64/patch_dll.bat</code>（这个文件是刚刚由压缩包中复制过来的），等待一段时间会产生LICENSE.TXT，保存到安装目录里的win64文件夹（本人是<code>D:\Program Files\Questasim\win64</code>）</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055937.png" alt="6"></p></li><li><p>接下来是修改用户变量和系统变量，不同系统可能步骤不一样，但修改的内容都一样</p><p><strong>用户变量</strong></p></li></ol><table><thead><tr><th align="center">变量名</th><th align="center">变量值</th></tr></thead><tbody><tr><td align="center">LM_LICENSE_FILE</td><td align="center">D:\Program Files\Questasim\win64\license.dat</td></tr><tr><td align="center">MGLS_LICENSE_FILE</td><td align="center">D:\Program Files\Questasim\win64\LICENSE.TXT</td></tr></tbody></table><p>​<strong>Path中新建两项</strong></p><p><code>D:\Program Files\Questasim\win64</code></p><p><code>D:\Program Files\Questasim\win64\LICENSE.TXT</code></p><p>​<strong>系统变量</strong></p><table><thead><tr><th align="center">变量名</th><th align="center">变量值</th></tr></thead><tbody><tr><td align="center">MGLS_LICENSE_FILE</td><td align="center">D:\Program Files\Questasim\win64\LICENSE.TXT</td></tr><tr><td align="center">lm_license_file</td><td align="center">D:\Program Files\Questasim\win64\LICENSE.TXT</td></tr></tbody></table><p>步骤图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056666.png" alt="7"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056831.png" alt="8"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056685.png" alt="9"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056957.png" alt="10"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056079.png" alt="11"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056514.png" alt="12"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056480.png" alt="13"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056522.png" alt="14"></p><ol start="6"><li>完成后打开软件，如果完成正确的配置后依旧无法打开可以重启计算机后打开。</li></ol>]]></content>
    
    
    <summary type="html">Questasim安装与破解教程</summary>
    
    
    
    <category term="FPGA" scheme="http://david-luge.cn/categories/FPGA/"/>
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/categories/FPGA/FPGA-Tools/"/>
    
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/tags/FPGA-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Vivado与Modelsim联合仿真</title>
    <link href="http://david-luge.cn/2022/09/29/FPGA/Vivado%E4%B8%8EModelsim%E8%81%94%E5%90%88%E4%BB%BF%E7%9C%9F/"/>
    <id>http://david-luge.cn/2022/09/29/FPGA/Vivado%E4%B8%8EModelsim%E8%81%94%E5%90%88%E4%BB%BF%E7%9C%9F/</id>
    <published>2022-09-29T05:54:39.000Z</published>
    <updated>2022-09-29T05:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vivado与Modelsim联合仿真"><a href="#Vivado与Modelsim联合仿真" class="headerlink" title="Vivado与Modelsim联合仿真"></a>Vivado与Modelsim联合仿真</h1><p>笔者在学习FPGA过程中遇到了如何使用Vivado和Modelsim进行联合仿真的问题，特此记录。</p><h2 id="确定版本"><a href="#确定版本" class="headerlink" title="确定版本"></a>确定版本</h2><p>笔者Vivado用的是2018.3版本，先是随便下了个Modelsim10.1c的版本，到编译库文件时报错了，后来发现是俩款软件的版本不匹配。所以大家在进行联合仿真之前先核对两个软件的版本是否对应，不用到最后再卸载重装。</p><p><strong>Vivado Design Suite 2018.3</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.6c)<br>Mentor Graphics Questa Advanced Simulator (10.6c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.053)<br>Cadence Xcelium Parallel Simulator (18.03.005)<br>Synopsys VCS and VCS MX (N-2017.12-SP2)<br>Aldec Active-HDL (10.5) Aldec Riviera-PRO (2018.02)</p><p><strong>Vivado Design Suite 2018.2</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.6c)<br>Mentor Graphics Questa Advanced Simulator (10.6c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.042)<br>Cadence Xcelium Parallel Simulator (17.10.005)<br>Synopsys VCS and VCS MX (N-2017.12)<br>Aldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.10)</p><p><strong>Vivado Design Suite 2018.1</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.6c)<br>Mentor Graphics Questa Advanced Simulator (10.6c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.042)<br>Cadence Xcelium Parallel Simulator (17.10.005)<br>Synopsys VCS and VCS MX (N-2017.12)<br>Aldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.10)</p><p><strong>Vivado Design Suite 2017.4</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.6b)<br>Mentor Graphics Questa Advanced Simulator (10.6b)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.028)<br>Synopsys VCS and VCS MX (M-2017.03-SP1)<br>Aldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.02)</p><p><strong>Vivado Design Suite 2017.3</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.6b)<br>Mentor Graphics Questa Advanced Simulator (10.6b)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.028)<br>Synopsys VCS and VCS MX (M-2017.03-SP1)<br>Aldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.02)</p><p><strong>Vivado Design Suite 2017.2</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.5c)<br>Mentor Graphics Questa Advanced Simulator (10.5c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.014)<br>Synopsys VCS and VCS MX (L-2016.06-SP1)<br>Aldec Active-HDL (10.4) Aldec Riviera-PRO (2016.10)</p><p><strong>Vivado Design Suite 2017.1</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.5c)<br>Mentor Graphics Questa Advanced Simulator (10.5c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.014)<br>Synopsys VCS and VCS MX (L-2016.06-SP1)<br>Aldec Active-HDL (10.4) Aldec Riviera-PRO (2016.10)</p><p><strong>Vivado Design Suite 2016.4</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.5c)<br>Mentor Graphics Questa Advanced Simulator (10.5c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.005)<br>Synopsys VCS and VCS MX (L-2016.06)<br>Aldec Active-HDL (10.3) Aldec Riviera-PRO (2016.06)</p><p><strong>Vivado Design Suite 2016.3</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.5c)<br>Mentor Graphics Questa Advanced Simulator (10.5c)<br>Cadence Incisive Enterprise Simulator (IES) (15.20.005)<br>Synopsys VCS and VCS MX (L-2016.06)<br>Aldec Active-HDL (10.3) Aldec Riviera-PRO (2016.06)</p><p>Vivado Design Suite 2016.2, 2016.1</p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.4d)<br>Mentor Graphics Questa Advanced Simulator (10.4d)<br>Cadence Incisive Enterprise Simulator (IES) (15.10.013)<br>Synopsys VCS and VCS MX (K-2015.09)<br>Aldec Active-HDL (10.3) Aldec Riviera-PRO (2015.10)</p><p><strong>Vivado Design Suite 2015.4, 2015.3</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.4b)<br>Mentor Graphics Questa Advanced Simulator (10.4b)<br>Cadence Incisive Enterprise Simulator (IES) (14.20.006)<br>Synopsys VCS and VCS MX (J-2014.12-SP2)<br>Aldec Active-HDL (10.2 SP2) Aldec Riviera-PRO (2015.06)</p><p><strong>Vivado Design Suite 2015.2, 2015.1</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.3d)<br>Mentor Graphics Questa Advanced Simulator (10.3d)<br>Cadence Incisive Enterprise Simulator (IES) (14.10.011)<br>Synopsys VCS and VCS MX (I-2014.03-SP1)<br>Aldec Active-HDL (10.1 SP1) Aldec Riviera-PRO (2015.02)</p><p><strong>Vivado Design Suite 2014.4</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.3b)<br>Mentor Graphics Questa Advanced Simulator (10.3b)<br>Cadence Incisive Enterprise Simulator (IES) (13.20.005)<br>Synopsys VCS and VCS MX (I-2014.03)<br>Aldec Active-HDL (9.3 SP1) Aldec Riviera-PRO (2014.02)</p><p><strong>Vivado Design Suite 2014.3</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.3b)<br>Mentor Graphics Questa Advanced Simulator (10.3b)<br>Cadence Incisive Enterprise Simulator (IES) (13.20.005)<br>Synopsys VCS and VCS MX (I-2014.03)<br>Aldec Active-HDL (9.2 SP1) Aldec Riviera-PRO (2014.02)</p><p><strong>Vivado Design Suite 2014.2, 2014.1</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.2a)<br>Mentor Graphics Questa Advanced Simulator (10.2a)<br>Cadence Incisive Enterprise Simulator (IES) (12.2-016)<br>Synopsys VCS and VCS MX (H-2013.06-SP1)<br>Aldec Active-HDL (9.3 SP1) Aldec Riviera-PRO (2014.02)</p><p><strong>Vivado Design Suite 2013.4</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.2a)<br>Mentor Graphics Questa Advanced Simulator (10.2a)<br>Cadence Incisive Enterprise Simulator (IES) (12.2-016)<br>Synopsys VCS and VCS MX (H-2013.06)<br>Aldec Active-HDL (9.2 SP1) Aldec Riviera-PRO (2013.06)</p><p><strong>Vivado Design Suite 2013.3</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.2a)<br>Mentor Graphics Questa Advanced Simulator (10.2a)<br>Cadence Incisive Enterprise Simulator (IES) (12.2-016)<br>Synopsys VCS and VCS MX (H-2013.06-3)<br>Aldec Active-HDL (9.2) Aldec Riviera-PRO (2013.02)</p><p><strong>Vivado Design Suite 2013.1, 2013.2</strong></p><p>Mentor Graphics ModelSim SE&#x2F;DE&#x2F;PE (10.1b)<br>Mentor Graphics Questa Advanced Simulator (10.1b)<br>Cadence Incisive Enterprise Simulator (IES) (12.2)<br>Synopsys VCS and VCS MX (G-2012.09)<br>Aldec Active-HDL (9.2) Aldec Riviera-PRO (2012.10)</p><p><a href="https://www.xilinx.com/support/answers/68324.html">reference</a></p><p>笔者用的是Vivado2018.3，查询的对应的Modelsim版本为10.6c。</p><hr><h2 id="Modelsim破解"><a href="#Modelsim破解" class="headerlink" title="Modelsim破解"></a>Modelsim破解</h2><p>准备Modelsim10.6c的安装包</p><p><a href="https://download.csdn.net/download/qq_42334072/13087931">下载链接</a></p><p>步骤如下：</p><p>(1)、安装软件，<strong>注意安装路径中不要出现中文或空格</strong>，安装过程中一直点击YES即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102490.png" alt="1"></p><p>(2)、把<code>crack.bat</code>、<code>MentorKG.exe</code>一起拷贝到modelsim安装目录的win64文件夹下，例如<code>D:\modelsim_dlx64_10.6c\win64pe</code></p><p>(3)、双击<code>crack.bat</code>，若出现下图所示问题，则将<code>mgls64.dll</code>重命名为<code>mgls.dll</code>再次重新运行<code>crack.bat</code>即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102020.png" alt="2"></p><p>(4)、将生成的<code>LICENSE.TXT</code>放在modelsim的安装路径下，如<code>D:\modelsim_dlx64_10.6c</code>，若前面修改了mgls64.dll文件的名称，则生成完LICENSE文件后应当把名字改回去。</p><p>(5)、新建环境变量<code>MGLS_LICENSE_FILE</code>，变量值为LICENSE放置的路径，如<code>D:\modelsim_dlx64_10.6c\LICENSE.TXT</code>。在win10中，右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，进行环境变量的添加。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102492.png" alt="3"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102352.png" alt="4"></p><p>(6)、打开Modelsim软件，安装破解结束。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102973.png" alt="5"></p><hr><h2 id="联合仿真"><a href="#联合仿真" class="headerlink" title="联合仿真"></a>联合仿真</h2><p>(1)、打开任意一个vivado工程，再按下图所示点击编译Xilinx的仿真库。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103139.png" alt="6"></p><p>注意：Simulator选Modelsim Simulator，编译库Compiled library location放入新建的文件夹<code>D:\Xilinx\Xlib</code>中(可自己指定)，Simulator executable path选择modelsim安装路径下的win64pe。注意Compile Xilinx IP选项不勾选。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103436.png" alt="7"></p><p>编译结果从Vivado中的Tcl Console中可知，无Errors，芜湖起飞！</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103881.png" alt="8"></p><p>(2)查看编译库Compiled library location路径下，应该出现<code>modelsim.ini</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103243.png" alt="9"></p><p>我们将其设置为用户的全局变量，这样下次就不需要再编译库文件了，步骤如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103520.png" alt="10"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103420.png" alt="11"></p><p>(3)、设置第三方仿真软件的安装路径与编译库的路径，具体步骤如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103143.png" alt="12"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104566.png" alt="13"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104304.png" alt="14"></p><p>(4)、全部准备就绪后，点击Run Simulation中的Run Behavioral Simulation。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104184.png" alt="15"></p><p>自动弹出Modelsim，并显示波形，游戏结束。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104385.png" alt="16"></p>]]></content>
    
    
    <summary type="html">Vivado与Modelsim联合仿真</summary>
    
    
    
    <category term="FPGA" scheme="http://david-luge.cn/categories/FPGA/"/>
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/categories/FPGA/FPGA-Tools/"/>
    
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/tags/FPGA-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Vivado中RTL封装IP流程</title>
    <link href="http://david-luge.cn/2022/09/29/FPGA/Vivado%E4%B8%ADRTL%E5%B0%81%E8%A3%85IP%E6%B5%81%E7%A8%8B/"/>
    <id>http://david-luge.cn/2022/09/29/FPGA/Vivado%E4%B8%ADRTL%E5%B0%81%E8%A3%85IP%E6%B5%81%E7%A8%8B/</id>
    <published>2022-09-29T05:54:39.000Z</published>
    <updated>2022-09-29T05:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vivado中RTL封装IP流程"><a href="#Vivado中RTL封装IP流程" class="headerlink" title="Vivado中RTL封装IP流程"></a>Vivado中RTL封装IP流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录自己将RTL代码封装成IP的流程，以供之后查阅使用。最近一个月在做一个数据仲裁与转发的项目，已经完成功能仿真，准备将其封装成IP在Block Design中进行调用。实验平台为Vivado 2018.3，编程语言为Verilog，IP的接口主要是一个AXI-Lite接口和一个AXI-Full接口。闲言少叙，我们直接开始。</p><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>新建一个文件夹<code>ip_test</code>，在该文件夹下新建文件夹<code>rtl</code>，将所有RTL源码放入该文件夹，完成准备工作；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232113260.png" alt="1"></p><p>新建一个文件夹<code>top_module</code>，里面仅存放RTL源码的最顶层的.v文件，便于IP生成正确的接口。(<strong>之前尝试将所有的RTL源码一次导入，发现vivado不能正确识别顶层模块，从而导致IP接口一直不对</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232113923.png" alt="2"></p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>双击打开vivado 2018.3，选择<code>Tasks-&gt;Manage IP-&gt;New IP Location</code>,按下图所示顺序进行操作；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114706.png" alt="3"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114156.png" alt="4"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114661.png" alt="5"></p><p>上图中的<code>IP location</code>选择之前建立的<code>ip_test</code>文件夹路径，选完后点击<code>Finish</code>完成工程的创建；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114039.png" alt="6"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114564.png" alt="7"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114217.png" alt="8"></p><p>因为本项目已有RTL源码，所以上图中我们选<code>Package a specified directory</code>；如果没有源码想创建一个带AXI接口的空IP往里写功能的话就选择<code>Create a new AXI4 Peripheral</code>；</p><p>此处一定注意下图中的路径，选择<strong>RTL顶层模块源码</strong>的路径</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114671.png" alt="9"></p><p>指定项目的名称，本示例工程名字为<code>ip_test</code>;</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115430.png" alt="10"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115659.png" alt="11"></p><p>点击<code>Finish</code>后我们看到封装IP的界面，此时看到IP的名称与顶层模块相同，且接口也与顶层模块的一致，只是此时除了顶层模块外，其余模块均未添加到<code>Design Sources</code>中。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115723.png" alt="12"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115661.png" alt="13"></p><p>下面进行剩余源码的添加，将<code>rtl</code>文件夹中的代码添加到<code>Design Sources</code>中。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115747.png" alt="14"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115898.png" alt="15"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116980.png" alt="16"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116444.png" alt="17"></p><p>选择IP封装模块的<code>File Groups</code>选项，点击<code>Merge changes from File Groups Wizard</code></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116407.png" alt="18"></p><p>可以看到此时的IP已经包含了所有的源码；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116420.png" alt="19"></p><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116796.png" alt="20"></p><p>在<code>Ports and Interfaces</code>界面中，我们可以看到，vivado工具自动将时钟复位信号、AXI-Full信号和AXI-Lite信号进行打包处理(<em>vivado永远的神！</em>)，但还有一些属性需要设置，否则vivado会报warning。如复位信号的低电平复位属性、时钟与AXI协议的相关属性等；</p><p>添加复位信号的低电平复位属性流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116809.png" alt="21"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116268.png" alt="22"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117310.png" alt="23"></p><p>将<code>clk</code>时钟与<code>rst_clk_n</code>绑定起来，并指定AXI-Lite接口用<code>clk</code>时钟</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117443.png" alt="24"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117514.png" alt="25"></p><p>具体各参数的属性配置情况大家可以参考<strong>vivado官方教程ug1118</strong>。完成上面时钟或者复位的绑定配置后，最后进行IP核的导出。</p><h3 id="导出IP"><a href="#导出IP" class="headerlink" title="导出IP"></a>导出IP</h3><p>在封装IP界面选择<code>Review and Package</code>，先进行打包IP的配置，点击<code>Edit packaging settings</code>；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117071.png" alt="26"></p><p>进行上图所示的配置，其中<code>Delete project after packaging</code>选项可以不选，因为导出IP可能之后还要继续，要对RTL代码进行修改上板测试来迭代更新，所以我们一般保留导出IP的项目工程。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117492.png" alt="27"></p><p>最后回到封装IP的界面，点击<code>Package IP</code>选项即可。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117377.png" alt="28"></p><p>已经成功打包，询问是否关闭项目工程，<code>Yes</code>或者<code>No</code>均可。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232118766.png" alt="29"></p><p>到指定的路径下查看，发现已经生成我们所需的IP。至此，封装IP圆满结束。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232118967.png" alt="30"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文为笔者打包IP的经验分享帖，其中不免错误不足之处，如果其中步骤有误还望大家指正出来，一起交流进步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug1118-vivado-creating-packaging-custom-ip.pdf">Vivado Design Suite User Guide: Creating and Packaging Custom IP (UG1118)</a></p>]]></content>
    
    
    <summary type="html">Vivado中RTL封装IP流程</summary>
    
    
    
    <category term="FPGA" scheme="http://david-luge.cn/categories/FPGA/"/>
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/categories/FPGA/FPGA-Tools/"/>
    
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/tags/FPGA-Tools/"/>
    
  </entry>
  
  <entry>
    <title>NVDLA阅读笔记</title>
    <link href="http://david-luge.cn/2022/09/29/Proj/NVDLA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://david-luge.cn/2022/09/29/Proj/NVDLA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-29T02:04:39.000Z</published>
    <updated>2022-09-29T02:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NVDLA阅读笔记"><a href="#NVDLA阅读笔记" class="headerlink" title="NVDLA阅读笔记"></a>NVDLA阅读笔记</h1><h2 id="Unit-Description"><a href="#Unit-Description" class="headerlink" title="Unit Description"></a>Unit Description</h2><h3 id="System-Architecture"><a href="#System-Architecture" class="headerlink" title="System Architecture"></a>System Architecture</h3><p>NVDLA作为深度学习加速器可以集成在SoC中作为一个协处理器；</p><p>NVDLA有许多数据处理Engine，各Engine都是独立的且可以自由配置，比如不需要池化的网络可以移除Planar Data Processor，各Engine的调度操作可以委托给Microcontroller或者CPU；其中用Microcontroller来调度的方式称为“headed” implementation，用CPU来调度的方式称为“headless” implementation；</p><p>图中左边的框图展示了“headless” implementation的示例，是一个小型的NVDLA系统，成本较低；右边的框图展示了“headed” implementation的示例，是一个大型的NVDLA系统，主要是添加了Microcontroller和高带宽的SRAM，适合于高性能的物联网设备。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141331.png" alt="1"></p><p>NVDLA主要有4个接口，其中SRAMIF是可选项；</p><ul><li>CSB（Configuration Space Bus）：这个接口是一个同步、低带宽、低功耗的32位控制总线，主要用来访问NVDLA的配置寄存器；</li><li>IRQ（Interrupt Request）：当NVDLA中的任务完成或者发生错误时会将中断线进行置位；</li><li>DBB（Data Backbone Interface）：DBB接口连接NVDLA和片外的DRAM，与AXI接口类似，是高速、高度可配置的数据总线，可以根据系统的要求发出不同大小的读写请求；</li><li>SRAMIF（SRAM Interface）：DBB接口还有一个可选的接口，在设计上与DBB接口相同，目的在于结合片上的SRAM来提供更高的数据吞吐量以及更低的访问延迟；</li></ul><h3 id="DLA-Core-Architecture"><a href="#DLA-Core-Architecture" class="headerlink" title="DLA Core Architecture"></a>DLA Core Architecture</h3><p>DLA的结构框图如图所示；内部主要有两个接口模块，其中Configuration Interface用于访问NVDLA的配置寄存器，Memory Interface用于读写特征数据、权重、像素数据等；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141690.png" alt="2"></p><p>Convolution buffer主要用于缓存像素数据、特征数据、权重数据等，供卷积核中的卷积序列控制器模块读取；Convolution core主要完成卷积中的乘加运算；SDP主要负责对单个数据执行后处理操作，包括bias加法、ReLU、Sigmoid、双曲正切、BN、逐元素操作等；PDP是平面数据处理器，主要完成池化相关的操作；CDP主要在通道方向上执行操作，旨在解决局部响应归一化层；RUBIK模块的功能与BDMA类似，它在不进行任何数据计算的情况下转换数据的映射格式，因为它的功能是变换特征数据立方体的尺寸，所以又被称为魔方单元；BDMA模块在外部DRAM和片上SRAM之间提供了一条移动数据的通道，它有两条独立的路径，一条是将数据从外部DRAM复制&#x2F;移动到内部SRAM，另一条是将数据从内部SRAM复制&#x2F;移动到外部DRAM，两条路径不能同时工作；</p><p>NVDLA有两种工作模式，独立模式（Independent Mode）和结合模式（Fused Mode）。独立模式下，各Engine分别通过两组数据接口完成各自分配的任务；结合模式可以将Convolution Core、SDP和PDP连接在一起作为一个整体流水线完成分配的任务；</p><h3 id="Convolution-Pipeline"><a href="#Convolution-Pipeline" class="headerlink" title="Convolution Pipeline"></a>Convolution Pipeline</h3><p>流水线卷积模块是NVDLA的核心逻辑，用于加速卷积算法，同时在卷积流水线中引入了Winograd算法和Multi-batch，提高MAC效率。Convolution Pipeline有五个阶段，分别是Convolution DMA、Convolution Buffer、Convolution Sequence Controller、Convolution MAC和Convolution Accumulator，各阶段都有自己的CSB来接收来自CPU的配置数据。CDMA从SRAM&#x2F;DRAM中获取数据来进行卷积操作，并按卷积Engine所需的数据顺序存储到CBUF中；CBUF缓存来自CDMA模块的像素、特征和权重等数据，由CSC模块进行读取；CSC模块负责从CBUF加载数据并发送到CMAC单元，它是卷积序列控制的关键模块；CMAC模块从CSC接收输入数据和权重，执行乘法和加法运算，并将结果输出给CACC；CACC模块用于对CMAC模块的部分和进行累加，并在发送给SDP模块前对数据进行舍入操作。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141311.png" alt="3"></p><h3 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141023.png" alt="4"></p><p>CDMA主要负责从SRAM&#x2F;DRAM中获取数据来进行卷积操作，读取的数据主要有以下数据类型：</p><ul><li>像素数据（Pixel Data）</li><li>特征数据（Feature Data）</li><li>未压缩&#x2F;压缩权重数据（Uncompressed&#x2F;compressed weight）</li><li>WMB（Weight Mask Bit）</li><li>WGS（Weight Group Size）</li></ul><p>CDMA主要有两个数据通道，分别是权重读取通道和数据读取通道，CDMA仅发送数据读取的请求。CDMA有三个子模块来获取像素数据或者特征数据来进行卷积，分别是CDMA_IMG（Pixel）、CDMA_WG（Winograd）、CDMA_DC（Direct Convolution）。上述三个子模块的工作步骤类似，区别在于数据存放在CBUF RAM中的格式，任何时候只能有一个子模块被激活来获取像素&#x2F;特征数据。以CDMA_DC为例介绍一下CDMA的工作流程：</p><ul><li>检查CBUF的状态，查看是否有空间；</li><li>进行一个读取事务；</li><li>在共享缓冲区（Shared_buffer）中缓存特征数据；</li><li>将特征数据立方体重塑为正确的格式；</li><li>生成卷积缓冲区（CBUF）的写入地址；</li><li>将特征数据写入CBUF；</li><li>更新CDMA_STATUS子模块中CBUF的状态；</li></ul><h3 id="CBUF"><a href="#CBUF" class="headerlink" title="CBUF"></a>CBUF</h3><p>CBUF模块有16个32KB的Bank，每个Bank由两个512位宽、256深度的双口RAM组成，存储空间共512KB；CBUF缓存来自CDMA的像素、特征、权重和WMB数据，并由CSC模块进行读取；CBUF有两个写端口和三个读端口。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141424.png" alt="5"></p><p>如果权重被压缩，那么Bank15分配给WMB数据，Bank0~14分配给特征、权重进行缓存。如果权重没被压缩，那么特征、权重缓冲区可以使用16个Bank；</p><p>每个Bank都是循环缓冲区，新的数据进来时地址都会进行自增，当地址达到最大值后会回到0重新自加；</p><h3 id="CSC"><a href="#CSC" class="headerlink" title="CSC"></a>CSC</h3><p>卷积序列控制器（CSC）负责从CBUF加载输入特征数据、像素数据和权重数据，并将其发送到CMAC单元，主要包含三个模块：CSC_SG、CSC_WL和CSC_DL。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142001.png" alt="6"></p><h4 id="CSC-SG"><a href="#CSC-SG" class="headerlink" title="CSC_SG"></a>CSC_SG</h4><p>CSC_SG模块用来生成序列来控制卷积操作，它的工作流程如下：</p><ol><li>在CBUF中轮询足够的数据和权重；</li><li>生成一对序列包，包括weight加载包和data加载包，每个包表示一个stripe operation；</li><li>将两个加载包push到两个FIFO中；</li><li>两个用于weight和feature&#x2F;image的计数器都是向下计数；&#x2F;&#x2F;计数器的作用？</li><li>当计数器达到零时，检查来自CACC的信号是否有任何back pressure；</li><li>如果所有条件都准备就绪，就将weight和data包发送给CSC_WL和CSC_DL；</li></ol><h4 id="CSC-DL"><a href="#CSC-DL" class="headerlink" title="CSC_DL"></a>CSC_DL</h4><p>CSC_DL（Data loader）负责执行feature&#x2F;image加载序列的逻辑，他从CSC_SG接收包，从CBUF加载feature&#x2F;image data，并将其发送到CMAC；且它还维护CBUF的状态，并与CDMA通信以保持状态最新。对于Winograd模式，它还执行预加法来转换输入数据；</p><p>以DC mode为例说明CSC_DL的工作流程：</p><ol><li>每个Atomic Operation，DL从CBUF读取一个data atom，并发送给CMAC；</li><li>每个Stripe Operation，DL从CBUF读取16~32个data atom，并发送给CMAC；</li><li>每个Block Operation，DL重复（weight_height*weight_width）次stripe operation，从CBUF读取对应的data atom，并发送给CMAC；</li><li>每次Channel Operation，DL重复C&#x2F;64次block Operation，从CBUF读取对应的data atom，并发送给CMAC；</li><li>每个Group Operation，DL遍历整个feature map，重复（data_width*data_height）&#x2F;（16~32）次channel operation，并发送给CMAC；</li><li>DL重复kernel_num&#x2F;（16~32）次group operation，每次的data都是相同的；</li></ol><p>注：16 or 32取决于数据精度。</p><h4 id="CSC-WL"><a href="#CSC-WL" class="headerlink" title="CSC_WL"></a>CSC_WL</h4><p>CSC_WL（Weight loader）执行weight加载序列的逻辑，它从CSC_SG接收包，从CBUF加载weight，并进行必要的解压缩并将其发送到CMAC。它帮助维护权重缓冲区状态，并与CDMA_WT通信，来使状态及时更新。</p><p>以DC mode为例说明CSC_WL的工作流程：</p><ol><li>每个atomic operation，WL不需要操作；</li><li>每个stripe operation，WL从CBUF读取1个group的16&#x2F;32个weight atom，并发送给CMAC；</li><li>每个block operation，WL重复（weight_height*weight_width）次stripe operation，从CBUF读取对应的weight atom，并发送给CMAC；</li><li>每个channel operation，WL重复C&#x2F;64次block operation，从CBUF读取对应的weight atom，并发送给CMAC；（tips：64&#x3D;128byte&#x2F;(int16&#x2F;fp16)）</li><li>每个group operation，WL反复读取同一组group的weight，重复（data_width*data_height）&#x2F;（16~32）次channel operation，并发送给CMAC；</li><li>WL重复kernel_num&#x2F;（16~32）次group operation，完成所有kernel group的读取；</li></ol><h3 id="CMAC"><a href="#CMAC" class="headerlink" title="CMAC"></a>CMAC</h3><p>CMAC（Convolution Multiply Accumulate）模块是流水线卷积操作的一个阶段，它从CSC接收输入数据和权重，进行乘法和加法运算，并将输出结果输出到卷积累加器。当在Winograd模式下工作时，CMAC在输出上执行POA(post addition)将结果转换为标准激活格式。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142273.png" alt="7"></p><p>CMAC有16个相同的MAC Cell，每个MAC Cell包含64个用于16bit的16位乘法器，还包含72个16bit的加法器，用于Winograd的POA。每个16位宽的乘法器和加法器都可以拆分成int8格式的两个计算单元，所以int8的吞吐量是int16的两倍；MAC Cell的流水线深度为7个Cycle。</p><p>为了Physical Design Optimization，CMAC被分为两部分CMAC_A和CMAC_B，每个都有单独的CSB接口。</p><h3 id="CACC"><a href="#CACC" class="headerlink" title="CACC"></a>CACC</h3><p>卷积累加器（CACC）是卷积流水线在CMAC之后的阶段，它用于累加CMAC模块的部分和，并在发送到SDP之前对结果进行舍入&#x2F;饱和。它支持不同位宽的数据输入，对于INT16输入而言结果位宽为48位，对于INT8输入而言结果位宽为34位。CACC和SDP模块之间的数据位宽是32，所以在将结果发送给SDP之前需要执行一个舍入和饱和运算。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142043.png" alt="8"></p><p>CACC中的组件如图所示，工作流程主要如下：</p><ol><li>从assembly SRAM中预取累加和；</li><li>当CMAC的部分和到达时，将它们与累加和一起发送到adder array；如果部分和来自第一个stripe operation，则累积和应为0；</li><li>从adder array的输出端收集新的累加和；</li><li>存储到assembly SRAM中；</li><li>在stripe operation中重复step1~step3，直到一个channel operation完成；</li><li>如果完成channel operation，加法器的输出将被舍入并饱和；</li><li>收集上一步的结果并将其存储到delivery SRAM中；</li><li>从delivery SRAM中加载结果并将它们发送给SDP；</li></ol><p>为支持Direct Convolution模式下的Multi-Batch选项，CACC在交付SRAM组中应用了data remapping功能；为了防止数据溢出，CACC使用相关协议来反压CSC模块。</p><h3 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142835.png" alt="9"></p><p>SDP是单点数据处理器，意在对单个数据元素级别执行后处理操作，主要完成以下的操作：</p><ol><li>**<u>Bias加法</u>**的公式为<code>y=x+bias</code>，bias是一个预先训练的参数，可以是以下3种之一：如果整个data cube都是同一bias的话可以从寄存器获取；per-channel模式下，同一channel内bias共享；per-element模式下，不同的element的bias都不同。</li><li>Non-Linear Function，包括ReLU、Sigmoid和双曲正切。ReLU可以通过硬件逻辑实现，Sigmoid和双曲正切函数是非线性函数，所以用查找表来实现；</li><li>Batch Normalization：SDP支持使用给定的均值&#x2F;标准方差参数进行批量归一化，参数是从训练中获得的，SDP还可以支持按层参数或者按通道参数进行批量归一化操作；</li><li>Element-Wise Layer：它指两个具有相同W、H和C参数的特征数据立方体之间的一种操作。这两个W×H×C特征数据立方体进行元素加法、乘法、或MAX&#x2F;MIN比较操作，并输出一个W×H×C的特征数据立方体；</li><li>PReLU Function，ReLU是将负值裁剪到0，而PReLU是将负值进行缩放；</li><li>Format Conversion：NVDLA支持INT8、INT16和FP16精度，较低的精度可提供较高的性能，而较高的精度可提供更好的推理结果。</li></ol><h3 id="PDP"><a href="#PDP" class="headerlink" title="PDP"></a>PDP</h3><p>PDP主要沿宽×高的平面执行操作，PDP模块旨在完成池化层，支持MAX、MIN和AVERAGE池化操作。PDP单元接收来自SDP或者MCIF&#x2F;SRAMIF的数据，并将数据发送给MCIF&#x2F;SRAMIF。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142274.png" alt="10"></p><p>支持的尺寸如下：Pooling Kernel Size：1<del>8；Pooling Kernel Stride：1</del>16；</p><p>on-the-fly模式下输入数据直接从SDP获取，off-fly模式下输入数据从PDMA获取；</p><p>Pre-processing模块主要完成最大、最小操作以及部分和的求和操作；</p><p>Pos-processing模块主要针对Average Pooling进行相关的后处理操作，如果是MAX&#x2F;MIN Pooling操作的话，那么Share Line Buffer存储的就是最终结果；如果是Average Pooling的话，需要取出Share Line Buffer中的数进行除法操作，并且为方便硬件实现将除法转换为乘法操作；</p><h3 id="CDP"><a href="#CDP" class="headerlink" title="CDP"></a>CDP</h3><p>CDP模块旨在解决局部响应归一化层，LRN通过在通道方向上对局部输入区域进行归一化。CDP模块始终与其它处理子单元<u><strong>独立工作</strong></u>，它从PDMA接收输入数据并将输出数据发送回PDMA。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142860.png" alt="11"></p><p>LRN的计算公式中涉及到除法和指数运算，使用硬件实现代价较大，所以内部用LUT实现功能。</p><h3 id="RUBIK"><a href="#RUBIK" class="headerlink" title="RUBIK"></a>RUBIK</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143590.png" alt="12"></p><p>RUBIK的功能是转换数据的映射格式，主要有三种工作模式：</p><ul><li>contract data cube</li><li>split feature data cube into multi-planar formats</li><li>merge multi-planar formats to data cube</li></ul><h3 id="BDMA"><a href="#BDMA" class="headerlink" title="BDMA"></a>BDMA</h3><p>NVDLA一般将输入图像和处理结果存储在外部DRAM中，但受限于DRAM的带宽和延迟，NVDLA不能提高MAC阵列的效率，所以NVDLA配置了一个到片上SRAM的辅助存储器接口。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143215.png" alt="13"></p><p>NVDLA使用BDMA来在外部DRAM和内部SRAM之间移动数据，有两个独立的路径，一个是从DRAM到SRAM，另一个是从SRAM到DRAM，两个方向不能同时工作。同时BDMA还可以将数据从DRAM移动到DRAM，或者从SRAM移动到SRAM。</p><p>两个接口的数据位宽均为512位，最大突发长度为4。</p><h3 id="MCIF-amp-SRAMIF"><a href="#MCIF-amp-SRAMIF" class="headerlink" title="MCIF&amp;SRAMIF"></a>MCIF&amp;SRAMIF</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143502.png" alt="14"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143212.png" alt="15"></p><p>MCIF用于仲裁多个内部子模块的请求，并转换为AXI协议来连接到外部DRAM。MCIF是同时支持读写通道的仲裁的，但有些NVDLA的子模块只有读请求，如图中的CDMA0和CDMA1只有读请求，其它5个接口均需要读写。</p><p>SRAMIF与MCIF接口功能类似，但预计总线延迟更低。</p><h2 id="Convolution-in-NVDLA"><a href="#Convolution-in-NVDLA" class="headerlink" title="Convolution in NVDLA"></a>Convolution in NVDLA</h2><p>下面简单说一下NVDLA中直接卷积的流程。输入的Data Cube为W×H×C；共K个kernel，每个kernel的尺寸为S×R×C；输出的Data Cube尺寸为W’×H’×C’；其中W’和H’与Padding和Stride有关，C’与Kernel数量相等；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143782.png" alt="16"></p><p>下图显示了Stride和Zero Padding的示意图，其中黑色虚线框出的是Padding之前的Feature Data；Kernel字母表示卷积核的中间位置，可以看到在X方向和Y方向上分别以SX和SY为距离进行步进；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143564.png" alt="17"></p><h3 id="Data-Format"><a href="#Data-Format" class="headerlink" title="Data Format"></a>Data Format</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143069.png" alt="18"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144717.png" alt="19"></p><p>这张图显示了Direct Convolution模式下特征数据与权重的数据格式，特征数据以32Byte为单位，在W-H-C方向上进行扫描并对数据进行存储，如果原始特征数据不是C方向上的32字节对齐，则将数据添加到通道末尾；</p><p>权重数据是在卷积操作之前很久就生成的，软件应将权重数据按DLA中的计算顺序进行映射。权重是在通道方向上以128Byte为单位进行划分，不足128Byte的话要进行一个补零操作，在C’-W-H-C方向上进行扫描并对数据进行存储。</p><h3 id="Atomic-Operation"><a href="#Atomic-Operation" class="headerlink" title="Atomic Operation"></a>Atomic Operation</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144637.png" alt="20"></p><p>在一个原子操作中，每个MAC Cell都取一个1×1×64的weight cube（16bit）来与1×1×64的feature data做运算，**<u>完成64个数的乘加运算操作（64个Channel）</u><strong>。因为有16个MAC Cell，所以一次能并行计算16个kernel，MAC Cell乘加运算后的结果叫做部分和，所以</strong><u>每个Cycle我们可以得到16个部分和（partial sum）</u>**。得到的部分和被送往CACC模块进行累积和的计算。</p><h3 id="Stripe-Operation"><a href="#Stripe-Operation" class="headerlink" title="Stripe Operation"></a>Stripe Operation</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144640.png" alt="21"></p><p>条带操作是原子操作的组合，在一次条带操作的过程中，**<u>MAC Cell中的权重数据保持不变</u>**，特征数据沿着input data cube滑动。（首先沿着W方向进行滑动）</p><p>由于条带操作MAC Cell中权重数据保持不变，所以**<u>一次条带操作中的部分和不能进行累加操作</u>**，因为它们来自不同的卷积核；这就是说需要在CACC模块对部分和进行缓存。</p><p><strong><u>由于CACC模块的缓冲区受限，所以Stripe Operation的Length有上限，上限为32。</u><strong>同时Stripe Operation的Length也有下限，</strong><u>因为要更新下一次Stripe Operation的权重数据至少要16个Cycle，所以下限为16。</u></strong></p><p>即1次Stripe Operation&#x3D;16~32次Atomic Operation，其中Weight Data不变，滑动Feature Data。</p><h3 id="Block-Operation"><a href="#Block-Operation" class="headerlink" title="Block Operation"></a>Block Operation</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144564.png" alt="22"></p><p>Block Operation是由一系列的Stripe Operation组成，**<u>次数为（Weight Width×Weight Height）</u>**，每次Stripe Operation的部分和结果都被发送到CACC模块进行累加和的计算。</p><!--NVDLA文档上写的是16-32 element accumulator，我理解的是可以对16-32路进来的数据进行累加，在一次Block Operation中每路的数据量应该是（Weight Width×Weight Height），每个数据都是Atomic Operation的部分和。--><blockquote><p>The partial sums from the same block operation are added together per stripe operation in the convolution accumulator.</p></blockquote><p>累加和的计算公式如下：<br>$$<br>AS_{w,h,k,c}&#x3D;\sum_{r&#x3D;0}^{R-1}\sum_{s&#x3D;0}^{S-1}\sum_{i&#x3D;c}^{min(c+63,C-1)}x_{(w<em>SX-LP+r),(h</em>SY-TP+s),i}*wt_{r,s,i,k}<br>$$<br>在公式中，AS指accumulative sum，其中第一个和第二个求和应该是由CACC模块进行，第三个求和应该是MAC Cell进行。</p><h3 id="Channel-Operation"><a href="#Channel-Operation" class="headerlink" title="Channel Operation"></a>Channel Operation</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144295.png" alt="23"></p><p>每次Block Operation完成64个kernel的运算，Channel Operation是一系列Block Operation的组合，次数共有<code>(C+63)/64</code>，完成Channel方向上的所有运算。**<u>在同一个Channel Operation中的部分和应该以卷积核为单位继续进行累加操作</u>**，在Channel Operation完成后，存储的累加和才是卷积的最终结果，才会从CACC模块中的assembly SRAM卸载到delivery SRAM，送给后续的处理模块。</p><!--CACC模块对16-32路进来的数据进行累加，在一次Block Operation中每路的数据量应该是（Weight Width×Weight Height）×[(C+63)/64]，每个数据都是Atomic Operation的部分和。--><h3 id="Group-Operation"><a href="#Group-Operation" class="headerlink" title="Group Operation"></a>Group Operation</h3><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144454.png" alt="24"></p><p>Group Operation是Channel Operation的组合，需要重复<code>(data_width*data_height)/(16~32)</code>次。在Group Operation后，输出的数据尺寸为<code>W×H×K&#39;</code>，其中K’为一次Kernel Group中Kernel的数量，对于16-bit的数据而言为16个，对于8-bit的数据而言为32个。</p><p>Direct Convolution重复<code>kernel_num/(16~32)</code>次Group Operation即可完成卷积运算，每次的feature data都是相同的。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="权重压缩"><a href="#权重压缩" class="headerlink" title="权重压缩"></a>权重压缩</h3><ul><li>WMB：Weight Mask Bit，用一位标记来指示权重元素是否为0，1位与1个权重element对应；对于int16和fp16，1位代表2字节权重数据；对于int8，1位代表1个字节的权重数据；WMB始终是128Byte对齐，不足的补0。</li><li>WGS：Weight Group Size，压缩后的权重组数据量大小，单位为Byte，位宽为32bit；</li></ul><h3 id="Multi-Batch-Mode"><a href="#Multi-Batch-Mode" class="headerlink" title="Multi-Batch Mode"></a>Multi-Batch Mode</h3><p>NVDLA支持多批次模式来提高性能并降低带宽，特别是对于全连接层。全连接层的输出是1×1×C的data cube，也就是说FC层中的所有权重只使用一次，就是FC层的一个条带操作内只有一个原子操作，但流水线卷积还需要16个周期来为下一个原子操作加载权重，MAC的效率下降到6.25%。</p><p>多批次就是说同时处理多个输入的特征数据立方体，流水线卷积将为一组权重kernel获取多个输入数据立方体，这也改变了原子操作。来自不同输入数据立方体的1×1×64的cube一个一个交错加载以进行原子操作，然后条带操作包含多个批次的原子操作。由于权重在整个Stripe Operation中重复使用，因此可以把权重加载周期隐藏到处理流程中，提高了MAC的使用效率。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><a href="http://nvdla.org/hw/v1/ias/unit_description.html">Reference</a></p>]]></content>
    
    
    <summary type="html">关于我实习学习NVDLA的一些记录</summary>
    
    
    
    <category term="Proj" scheme="http://david-luge.cn/categories/Proj/"/>
    
    
    <category term="Proj" scheme="http://david-luge.cn/tags/Proj/"/>
    
  </entry>
  
  <entry>
    <title>Verilog各类分频器设计详解</title>
    <link href="http://david-luge.cn/2022/09/29/IC/Basic/Verilog%E5%90%84%E7%B1%BB%E5%88%86%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://david-luge.cn/2022/09/29/IC/Basic/Verilog%E5%90%84%E7%B1%BB%E5%88%86%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-09-29T01:50:39.000Z</published>
    <updated>2022-09-29T01:44:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog各类分频器设计详解"><a href="#Verilog各类分频器设计详解" class="headerlink" title="Verilog各类分频器设计详解"></a>Verilog各类分频器设计详解</h1><p>分频器是时序电路的基本器件，它的功能是对系统时钟或其他时钟进行分频产生所需要的时钟信号。分频有两种方式：一是通过HDL语言建模产生所需要的时钟信号，二是利用开发工具的PLL进行分频。前者分频灵活，需编写代码实现；后者使用场景受限，因为有的低端FPGA没有PLL，但PLL的分频效果更好，而且在进行小数分频时也比较容易实现。<strong>本文首先尝试用HDL语言建模方式设计各种类型的分频器，最后给大家简单介绍一下PLL的使用。</strong>如有不足之处还望大家批评指正。</p><h2 id="偶数分频器"><a href="#偶数分频器" class="headerlink" title="偶数分频器"></a>偶数分频器</h2><p>我们先从最简单的偶数分频器切入，慢慢分析各种分频器的实现。</p><p>若要实现二分频，则只需要在原时钟的上升沿进行输出时钟状态的翻转即可，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232037429.png" alt="1"></p><p>若实现四分频呢？则需要一个计数器，每次在原时钟的上升沿计数，当计数器记到2个上升沿时输出时钟状态进行翻转，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232037205.png" alt="2"></p><p>现在对一般情况进行分析，<strong>对时钟进行N分频，N为偶数</strong>；则计数器每次在原时钟的上升沿计数，<strong>计数器的范围为0~(N-1)<strong>，我们可以在0—(N-1)这N个数中分出两个范围选择输出时钟的状态，如当cnt在0—M范围时输出时钟为低电平，当cnt在(M+1)—(N-1)范围时输出时钟为高电平，则</strong>我们可以动态调整输出时钟的占空比</strong>，输出时钟的占空比为(N-M-1)&#x2F;N；</p><p>以8分频为例，则N&#x3D;8，取M&#x3D;3，则此时输出的时钟应当是50%占空比，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232038249.png" alt="3"></p><p>若取M&#x3D;1，则此时输出时钟的占空比应当是75%，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232038225.png" alt="4"></p><p><strong>偶数分频器代码</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数分频器示例，可调占空比</span></span><br><span class="line"><span class="keyword">module</span> clk_div_even(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> clk,                 <span class="comment">//系统时钟</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> rst_n,               <span class="comment">//异步低电平复位</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] clkperiod,     <span class="comment">//分频系数，N(偶数)分频时clkperiod=N</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] clklow,        <span class="comment">//低电平占用系统时钟的周期数</span></span><br><span class="line">                                    <span class="comment">//占空比为50%时clklow=N/2</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_out<span class="comment">//输出时钟</span></span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] cnt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">        cnt &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == clklow - <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            cnt &lt;= cnt + <span class="number">8&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == clkperiod - <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt + <span class="number">8&#x27;d1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="奇数分频器"><a href="#奇数分频器" class="headerlink" title="奇数分频器"></a>奇数分频器</h2><p>我们先以三分频模块切入，分析奇数分频器的思想：整体思路是<strong>产生两路上升沿和下降沿触发信号</strong>，然后对这两路信号进行操作得到最终分频时钟。</p><p>当分频系数N为奇数时，使用一个计数器在0~(N-1)循环进行计数，控制输出(N-1)&#x2F;2个高电平，(N+1)&#x2F;2个低电平，称为<code>clk_1</code>；然后将此<code>clk_1</code>电平信号延迟半个周期称为<code>clk_2</code>，最后输出<code>clk_out =  clk_1 | clk_2</code>，即为占空比为50%的奇数分频器；另一种思路是产生输出(N+1)&#x2F;2个高电平，(N-1)&#x2F;2个低电平的<code>clk_1</code>，输出的分频时钟为<code>clk_out =  clk_1 &amp; clk_2</code>。</p><p>以<code>clk_out =  clk_1 &amp; clk_2</code>为例，将<code>clk_1</code>延时半个时钟周期的方法有两种，法1是直接使用下降沿的锁存器对<code>clk_1</code>锁存得到<code>clk_2</code>，法2得到<code>clk_2</code>的原理与<code>clk_1</code>相同，不过是在下降沿检测。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232039017.png" alt="5"></p><p>若采用法一，则我们用一个<strong>下降沿触发</strong>的D触发器锁存<code>clk_1</code>的结果<code>clk_2</code>，然后将<code>clk_1</code>与<code>clk_2</code>信号做逻辑“或”就得到了占空比50%的分频时钟信号<code>clk_out</code>。</p><p>结合上面的偶数分频器，如果N为偶数，则<code>clk_1</code>就是我们所需要的分频结果，如果N为奇数，则<code>clk_1 &amp; clk_2</code>就是我们所需的分频结果，所以我们可以把偶数分频和奇数分频结合，实现N分频器设计，其中N为正整数；通过N[0]选择输出，N[0]&#x3D;1为奇数分频，N[0]&#x3D;0为偶数分频。</p><p>5分频结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232040146.png" alt="6"></p><p>6分频结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232040660.png" alt="7"></p><p><strong>正整数分频器代码</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk_div_integer #(</span><br><span class="line">    <span class="keyword">parameter</span> N = <span class="number">6</span>,        <span class="comment">//N分频，N为整数</span></span><br><span class="line">    <span class="keyword">parameter</span> WIDTH = <span class="number">3</span>     <span class="comment">//计数器位宽</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rstn,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> clk_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">reg</span> clk_1,clk_2;</span><br><span class="line">    <span class="keyword">wire</span> clk_odd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == N-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">            clk_1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == ((N-<span class="number">1</span>) &gt;&gt; <span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">                clk_1 &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == (N-<span class="number">1</span>))<span class="keyword">begin</span></span><br><span class="line">                clk_1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                clk_1 &lt;= clk_1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//法1：在时钟下降沿锁存clk_1得到clk_2</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">            clk_2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_2 &lt;= clk_1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//法2:clk2与clk_1产生的方式相同，差别是clk_2是下降沿触发</span></span><br><span class="line">    <span class="comment">// always @(negedge clk or negedge rstn) begin</span></span><br><span class="line">    <span class="comment">//     if(~rstn) begin</span></span><br><span class="line">    <span class="comment">//         clk_2 &lt;= 1&#x27;b0;</span></span><br><span class="line">    <span class="comment">//     end</span></span><br><span class="line">    <span class="comment">//     else begin</span></span><br><span class="line">    <span class="comment">//         if(cnt == ((N-1) &gt;&gt; 1)) begin</span></span><br><span class="line">    <span class="comment">//             clk_2 &lt;= 1&#x27;b0;</span></span><br><span class="line">    <span class="comment">//         end</span></span><br><span class="line">    <span class="comment">//         else if(cnt == (N-1)) begin</span></span><br><span class="line">    <span class="comment">//             clk_2 &lt;= 1&#x27;b1;</span></span><br><span class="line">    <span class="comment">//         end</span></span><br><span class="line">    <span class="comment">//         else begin</span></span><br><span class="line">    <span class="comment">//             clk_2 &lt;= clk_2;</span></span><br><span class="line">    <span class="comment">//         end</span></span><br><span class="line">    <span class="comment">//     end</span></span><br><span class="line">    <span class="comment">// end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> clk_odd = clk_1 | clk_2;</span><br><span class="line">    <span class="keyword">assign</span> clk_out = N[<span class="number">0</span>] ? clk_odd : clk_1;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="半整数分频器"><a href="#半整数分频器" class="headerlink" title="半整数分频器"></a>半整数分频器</h2><p><strong>1、占空比非50%</strong></p><p>网上比较多的分频思路是：半整数分频多出来的那半个周期为高电平，其余为低电平。以5.5分频为例，以原时钟的半周期为单位，可以分频输出1高10低。原理是用计数器循环记数0~10即11个周期，控制输出<code>clk_1</code>前6周期高电平，后5周期低电平，然后再使用该计数器得到一下降沿触发的5低6高的输出<code>clk_2</code>，最后输出<code>clk_out = clk_1 &amp; clk_2</code>。波形图如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232041944.png" alt="8"></p><p>现在我们虽然得到了5.5分频后的信号，但占空比不是很理想，是否可以在其基础上进行改进来实现占空比近似50%的分频信号呢？</p><p><strong>2、占空比近似50%</strong></p><p>由上面的波形图我们可以看到，如果<code>clkx</code>和<code>clky</code>在<code>cnt</code>的其它状态(稍微偏大的值)进行状态翻转的话，可能输出的<code>clk_out = clk_1 &amp; clk_2</code>就能达到近似50%的占空比。在尝试后发现，<code>clkx</code>在<code>cnt</code>等于<code>N+M</code>和<code>2N</code>时进行状态翻转，<code>clky</code>在<code>cnt</code>等于<code>N</code>和<code>M</code>时进行状态翻转，此时输出的<code>clk_out = clk_1 &amp; clk_2</code>近似50%占空比。其中N为不超过分频系数的最大整数，如5.5分频时<code>N=5</code>，当N为奇数时<code>M=(N-1)/2</code>，当N为偶数时<code>M=(N+1)/2</code></p><p>占空比近似50%的4.5分频的波形图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232041417.png" alt="9"></p><p><strong>半整数分频器代码</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> clk_div_half #(</span><br><span class="line">    <span class="keyword">parameter</span> N = <span class="number">5</span>             <span class="comment">//5.5分频时N=5,以此类推</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rstn,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> clk_div</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//localparam M = 0;                                           //占空比非50%，高电平仅有半周期</span></span><br><span class="line">    <span class="keyword">localparam</span> M = N[<span class="number">0</span>] ? ((N - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) : ((N + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);        <span class="comment">//占空比近似50%</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">reg</span> clkx,clky;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">           cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cnt == (N&lt;&lt;<span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">           cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">           cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">            clkx &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == N + M) <span class="keyword">begin</span></span><br><span class="line">            clkx &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == (N &lt;&lt; <span class="number">1</span>))<span class="keyword">begin</span></span><br><span class="line">            clkx &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">            clky &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == N) <span class="keyword">begin</span></span><br><span class="line">            clky &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == M) <span class="keyword">begin</span></span><br><span class="line">            clky &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> clk_div = clkx &amp; clky;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="小数分频器"><a href="#小数分频器" class="headerlink" title="小数分频器"></a>小数分频器</h2><p>以8.7分频为例来分析小数分频器的设计。因为无法用计数器表示0.7这种数字，所以我们用一个等效的概念来实现8.7分频，原时钟87个周期的总时间等于分频后的时钟10个周期的总时间。</p><p>因为8.7分频在8分频和9分频之间，所以我们用8分频和9分频来组合生成8.7分频的时钟。可以列方程组，设8分频共x个周期，9分频共y个周期，则</p><ul><li>x+y&#x3D;10(1)</li><li>8*x + 9 *y &#x3D; 87  (2)</li></ul><p>解得x&#x3D;3，y&#x3D;7。</p><p>即通过3次8分频和7次9分频可得到8.7分频。但如果是按序先输出3个8分频再输出7次9分频的时钟用处不大，我们还得乱序<strong>使其均匀输出，不然会造成时钟频率均匀性不好，相位抖动大的问题</strong>。</p><p>此处我们介绍脉冲删除小数分频，该方法相对比较简单。什么意思呢？就是说我在87个输入时钟里删掉77个时钟周期，这样不就输出了10个时钟周期了吗？也就实现了8.7分频，那么该怎么删呢？查阅论文后得到结论：</p><ol><li>设置寄存器cnt位宽自定，初始值为0；</li><li>在<code>clk</code>的上升沿<code>cnt=cnt+分母</code>，并判断<code>cnt</code>是否大于分子，若大于分子则在下一周期减去分子；</li><li><code>cnt</code>小于分子时，输出脉冲信号为0，<code>cnt</code>大于分子时，输出脉冲信号为1；</li></ol><p>说起来比较乱，我们以7&#x2F;3分频为例来看</p><table><thead><tr><th align="center">时钟序号</th><th align="center">cnt</th><th align="center">输出脉冲</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">6</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">9</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">(12-&gt;)5</td><td align="center">0</td></tr><tr><td align="center">4</td><td align="center">8</td><td align="center">1</td></tr><tr><td align="center">5</td><td align="center">(11-&gt;)4</td><td align="center">0</td></tr><tr><td align="center">6</td><td align="center">(7-&gt;)0</td><td align="center">1</td></tr></tbody></table><p>从表中可以看到每7个周期输出3个脉冲，刚好满足分频要求。</p><p><strong>小数分频器代码</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> clk_div_decimal #(</span><br><span class="line">    <span class="keyword">parameter</span> fraction = <span class="number">16&#x27;d87</span>,       <span class="comment">//分频的分子</span></span><br><span class="line">    <span class="keyword">parameter</span> denominator = <span class="number">16&#x27;d10</span>,    <span class="comment">//分频的分母</span></span><br><span class="line">    <span class="keyword">parameter</span> cnt_width = <span class="number">8</span>            <span class="comment">//计数器的位宽</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rstn,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [cnt_width-<span class="number">1</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstn) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rstn) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">0</span>;</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; fraction) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt + denominator;</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt + denominator - fraction;</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>8.7分频结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232042586.png" alt="10"></p><p>3.25分频结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232042675.png" alt="11"></p><h2 id="PLL分频"><a href="#PLL分频" class="headerlink" title="PLL分频"></a>PLL分频</h2><p>这里就给大家简单介绍一下如何在Vivado中对PLL进行例化。</p><p>首先打开<code>vivado</code>，新建一个RTL项目，点击<code>Flow Navigator</code>窗口中的<code>IP Catalog</code>，在<code>search</code>处搜索自己想要的IP核的名字，例如输入<code>clock</code>就会找到<code>Clocking Wizard</code>这个IP核，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045234.png" alt="12"></p><p>双击Clocking Wizard 这个IP核，就能弹出配置窗口；我们简单配置一些信息，输入时钟为100MHz，分频输出两个时钟，一个是30MHz，一个是18MHz，查看分频效果；</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045483.png" alt="13"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045206.png" alt="14"></p><p>点击Generate,生成IP核，然后在source窗口就会出现一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045112.png" alt="15"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045177.png" alt="16"></p><p>下面对这个生成的IP进行例化，测试分频效果</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045911.png" alt="17"></p><p>将这个例化模块的例程添加到自己的顶层仿真代码中，就可以查看分频结果了。</p><hr><p>本次的博客就讲到这里，其中PLL的使用讲的很浅显，大家要想深入学习PLL的IP使用的话可以学习官方文档。若文章中存在任何错误或不足欢迎大家指正，欢迎大家在博客下方留言交流。</p>]]></content>
    
    
    <summary type="html">简要介绍了各种分频器的verilog设计方法,笔试常用</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>为什么D触发器需要建立时间和保持时间</title>
    <link href="http://david-luge.cn/2022/09/29/IC/Basic/%E4%B8%BA%E4%BB%80%E4%B9%88D%E8%A7%A6%E5%8F%91%E5%99%A8%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E4%B8%8E%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4/"/>
    <id>http://david-luge.cn/2022/09/29/IC/Basic/%E4%B8%BA%E4%BB%80%E4%B9%88D%E8%A7%A6%E5%8F%91%E5%99%A8%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E4%B8%8E%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4/</id>
    <published>2022-09-29T01:44:39.000Z</published>
    <updated>2022-09-29T01:44:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么D触发器需要建立时间与保持时间"><a href="#为什么D触发器需要建立时间与保持时间" class="headerlink" title="为什么D触发器需要建立时间与保持时间"></a>为什么D触发器需要建立时间与保持时间</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>建立时间</strong>：时钟有效沿到来之前的某段时间内，数据必须稳定，这段时间称为建立时间，用Tsetup或者Tsu表示。</p><p><strong>保持时间</strong>：时钟有效沿到来之后的某段时间内，数据必须稳定，这段时间成为保持时间，用Thold或者Th表示。</p><p>时序图如下</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048432.png" alt="1"></p><h2 id="为什么需要建立时间和保持时间"><a href="#为什么需要建立时间和保持时间" class="headerlink" title="为什么需要建立时间和保持时间"></a>为什么需要建立时间和保持时间</h2><p><a href="https://zhuanlan.zhihu.com/p/120863919">从CMOS到建立时间和保持时间</a>这篇文章里作者已经讲的很详细了，我就不再赘述锁存器的原理了，大家有疑问的话可以先去看看这篇文章，这里我只简单举例记录一下我个人对建立时间和保持时间的理解。</p><p>我们从D触发器的门级电路开始分析，D触发器的门级电路如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048337.png" alt="2"></p><p>D触发器在时钟(上升)边沿进行数据的锁存。我们这里假设原来的输出是1，即从锁存器锁存的数据为1，要锁存的数据是0，来理解建立时间和保持时间。</p><p>要让时钟上升沿之后Q输出为0，即让从锁存器的输出变为0，也就是要让主锁存器在时钟上升沿之后稳定地锁存住0。</p><p>总结而言，<strong>在上升沿到来及到来之后，主锁存器负责锁存数据，而从锁存器负责传输主锁存器所锁存好的数据。</strong>这样一来，我们重点分析<strong>主锁存器</strong>即可。</p><p>主锁存器的门级电路：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048755.png" alt="3"></p><p><strong>1、如果数据的建立时间不足，会发生什么？</strong></p><p>按我们的假设，也就是数据(0)相对于时钟上升沿来的晚了。假设在T&#x3D;0ns的时候，clk从0变成1(为方便分析，假设时钟理想无跳变延时)。我们假设一个数据D1&#x3D;0在T&#x3D;-0.7ns(即比时钟上升沿提前0.7s)的时候到达数据的端口，然后另一个数据D2&#x3D;0在T&#x3D;-0.3ns的时候才来到数据端口(即D1来得早，而D2来得比较晚不满足建立时间的要求)。我们看看D1的路线，首先经过反相器变为1，然后经过与门(此时时钟还是低电平，该与门的另一个输入为1)变成1，经过或非门之后，将输出Q变成了0。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048629.png" alt="4"></p><p>但<strong>此时主锁存器输出的Q还不稳定，需要通过反馈改变或非门的输入才能保持输出数据的稳定。</strong>如下图所示，通过反馈使得自己或非门的输入为1才能维持Q的稳定，需要<code>t1+t2+t3</code>的时间。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048942.png" alt="5"></p><p>我们再回过头看D2这个数据，它提前于时钟沿的时间不多，刚经过与门时钟沿就来了，<strong>没有成功通过反馈到达或非门的输入</strong>，不能稳定锁存住从锁存器要锁存的0值，这就是建立时间不足引起的锁存不住值导致亚稳态的原因。</p><p><strong>2、如果数据的保持时间不足，会发生什么？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048433.png" alt="6"></p><p>我们看保持时间仍要从主锁存器这边看：</p><p>假设T&#x3D;0时刻时钟Clk发生从0-&gt;1的上升沿跳变，Clk的高电平信号首先要经过反相器变成0信号后传到后面的与门，如上图绿线所示路径，假设该路径延迟时间为t2，也就是说t2时刻与门的输入就为低电平0，那么在t2时刻之前，与门的Clk输入端始终保持高电平1。</p><p>在t2之前，如果输入端D发生跳变(按我们的假设，从0变为1，即数据的保持时间不足)，变换后的数据端高电平经过t1延迟时间后(上图蓝线所示路径)，到达与门的另一个输入端。</p><p>一般情况下，由于时钟信号需要经过反相器，所以<code>t2&gt;t1</code>，<strong>那么与门的输出在t1~t2时刻之间的时候输出为1。</strong>也就是SR锁存器的置位端为1，这会导致Q&#x3D;1，这与我们要锁存的0值不同，导致亚稳态的出现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>建立时间：在时钟上升沿到来之前主锁存器将数据稳定锁存所需的时间。</strong></p><p><strong>保持时间：在时钟上升沿到来之后主锁存器传输门关断至锁存数据的时间。</strong></p>]]></content>
    
    
    <summary type="html">为什么D触发器需要建立时间和保持时间</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu开发环境打造</title>
    <link href="http://david-luge.cn/2022/09/23/Misc/Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%89%93%E9%80%A0/"/>
    <id>http://david-luge.cn/2022/09/23/Misc/Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%89%93%E9%80%A0/</id>
    <published>2022-09-23T04:50:00.000Z</published>
    <updated>2022-09-23T04:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu开发环境打造"><a href="#Ubuntu开发环境打造" class="headerlink" title="Ubuntu开发环境打造"></a>Ubuntu开发环境打造</h1><h2 id="安装ubuntu18-04"><a href="#安装ubuntu18-04" class="headerlink" title="安装ubuntu18.04"></a>安装ubuntu18.04</h2><p>下载：</p><blockquote><p>  <a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></p></blockquote><h2 id="配置清华软件源"><a href="#配置清华软件源" class="headerlink" title="配置清华软件源"></a>配置清华软件源</h2><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p></blockquote><h2 id="双系统时间不同步问题"><a href="#双系统时间不同步问题" class="headerlink" title="双系统时间不同步问题"></a>双系统时间不同步问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure><h2 id="安装Synaptic包管理器"><a href="#安装Synaptic包管理器" class="headerlink" title="安装Synaptic包管理器"></a>安装Synaptic包管理器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install synaptic</span><br></pre></td></tr></table></figure><h2 id="安装编译开发环境"><a href="#安装编译开发环境" class="headerlink" title="安装编译开发环境"></a>安装编译开发环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h2 id="Home下目录改成英文"><a href="#Home下目录改成英文" class="headerlink" title="Home下目录改成英文"></a>Home下目录改成英文</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ export LANG=en_US</span><br><span class="line"></span><br><span class="line">$ xdg-user-dirs-gtk-update</span><br><span class="line"></span><br><span class="line">这个时候会弹出一个配置界面，提示是否将中文目录切换为英文目录。选中不再提示，确定</span><br><span class="line"></span><br><span class="line">最后再执行如下命令还原到系统之前的设置</span><br><span class="line">$ export LANG=zh_CN</span><br></pre></td></tr></table></figure><h2 id="安装并配置VS-Code"><a href="#安装并配置VS-Code" class="headerlink" title="安装并配置VS Code"></a>安装并配置VS Code</h2><p>下载安装包</p><blockquote><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p></blockquote><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i [安装包文件名]</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code</span><br></pre></td></tr></table></figure><p>以超级用户启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo code --user-data-dir=&quot;/home/wg/.vscode/&quot;</span><br></pre></td></tr></table></figure><p>安装插件</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232124452.png" alt="1"></p><h2 id="Ubuntu安装pytorch"><a href="#Ubuntu安装pytorch" class="headerlink" title="Ubuntu安装pytorch"></a>Ubuntu安装pytorch</h2><p>版本：python3.6.9</p><p>安装pip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure><p>更换阿里源<br>修改 ~&#x2F;.pip&#x2F;pip.conf (没有就创建一个)， 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><p>升级pip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><p>安装常用包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip3 install numpy</span><br><span class="line">pip3 install opencv-python</span><br><span class="line">pip3 install torch</span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure><p>下载离线安装包<br>torchtorchvision   python                cuda</p><p>1.5.10.6.1       &gt;&#x3D;3.6                9.2, 10.1,10.2</p><p>1.5.00.6.0       &gt;&#x3D;3.6                9.2, 10.1,10.2</p><p>1.4.00.5.0       &#x3D;&#x3D;2.7, &gt;&#x3D;3.5, &lt;&#x3D;3.8    9.2, 10.0</p><p>1.3.10.4.2       &#x3D;&#x3D;2.7, &gt;&#x3D;3.5, &lt;&#x3D;3.7    9.2, 10.0</p><p>1.3.00.4.1       &#x3D;&#x3D;2.7, &gt;&#x3D;3.5, &lt;&#x3D;3.7    9.2, 10.0</p><p>1.2.00.4.0       &#x3D;&#x3D;2.7, &gt;&#x3D;3.5, &lt;&#x3D;3.7    9.2, 10.0</p><p>1.1.00.3.0       &#x3D;&#x3D;2.7, &gt;&#x3D;3.5, &lt;&#x3D;3.7    9.0, 10.0</p><p>&lt;1.0.10.2.2       &#x3D;&#x3D;2.7, &gt;&#x3D;3.5, &lt;&#x3D;3.7    9.0, 10.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install torch-1.4.0-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">sudo pip install torchvision-0.5.0-cp36-cp36m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><h2 id="安装Vivado-2018-2"><a href="#安装Vivado-2018-2" class="headerlink" title="安装Vivado 2018.2"></a>安装Vivado 2018.2</h2><p>下载安装包</p><blockquote><p><a href="https://china.xilinx.com/support/download.html">https://china.xilinx.com/support/download.html</a></p></blockquote><p>解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf xxx.tar.gz</span><br></pre></td></tr></table></figure><p>执行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./xsetup</span><br></pre></td></tr></table></figure><p>安装路径选择默认</p><p>安装JTAG驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers/</span><br><span class="line">sudo ./install_drivers</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit .bashrc</span><br></pre></td></tr></table></figure><p>添加命令别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias svvd=&#x27;source /opt/Xilinx/Vivado/2018.2/settings64.sh&#x27;</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#启动Vivado</span><br><span class="line">$ vivado</span><br><span class="line"></span><br><span class="line">#启动Vivado HLS</span><br><span class="line">$ vivado_hls</span><br><span class="line"></span><br><span class="line">#启动XSDK</span><br><span class="line">$ xsdk</span><br></pre></td></tr></table></figure><h2 id="安装SSH服务并开机自启"><a href="#安装SSH服务并开机自启" class="headerlink" title="安装SSH服务并开机自启"></a>安装SSH服务并开机自启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">sudo systemctl enable ssh</span><br><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure><h2 id="安装GHex"><a href="#安装GHex" class="headerlink" title="安装GHex"></a>安装GHex</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ghex</span><br></pre></td></tr></table></figure><h2 id="安装Typora"><a href="#安装Typora" class="headerlink" title="安装Typora"></a>安装Typora</h2><blockquote><p><a href="https://typora.io/#linux">https://typora.io/#linux</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or run:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add Typora<span class="string">&#x27;s repository</span></span></span><br><span class="line">sudo add-apt-repository &#x27;deb https://typora.io/linux ./&#x27;</span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">install typora</span></span></span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><h2 id="安装坚果云（NutStore）"><a href="#安装坚果云（NutStore）" class="headerlink" title="安装坚果云（NutStore）"></a>安装坚果云（NutStore）</h2><blockquote><p><a href="https://www.jianguoyun.com/s/downloads/linux">https://www.jianguoyun.com/s/downloads/linux</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i nautilus_nutstore_amd64.deb</span><br><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure><h2 id="安装网易云音乐"><a href="#安装网易云音乐" class="headerlink" title="安装网易云音乐"></a>安装网易云音乐</h2><blockquote><p><a href="https://music.163.com/#/download">https://music.163.com/#/download</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232125711.png" alt="2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure><h2 id="安装FlameShot"><a href="#安装FlameShot" class="headerlink" title="安装FlameShot"></a>安装FlameShot</h2><p>下载安装包</p><blockquote><p><a href="https://github.com/lupoDharkael/flameshot/releases">https://github.com/lupoDharkael/flameshot/releases</a></p></blockquote><p>rpm包是yum的安装文件，.deb包才是Ubuntu安装包</p><ul><li><p>bionic：Ubuntu18.04的版本名</p></li><li><p>jessie：Debian8.6版本的版本名</p></li><li><p>stretch：Debian9的版本名</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i flameshot_0.6.0_bionic_x86_64.deb</span><br></pre></td></tr></table></figure><p>创建截图快捷键</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232125490.png" alt="3"></p><h2 id="破解安装Beyond-Compare"><a href="#破解安装Beyond-Compare" class="headerlink" title="破解安装Beyond Compare"></a>破解安装Beyond Compare</h2><blockquote><p><a href="http://www.scootersoftware.com/download.php">http://www.scootersoftware.com/download.php</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232125626.png" alt="4"></p><p>下载64位的.deb包，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i [安装包文件名]</span><br></pre></td></tr></table></figure><p><strong>破解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转到安装路径：</span><br><span class="line">cd /usr/lib/beyondcompare/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i &quot;s/keexjEP3t4Mue23hrnuPtY4TdcsqNiJL-5174TsUdLmJSIXKfG2NGPwBL6vnRPddT7tH29qpkneX63DO9ECSPE9rzY1zhThHERg8lHM9IBFT+rVuiY823aQJuqzxCKIE1bcDqM4wgW01FH6oCBP1G4ub01xmb4BGSUG6ZrjxWHJyNLyIlGvOhoY2HAYzEtzYGwxFZn2JZ66o4RONkXjX0DF9EzsdUef3UAS+JQ+fCYReLawdjEe6tXCv88GKaaPKWxCeaUL9PejICQgRQOLGOZtZQkLgAelrOtehxz5ANOOqCaJgy2mJLQVLM5SJ9Dli909c5ybvEhVmIC0dc9dWH+/N9KmiLVlKMU7RJqnE+WXEEPI1SgglmfmLc1yVH7dqBb9ehOoKG9UE+HAE1YvH1XX2XVGeEqYUY-Tsk7YBTz0WpSpoYyPgx6Iki5KLtQ5G-aKP9eysnkuOAkrvHU8bLbGtZteGwJarev03PhfCioJL4OSqsmQGEvDbHFEbNl1qJtdwEriR+VNZts9vNNLk7UGfeNwIiqpxjk4Mn09nmSd8FhM4ifvcaIbNCRoMPGl6KU12iseSe+w+1kFsLhX+OhQM8WXcWV10cGqBzQE9OqOLUcg9n0krrR3KrohstS9smTwEx9olyLYppvC0p5i7dAx2deWvM1ZxKNs0BvcXGukR+/g&quot; BCompare</span><br></pre></td></tr></table></figure><p>然后打开Beyond Conpare，弹出Trial Mode Error！弹窗</p><p>单击右下角按钮“Enter Key”，输入以下秘钥【注意：包括开始和结尾的横线行】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- BEGIN LICENSE KEY ---</span><br><span class="line">GXN1eh9FbDiX1ACdd7XKMV7hL7x0ClBJLUJ-zFfKofjaj2yxE53xauIfkqZ8FoLpcZ0Ux6McTyNmODDSvSIHLYhg1QkTxjCeSCk6ARz0ABJcnUmd3dZYJNWFyJun14rmGByRnVPL49QH+Rs0kjRGKCB-cb8IT4Gf0Ue9WMQ1A6t31MO9jmjoYUeoUmbeAQSofvuK8GN1rLRv7WXfUJ0uyvYlGLqzq1ZoJAJDyo0Kdr4ThF-IXcv2cxVyWVW1SaMq8GFosDEGThnY7C-SgNXW30jqAOgiRjKKRX9RuNeDMFqgP2cuf0NMvyMrMScnM1ZyiAaJJtzbxqN5hZOMClUTE+++</span><br><span class="line">--- END LICENSE KEY -----</span><br></pre></td></tr></table></figure><p>破解成功的重要标志</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232126402.png" alt="5"></p><p>务必取消更新检测（否则破解过一段时间就会失效）</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232126083.png" alt="6"></p><p><strong>破解失效的解决办法</strong></p><p>删除如下的两个文件即可</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232127803.png" alt="7"></p><h2 id="安装并配置Synergy"><a href="#安装并配置Synergy" class="headerlink" title="安装并配置Synergy"></a>安装并配置Synergy</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install synergy</span><br></pre></td></tr></table></figure><p>遇到问题system tray is unavailable, don’t close your window，解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sni-qt</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://vvplus.net/multi-computer-screen-sharing-keyboard-mouse-synergy1-8-8-stable-windows10-mac-linux-download-configuration.html">https://vvplus.net/multi-computer-screen-sharing-keyboard-mouse-synergy1-8-8-stable-windows10-mac-linux-download-configuration.html</a></p></blockquote><p>可用注册码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7B76313B70726F3BE5BDAC20E585B33B313B73796E313333323040676D61696C2E636F6D3B3B3B7D</span><br></pre></td></tr></table></figure><h2 id="设置开机启动项"><a href="#设置开机启动项" class="headerlink" title="设置开机启动项"></a>设置开机启动项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232127621.png" alt="8"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232128108.png" alt="9"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232128032.png" alt="10"></p><h2 id="无法识别exfat格式分区"><a href="#无法识别exfat格式分区" class="headerlink" title="无法识别exfat格式分区"></a>无法识别exfat格式分区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install exfat-utils</span><br></pre></td></tr></table></figure><h2 id="Firefox无法播放bilibili视频"><a href="#Firefox无法播放bilibili视频" class="headerlink" title="Firefox无法播放bilibili视频"></a>Firefox无法播放bilibili视频</h2><p>提示未安装flash，实际上是缺少本地解码器，可以通过安装<del>mplayer</del>解决，（mplayer无界面，转而安装vlc）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vlc</span><br></pre></td></tr></table></figure><h2 id="vlc无法播放H-264视频"><a href="#vlc无法播放H-264视频" class="headerlink" title="vlc无法播放H.264视频"></a>vlc无法播放H.264视频</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ubuntu-restricted-extras</span><br></pre></td></tr></table></figure><h2 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h2><p>下载.deb</p><p><a href="https://pinyin.sogou.com/linux/">https://pinyin.sogou.com/linux/</a></p><p>安装过程</p><p><a href="https://pinyin.sogou.com/linux/help.php">https://pinyin.sogou.com/linux/help.php</a></p><p>安装结束后卸载ibus框架相关组件，只保留fcitx框架</p><p>查看日志，搜狗提示libpng12.0.so找不到，（18.04已经安装了libpng16，不能通过apt安装libpng12，只能手动下载deb包安装）</p><blockquote><p><a href="https://mirrors.ustc.edu.cn/ubuntu/pool/main/libp/libpng/">https://mirrors.ustc.edu.cn/ubuntu/pool/main/libp/libpng/</a></p></blockquote><p>安装后，搜狗的顶栏图标正常，Xilinx的Docnav也可以打开。</p><p>但安装后，出现了两个搜狗输入法的图标，此时对fcitx进行配置，隐藏fcitx的图标。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232128452.png" alt="11"></p><h2 id="解决AIR-14-2020的声音伪输出的问题"><a href="#解决AIR-14-2020的声音伪输出的问题" class="headerlink" title="解决AIR 14 2020的声音伪输出的问题"></a>解决AIR 14 2020的声音伪输出的问题</h2><p>本问题可能由于5.4内核对英特尔最新硬件的支持不足导致的。</p><p>step1：对于Ubuntu18.04，升级内核相关的包到最新版本（grub*，linux*）</p><p>step2：在&#x2F;etc&#x2F;modprobe.d&#x2F;alsa-base.conf添加中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options snd-hda-intel dmic_detect=0</span><br><span class="line">或者</span><br><span class="line">options snd-intel-dspcfg dsp_driver=1（使用dsp而不是sof）</span><br></pre></td></tr></table></figure><p>重启后检查是否有声音，</p><p>step3：重新安装（alsa*，不包括alsa-tools等）（pulseaudio*）等包，gstreamer1.0-alsa，gstreamer1.0-pulseaudio等包，</p><p>重启。</p><h2 id="设置GRUB2默认启动操作系统"><a href="#设置GRUB2默认启动操作系统" class="headerlink" title="设置GRUB2默认启动操作系统"></a>设置GRUB2默认启动操作系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设定默认启动项，推荐使用数字（0代表第1项，1 &gt;0代表第2项的第1子项）</span><br><span class="line">GRUB_DEFAULT=2</span><br><span class="line"></span><br><span class="line">#显示倒计时</span><br><span class="line">GRUB_TIMEOUT_STYLE=countdown</span><br><span class="line"></span><br><span class="line">#超时时间，默认为10秒</span><br><span class="line">GRUB_TIMEOUT=6</span><br></pre></td></tr></table></figure><p><strong>记得</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub </span><br></pre></td></tr></table></figure><h2 id="安装清理工具Bleachbit"><a href="#安装清理工具Bleachbit" class="headerlink" title="安装清理工具Bleachbit"></a>安装清理工具Bleachbit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bleachbit</span><br></pre></td></tr></table></figure><h2 id="安装PDF批注软件Xournal"><a href="#安装PDF批注软件Xournal" class="headerlink" title="安装PDF批注软件Xournal"></a>安装PDF批注软件Xournal</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xournal</span><br></pre></td></tr></table></figure><h2 id="安装电子书管理器Calibre"><a href="#安装电子书管理器Calibre" class="headerlink" title="安装电子书管理器Calibre"></a>安装电子书管理器Calibre</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install calibre</span><br></pre></td></tr></table></figure><h2 id="安装音频编辑软件Audacity"><a href="#安装音频编辑软件Audacity" class="headerlink" title="安装音频编辑软件Audacity"></a>安装音频编辑软件Audacity</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install audacity</span><br></pre></td></tr></table></figure><h2 id="安装矢量绘图软件Inkscape"><a href="#安装矢量绘图软件Inkscape" class="headerlink" title="安装矢量绘图软件Inkscape"></a>安装矢量绘图软件Inkscape</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install inkscape</span><br></pre></td></tr></table></figure><h2 id="安装几何画板软件GeoGebra"><a href="#安装几何画板软件GeoGebra" class="headerlink" title="安装几何画板软件GeoGebra"></a>安装几何画板软件GeoGebra</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install geogebra</span><br></pre></td></tr></table></figure><h2 id="安装科学计算软件Octave"><a href="#安装科学计算软件Octave" class="headerlink" title="安装科学计算软件Octave"></a>安装科学计算软件Octave</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install octave</span><br></pre></td></tr></table></figure><h2 id="安装utools插件框架"><a href="#安装utools插件框架" class="headerlink" title="安装utools插件框架"></a>安装utools插件框架</h2><blockquote><p><a href="https://u.tools/">https://u.tools/</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure><p>安装下面的插件</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232129296.png" alt="12"></p><h2 id="破解安装Xmind"><a href="#破解安装Xmind" class="headerlink" title="破解安装Xmind"></a>破解安装Xmind</h2><p>下载补丁（app.asar），</p><blockquote><p><a href="https://www.ghpym.com/xmindzen.html">https://www.ghpym.com/xmindzen.html</a></p></blockquote><p>安装官方程序，</p><blockquote><p><a href="https://www.xmind.cn/download/">https://www.xmind.cn/download/</a></p></blockquote><p>然后进入程序目录&#x2F;opt&#x2F;XMind ZEN&#x2F;XMind&#x2F;resources<br>替换此目录的app.asar 文件即可</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232129487.png" alt="13"></p><h2 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h2><blockquote><p><a href="https://www.vmware.com/go/downloadworkstation">https://www.vmware.com/go/downloadworkstation</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh ./VMware-Workstation-Full-15.5.6.x86_64.bundle</span><br></pre></td></tr></table></figure><p>显示Successful则成功</p><h2 id="安装Gnome-Shell插件"><a href="#安装Gnome-Shell插件" class="headerlink" title="安装Gnome Shell插件"></a>安装Gnome Shell插件</h2><p>打开Gnome软件中心，选择附加组件，</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232130975.png" alt="14"></p><p>已安装：</p><ul><li>Bing wallpaper</li><li>Workspace indicator</li><li>NetSpeed</li></ul><p>在这里进行管理，</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232130925.png" alt="15"></p><h2 id="屏蔽邮件服务程序的开机自启"><a href="#屏蔽邮件服务程序的开机自启" class="headerlink" title="屏蔽邮件服务程序的开机自启"></a>屏蔽邮件服务程序的开机自启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --user mask evolution-addressbook-factory.service evolution-calendar-factory.service evolution-source-registry.service</span><br></pre></td></tr></table></figure><h2 id="查看dpkg安装日志"><a href="#查看dpkg安装日志" class="headerlink" title="查看dpkg安装日志"></a>查看dpkg安装日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;\ install\ &quot; /var/log/dpkg.log</span><br></pre></td></tr></table></figure><h2 id="安装Windows字体"><a href="#安装Windows字体" class="headerlink" title="安装Windows字体"></a>安装Windows字体</h2><p>从Windows系统中找到相应字体文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/share/fonts/truetype/windows-font</span><br></pre></td></tr></table></figure><p>拷贝字体到Windows目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 777  /usr/share/fonts/truetype/windows-font</span><br><span class="line">cd /usr/share/fonts/truetype/windows-font</span><br><span class="line">mkfontscale</span><br><span class="line">mkfontdir</span><br><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure><h2 id="配置科学上网（科技熊、光速云）"><a href="#配置科学上网（科技熊、光速云）" class="headerlink" title="配置科学上网（科技熊、光速云）"></a>配置科学上网（科技熊、光速云）</h2><blockquote><p><a href="https://kejibearstudio.tk/">https://kejibearstudio.tk/</a></p></blockquote><blockquote><p><a href="https://kejibearstudio.tk/user/tutorial?os=linux&amp;client=clash">https://kejibearstudio.tk/user/tutorial?os=linux&amp;client=clash</a></p></blockquote><p>下载clash的二进制文件</p><p><a href="https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a></p><p>下载机场的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">光速云</span><br><span class="line">wget -O gsy-config.yaml &quot;https://136900.xyz/link/glLP6b5aqiOxa6Xg?clash=1&amp;log-level=info&quot;</span><br><span class="line"></span><br><span class="line">科技熊</span><br><span class="line">wget -O kjx-config.yaml &quot;https://service-6wrorr47-1254266595.sh.apigw.tencentcs.com/link/MKKO2wk7drvLpKrp?clash=1&amp;log-level=info&quot;</span><br></pre></td></tr></table></figure><p>对于光速云</p><p>需要修改<code>gsy-config.yaml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除 trojan 测试 项</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clash  -d .  -f gsy-config.yaml</span><br></pre></td></tr></table></figure><blockquote><p>Usage of .&#x2F;clash:<br>  -d string<br>        set configuration directory<br>  -ext-ctl string<br>        override external controller address<br>  -ext-ui string<br>        override external ui directory<br>  -f string<br>        specify configuration file<br>  -secret string<br>        override secret for RESTful API<br>  -ttest configuration and exit<br>  -vshow current version of clash</p></blockquote><p>使用浏览器访问</p><p><a href="http://clash.razord.top/#/proxies">http://clash.razord.top/#/proxies</a></p><p>打开系统代理</p><p>打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 <code>127.0.0.1:7890</code>，填写 Socks 主机为 <code>127.0.0.1:7891</code>，即可启用系统代理。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232130527.png" alt="16"></p><p>设置开机启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;(sleep 15 &amp;&amp; cd /home/kopera/Tools/ &amp;&amp; clash -d . -f gsy-config.yaml)&quot;</span><br></pre></td></tr></table></figure><h2 id="GNOME3安装主题与图标包"><a href="#GNOME3安装主题与图标包" class="headerlink" title="GNOME3安装主题与图标包"></a>GNOME3安装主题与图标包</h2><p><strong>theme</strong>：控制窗口样式</p><p><strong>shell theme</strong>：控制顶栏样式（可以不启用）</p><blockquote><p><a href="https://www.pling.com/p/1334194/">https://www.pling.com/p/1334194/</a></p></blockquote><p>在<code>home</code>下建立<code>.themes</code>文件夹，放入下载的主题包后，从gnome-tweak-tool中选择</p><p><strong>icon theme</strong>：控制图标样式</p><blockquote><p><a href="https://www.pling.com/p/1279924/">https://www.pling.com/p/1279924/</a></p></blockquote><p>在<code>home</code>下建立<code>.icons</code>文件夹，放入下载的图标包后，从gnome-tweak-tool中选择</p><h2 id="安装Foxit-Reader阅读器"><a href="#安装Foxit-Reader阅读器" class="headerlink" title="安装Foxit Reader阅读器"></a>安装Foxit Reader阅读器</h2><blockquote><p><a href="https://www.foxitsoftware.cn/">https://www.foxitsoftware.cn/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232131679.png" alt="17"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232131998.png" alt="18"></p><p>下载<code>.run</code>文件，使用sudo权限安装至<code>/opt/Foxit</code>下</p><h2 id="安装CopyTranslator"><a href="#安装CopyTranslator" class="headerlink" title="安装CopyTranslator"></a>安装CopyTranslator</h2><blockquote><p><a href="https://github.com/CopyTranslator/CopyTranslator/releases">https://github.com/CopyTranslator/CopyTranslator/releases</a></p></blockquote><h2 id="安装balenaEtcher"><a href="#安装balenaEtcher" class="headerlink" title="安装balenaEtcher"></a>安装balenaEtcher</h2><blockquote><p><a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a></p><p><a href="https://github.com/balena-io/etcher/releases">https://github.com/balena-io/etcher/releases</a></p></blockquote><h2 id="安装Free-Download-Manager"><a href="#安装Free-Download-Manager" class="headerlink" title="安装Free Download Manager"></a>安装Free Download Manager</h2><blockquote><p><a href="https://www.freedownloadmanager.org/zh/download-fdm-for-linux.htm">https://www.freedownloadmanager.org/zh/download-fdm-for-linux.htm</a></p></blockquote><h2 id="基于VScode-Vivado的HDL仿真环境"><a href="#基于VScode-Vivado的HDL仿真环境" class="headerlink" title="基于VScode+Vivado的HDL仿真环境"></a>基于VScode+Vivado的HDL仿真环境</h2><p>安装插件：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133836.png" alt="19"></p><p>配置插件：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133328.png" alt="20"></p><p>修改插件源码（以支持linux并且去掉无效功能）</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133204.png" alt="21"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133260.png" alt="22"></p><p>修改插件源码（修改生成样式）</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133268.png" alt="23"></p><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定综合的顶层模块</span></span><br><span class="line">SYNTH_TOP = pc</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定仿真的顶层模块</span></span><br><span class="line">SIM_TOP = <span class="variable">$(SYNTH_TOP)</span>_tb</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定新建工程的序号</span></span><br><span class="line">INDEX = <span class="variable">$(N)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定坚果云同步目录</span></span><br><span class="line">Cur_Dir = <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">basename</span> `pwd`)</span></span><br><span class="line">Nut_Path = /home/wg/Nutstore\ Files/我的坚果云/Coding/Verilog</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建文件</span></span><br><span class="line"><span class="section">create:</span></span><br><span class="line">touch src/<span class="variable">$(SIM_TOP)</span>.v</span><br><span class="line">touch src/<span class="variable">$(SYNTH_TOP)</span>.v</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">mkdir batch_sim</span><br><span class="line">cd batch_sim &amp;&amp; xvlog --work mylib ../src/*.v</span><br><span class="line">cd batch_sim &amp;&amp; xelab --debug typical -s simTest mylib.<span class="variable">$(SIM_TOP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首次仿真（Batch Mode）</span></span><br><span class="line"><span class="section">first:</span></span><br><span class="line">cd batch_sim &amp;&amp; xsim simTest -gui -wdb wave_data.wdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#仿真（带波形配置）</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">cd batch_sim &amp;&amp; xsim simTest -gui -wdb wave_data.wdb -view ../wave_config.wcfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#清空输出</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -r batch_sim vvd_prj</span><br><span class="line"></span><br><span class="line"><span class="comment">#调试（Project Mode）</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">mkdir vvd_prj</span><br><span class="line">cd ./vvd_prj &amp;&amp; vivado -mode tcl -source ../run_sim.tcl -tclargs <span class="variable">$(SIM_TOP)</span> <span class="variable">$(SYNTH_TOP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动Vivado工程</span></span><br><span class="line"><span class="section">launch:</span></span><br><span class="line">cd ./vvd_prj &amp;&amp; vivado debug_prj.xpr</span><br><span class="line"></span><br><span class="line"><span class="comment">#另存工作空间</span></span><br><span class="line"><span class="section">new_prj:</span></span><br><span class="line">mkdir ../demoT_<span class="variable">$(INDEX)</span></span><br><span class="line">cp -r src ../demoT_<span class="variable">$(INDEX)</span></span><br><span class="line">cp Makefile run_sim.tcl ../demoT_<span class="variable">$(INDEX)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#推送坚果云</span></span><br><span class="line"><span class="section">push_Nut:</span></span><br><span class="line">mkdir <span class="variable">$(Nut_Path)</span>/<span class="variable">$(Cur_Dir)</span></span><br><span class="line">cp -r src <span class="variable">$(Nut_Path)</span>/<span class="variable">$(Cur_Dir)</span></span><br><span class="line">cp Makefile run_sim.tcl <span class="variable">$(Nut_Path)</span>/<span class="variable">$(Cur_Dir)</span></span><br></pre></td></tr></table></figure><p>Tcl脚本</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> sim_top [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">0</span>]</span><br><span class="line"><span class="keyword">set</span> synth_top [<span class="keyword">lindex</span> <span class="variable">$argv</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">create_project debug_prj</span><br><span class="line"></span><br><span class="line">add_files -fileset sources_1 -norecurse [<span class="keyword">glob</span> ../src/*.v]</span><br><span class="line"></span><br><span class="line">set_property top <span class="variable">$synth_top</span> [current_fileset]</span><br><span class="line">update_compile_order -fileset [current_fileset]</span><br><span class="line"></span><br><span class="line">set_property top <span class="variable">$sim_top</span> [get_filesets sim_1]</span><br><span class="line">update_compile_order -fileset sim_1</span><br><span class="line"></span><br><span class="line">set_property -name &#123;xsim.simulate.runtime&#125; -value &#123;<span class="number">30</span>ns&#125; -objects [get_filesets sim_1]</span><br><span class="line">launch_simulation -mode behavioral</span><br><span class="line">start_gui</span><br></pre></td></tr></table></figure><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢舍友老王的倾力支持</p>]]></content>
    
    
    <summary type="html">Ubuntu开发环境打造</summary>
    
    
    
    <category term="Misc" scheme="http://david-luge.cn/categories/Misc/"/>
    
    <category term="Ubuntu" scheme="http://david-luge.cn/categories/Misc/Ubuntu/"/>
    
    
    <category term="Ubuntu" scheme="http://david-luge.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>我的实习小结</title>
    <link href="http://david-luge.cn/2022/09/12/Interview/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>http://david-luge.cn/2022/09/12/Interview/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/</id>
    <published>2022-09-12T11:54:39.000Z</published>
    <updated>2022-09-12T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的实习小结"><a href="#我的实习小结" class="headerlink" title="我的实习小结"></a>我的实习小结</h1><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>字节跳动开始的比较早，在2月中旬的时候开放投递。我是2月20日晚投递简历，2月21日<u>简历挂</u>，反馈很快。跟内推的字节师兄交流后发现，是我投递的上海部门那边不缺人，所以直接简历挂。然后师兄帮我转日常实习，base北京，算是被捞了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b74ce162cb73e504052ff197613ce9c2.png" alt="图5.png"></p><p>重新简历评估后，2月23日约我，3.1一面，3.8二面，3.17三面，3.28hr面，3.30offer call。</p><h3 id="一面技术面（3-1）"><a href="#一面技术面（3-1）" class="headerlink" title="一面技术面（3.1）"></a>一面技术面（3.1）</h3><p>1、面试官一上来给我简要介绍了面试的流程，自我介绍5-10min左右，剩下的话是基础知识考核+撕题。（有点慌，没有问一点项目，可能是项目不对口）</p><p>2、第一题是简要介绍一下功耗的定义，有哪些降功耗的方式？</p><p>3、第二题是两个Reg之间经典的时序分析，逐步加入skew、jitter等因素，写出建立时间和保持时间的计算公式，询问time borrow的概念；</p><p>4、撕一道DDS的题。<br>$$<br>y&#x3D;sin(\frac{\pi}{128}*x)+x<br>$$<br>x的范围是[0,255]；</p><p>1）y的范围，定点数，16位宽的话小数点的位置；2）实现思路；3）RTL code；</p><p>最后一题撕的时间有点长，最后也没完整撕出来，不过思路大致给面试官说明白了。整个一面大约用时1h左右。</p><h3 id="二面技术面（3-8）"><a href="#二面技术面（3-8）" class="headerlink" title="二面技术面（3.8）"></a>二面技术面（3.8）</h3><p>1、自我介绍，从本科到硕士的项目和科研经历；</p><p>2、项目中跨时钟域部分的处理；</p><p>3、异步FIFO中binary转gray的原因；</p><p>4、multicycle和max delay的区别；</p><p>5、单bit信号要跨时钟域并进行取反操作，问反相器放置的位置；</p><p>6、异步复位、同步复位的优缺点；</p><p>7、异步复位同步释放的做法；</p><p>8、对芯片工艺和频率的一些讨论；面试官认为40nm工艺可以跑更高的时钟频率；</p><p>9、简单介绍一下AXI协议，协议转换如何做；</p><p>10、介绍一下AXI中的outstanding功能；</p><p>11、源同步输出的时序约束；</p><p>12、问一下项目的代码量；</p><p>13、最后撕一道题，在一段数据序列中找最大次大值；</p><h3 id="三面技术面（3-17）"><a href="#三面技术面（3-17）" class="headerlink" title="三面技术面（3.17）"></a>三面技术面（3.17）</h3><p>面试官在美国，约了早8点的面试，年龄比较大，面试官很和蔼，有什么不明白的地方也会循循善诱，引导你讲出来，面试体验很好。首先寒暄了一下，没有让自我介绍，问了一下实习时间，实习地点，询问一下职业规划。最后评价说书本知识掌握的不错，但还不够深究，希望以后在实习中继续加深理解。整体流程大概25min</p><p>1、SRAM、DRAM的区别；</p><p>2、DRAM为什么需要动态刷新？</p><p>3、介绍一下功耗；</p><p>4、以DRAM为例解释一下静态功耗；</p><p>5、方波怎么得到正弦波？</p><p>6、时钟经过一段路径会失真吗？为什么？</p><p>7、二分频电路；</p><p>8、环路振荡器；</p><p>9、了解Power Domain吗？</p><h3 id="四面HR面（3-28）"><a href="#四面HR面（3-28）" class="headerlink" title="四面HR面（3.28）"></a>四面HR面（3.28）</h3><p>1、对实习地点是否有要求？是否有倾向性？</p><p>2、秋招还会考虑其他公司吗？</p><p>3、别人对你的评价？有哪些事例证明？</p><p>4、确认实习时间；</p><p>5、工作内容，方向确认；</p><h2 id="乐鑫科技"><a href="#乐鑫科技" class="headerlink" title="乐鑫科技"></a>乐鑫科技</h2><p>乐鑫科技的领跑者计划在21年12月就开始了，然后网上说去年的面试体验不是很好，<strong>自己亲身体验了一下发现面试体验非常非常好</strong>，非常推荐各位同学投递。2.28简历投递，3.1通知笔试，3.7完成笔试，3.14一面技术面，3.21二面HR面，3.24offer call。</p><h3 id="一面技术面（3-14）"><a href="#一面技术面（3-14）" class="headerlink" title="一面技术面（3.14）"></a>一面技术面（3.14）</h3><p>乐鑫面试的风格与字节完全不同，紧紧围绕项目，主要询问TW二号项目，大部分是我讲面试官听，问的问题也是项目强相关，这里主要记录一下面试官的关注的点；</p><p>1、系统最大吞吐率，工作模式有哪些；</p><p>2、组帧、组包的必要性；</p><p>3、接口信号的介绍；</p><p>4、跨时钟域的方式；</p><p>5、FIFO深度的设计，是否有流控机制。</p><p>6、FIFO会溢出吗？如果不会是如何保证的？如果会的话如何应对？</p><p>7、航空航天领域如何抗单粒子翻转？</p><p>8、ASIC项目是如何验证的？</p><p>9、自己会做一些综合看面积吗？面积有要求吗？</p><p>10、简要介绍一下低功耗的方法，自己在ASIC项目中用到了哪些低功耗方式？</p><p>11、设计ASIC时有没有考虑插门控时钟，门控时钟有哪几种方式？</p><h3 id="二面HR面（3-21）"><a href="#二面HR面（3-21）" class="headerlink" title="二面HR面（3.21）"></a>二面HR面（3.21）</h3><p>乐鑫的HR看着比较年轻，比我们大不了几岁，上来寒暄了一会。</p><p>1、简单的自我介绍；</p><p>2、询问学习教育经历；</p><p>3、你觉得数字IC设计的最重要的三点能力，你哪点比较擅长，哪点比较不足？</p><p>4、为什么选择数字IC？是父母做的决定吗？</p><p>5、你想象中二十年后的你是什么样的角色？</p><p>6、参与那么多竞赛有什么收获？</p><p>7、现在有明确的职业规划吗？</p><p>反问：</p><p>1、后续的面试流程；（如果切换base的话会加主管面）</p><p>2、去年网上乐鑫的面试过程评价不高，今年的面试体验很好，公司是否做了相应调整，及时倾听应届生反馈？</p><p><strong>乐鑫今年的面试体验巨巨巨巨巨好</strong>，我字节的HR面在乐鑫Offer的截止日期之前，在与HR说明情况后HR能帮忙延迟一下签Offer的时间。最后没有签HR也会打电话跟你确认，还给秋招直通终面的机会，总之<strong>体验非常不错，墙裂推荐！！！</strong></p><hr><p>4.7日更新一波阿平面经</p><h2 id="平头哥"><a href="#平头哥" class="headerlink" title="平头哥"></a>平头哥</h2><h3 id="一面技术面（3-30）"><a href="#一面技术面（3-30）" class="headerlink" title="一面技术面（3.30）"></a>一面技术面（3.30）</h3><p>我觉得平头哥的面试官比较在意的是你项目中的亮点，这是我面试中收获比较大的一点。项目不要上来就深入细节，面试官应该也不是很care，<strong>上来把项目框架介绍完之后直接给面试官介绍亮点即可</strong>，面试官也可以通过你总结的亮点大概摸清你的技术深度这样。</p><p>问题主要是紧紧围绕项目展开的，大家仅做参考即可，八股比较少：</p><p>1、ASIC与FPGA功能划分的依据；</p><p>2、ASIC的验证是怎么做的？</p><p>3、关注TW2项目中的数据反压，时钟复位信号的生成；</p><p>4、项目中FIFO深度的设置依据；</p><p>5、跨复位域的一些问题，复位的释放顺序等；</p><p>6、Verilog的四值逻辑，仿真中使用什么语法可以使X态进行传播；</p><h3 id="二面技术面（4-7）"><a href="#二面技术面（4-7）" class="headerlink" title="二面技术面（4.7）"></a>二面技术面（4.7）</h3><p>二面被安排在上午9点，面试官应该在海外，然后整体交流过程中夹带英文比较多，有的时候我可能听不太懂。我面的组是做GPGPU的，整体流程与上面类似，问题也与上面类似，主要记录一下问的不同的点：</p><p>1、时钟级联的难点及必要性；</p><p>2、源同步输入&#x2F;输出的时序约束，实现方法；如何保证时钟与数据的偏移关系？</p><p>3、ASIC与FPGA功能的划分原因？ASIC的验证方式是什么？</p><p>4、设计可靠性是如何保障的？</p><p>5、数据反压是如何做的？</p><p>反问：公司内部对HLS工具是什么看法？答：使用起来很保守，Debug不便，或许过几年成熟了才会大规模使用；</p><h2 id="其他公司"><a href="#其他公司" class="headerlink" title="其他公司"></a>其他公司</h2><p>奕斯伟我是2.20申请，直到3.28那边才有工作人员打电话跟我确认时间，那边要求实习时间6个月，保证之后安排面试，这个实习时间我是达不到要求的，于是拒之；</p><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2><p>今年实习开始的早，结束的也早，后续应该不会再投递其他公司的实习了，没有集邮的兴趣，秋招再说。</p>]]></content>
    
    
    <summary type="html">关于我的实习小结</summary>
    
    
    
    <category term="interview" scheme="http://david-luge.cn/categories/interview/"/>
    
    
    <category term="interview" scheme="http://david-luge.cn/tags/interview/"/>
    
  </entry>
  
</feed>
