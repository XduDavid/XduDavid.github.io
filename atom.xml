<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大卫的博客园</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="http://david-luge.cn/atom.xml" rel="self"/>
  
  <link href="http://david-luge.cn/"/>
  <updated>2025-03-24T11:15:39.000Z</updated>
  <id>http://david-luge.cn/</id>
  
  <author>
    <name>DavidGu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>局域网 Git 搭建</title>
    <link href="http://david-luge.cn/2025/03/24/Misc/%E5%B1%80%E5%9F%9F%E7%BD%91Git%E6%90%AD%E5%BB%BA/"/>
    <id>http://david-luge.cn/2025/03/24/Misc/%E5%B1%80%E5%9F%9F%E7%BD%91Git%E6%90%AD%E5%BB%BA/</id>
    <published>2025-03-24T11:15:39.000Z</published>
    <updated>2025-03-24T11:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="局域网-Git-搭建"><a href="#局域网-Git-搭建" class="headerlink" title="局域网 Git 搭建"></a>局域网 Git 搭建</h1><h2 id="共享文件夹配置-Git-服务器"><a href="#共享文件夹配置-Git-服务器" class="headerlink" title="共享文件夹配置 Git 服务器"></a>共享文件夹配置 Git 服务器</h2><p>本文说明在局域网中用一台电脑作为服务器，在服务器中创建一个文件夹，并设置共享。然后该文件夹作为公开的版本库，局域网内其他电脑都可以访问，这样可以实现统一的版本管理。</p><h2 id="配置公开版本库"><a href="#配置公开版本库" class="headerlink" title="配置公开版本库"></a>配置公开版本库</h2><p>首先选取一个数据盘，在数据盘中建立一个文件夹，本例中的名称就是 git。</p><ul><li>在 git 目录下新建一个裸仓库名字为 rx_script,命令如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare rx_script</span><br></pre></td></tr></table></figure><blockquote><p><code>git init --bare</code> 是 Git 里的一个常用命令，其作用是创建一个裸仓库。<br><strong>命令解析</strong><br><code>git init</code> 用于初始化一个新的 Git 仓库。而 <code>--bare</code> 是 <code>git init</code> 的一个参数，添加这个参数后，创建的仓库就不会包含工作目录，只包含 Git 版本控制所需的元数据文件，如 <code>objects</code>（存储对象数据）、<code>refs</code>（存储引用信息）、<code>HEAD</code>（指向当前分支）等。<br><strong>主要作用</strong></p><ul><li><strong>作为共享仓库</strong>：在团队协作开发中，通常需要一个中央仓库来存储项目的代码，让团队成员能够共享代码。由于裸仓库没有工作目录，避免了工作目录可能带来的文件冲突、本地修改等问题，所以非常适合作为共享仓库。成员们可以将自己本地仓库的代码推送到这个裸仓库，也能从这里拉取其他成员的更新。</li><li><strong>服务器端部署</strong>：在服务器上部署 Git 仓库时，一般会使用裸仓库。服务器的主要功能是存储和管理代码，并不需要实际的工作目录。使用裸仓库可以减少服务器的资源占用，提高性能。</li><li><strong>版本控制与备份</strong>：裸仓库保存了项目的完整版本历史记录，可用于对项目进行版本控制和备份。即使本地仓库出现问题，也能从裸仓库恢复到任意一个历史版本。</li></ul></blockquote><p>rx_script 目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/LMWPbBh5goked9xJlaJcvV6Lnpg.png" alt="LMWPbBh5goked9xJlaJcvV6Lnpg"></p><ul><li>设置 git 文件夹为共享文件夹</li></ul><p>右键 git 文件夹，属性：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/WtwBbu2uroip2LxIOYLciZ3dneh.png" alt="WtwBbu2uroip2LxIOYLciZ3dneh"></p><ul><li>用户设置为 everyone，并进行共享</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/GT3Fb5PNYonC8vxVseTcOvX9nBf.png" alt="GT3Fb5PNYonC8vxVseTcOvX9nBf"></p><ul><li>此时文件夹属性中就有一个网络路径：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/TW3fbKXh2oCfuHxeW0ncZ3nYnSg.png" alt="TW3fbKXh2oCfuHxeW0ncZ3nYnSg"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li>在客户端，右键我的电脑-&gt; 映射网络驱动器：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/LDKKbn8h5opAFyxrSx7cviNPnAd.png" alt="LDKKbn8h5opAFyxrSx7cviNPnAd"></p><ul><li>此时会发现电脑下多了个 Y 盘。Y 盘就是公开文件夹：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/MDzpbsImToKDg1xd7ATcM03rnpj.png" alt="MDzpbsImToKDg1xd7ATcM03rnpj"></p><p>git 就是公开版本库</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在各自需要同步的电脑上，创建本地版本库，并于远端进行关联即可。</p><p>比如我要在”D:\proj\scrpit”路径下去关联版本库，仅需：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin Y:\\rx_script</span><br></pre></td></tr></table></figure><p>后续完成”git add”，”git commit”，“git push”等操作后即完成了对仓库的初始化。</p><blockquote><p>考虑到仓库大小，最好第一次上库的时候就添加.gitignore 文件，避免跟踪过多不必要的文件。</p></blockquote><p>在仓库第一次初始化完后，后续接入的电脑仅需：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin Y:\\rx_script</span><br><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>即可完成仓库的同步。</p>]]></content>
    
    
    <summary type="html">对局域网Git搭建的流程做了整理，方便以后快速查阅</summary>
    
    
    
    <category term="Misc" scheme="http://david-luge.cn/categories/Misc/"/>
    
    <category term="Git" scheme="http://david-luge.cn/categories/Misc/Git/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>线性代数05-转置矩阵与向量空间</title>
    <link href="http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-5/"/>
    <id>http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-5/</id>
    <published>2025-03-16T07:14:39.000Z</published>
    <updated>2025-03-16T07:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra-转置矩阵与向量空间-05"><a href="#Linear-Algebra-转置矩阵与向量空间-05" class="headerlink" title="Linear Algebra-转置矩阵与向量空间-05"></a>Linear Algebra-转置矩阵与向量空间-05</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本节我们再谈置换矩阵与转置矩阵，并介绍对称矩阵，之后便进入学习线代的关键所在：向量空间与子空间。</p><h2 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>所谓的置换矩阵 P，就是用来完成行交换的矩阵，更具体地说，是行重新排列了的单位矩阵。例如 I 就是一个置换矩阵，只不过 I 对矩阵没影响。</p><p>那么对于 n 阶矩阵来说，有多少个置换矩阵呢？答案是：n!种，也就是将单位矩阵 I 各行重新排列后所有可能的情况的数量。</p><p>置换矩阵的另一个优点就是可逆，因为置换矩阵各行还原后可以得到单位矩阵。而且对于置换矩阵 P，有<script type="math/tex">PP^T=I</script>，也就是<script type="math/tex">P^{-1}=P^{T}</script>。</p><p>这个性质其实很好理解，首先明确，P 是置换矩阵，因此 P 的每个列向量中只有一个分量是 1，其余分量均是 0。而既然要求<script type="math/tex">PP^{-1}=I</script>，那就<strong>说明</strong><script type="math/tex">P</script><strong>中每一行的行向量与</strong><script type="math/tex">P^{-1}</script><strong>中每一列的列向量的数量积为 1，也就意味着</strong><script type="math/tex">P</script><strong>中每一行与</strong><script type="math/tex">P^{-1}</script><strong>中每一列中分量 1 出现的位置相同</strong>，也就是<script type="math/tex">P</script>与<script type="math/tex">P^{-1}</script>沿对角线对称，所以<script type="math/tex">P^{-1}=P^{T}</script>。</p><h3 id="置换矩阵的使用"><a href="#置换矩阵的使用" class="headerlink" title="置换矩阵的使用"></a>置换矩阵的使用</h3><p>在讲消元法的时候，主元位置为 0 是一件很让人头疼的事，这时就需要置换矩阵 P 来完成行交换，确保消元过程顺利进行。上节学习<script type="math/tex">A=LU</script>分解时，我们没有考虑要交换行的过程，如果我们想写出更普适的 LU 分解式的话，必须把行交换情况考虑进去，即：<script type="math/tex">PA=LU</script>，先用行交换使得主元位置不为 0，行顺序正确，其后再使用 LU 分解。</p><h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h2><h3 id="转置矩阵回顾"><a href="#转置矩阵回顾" class="headerlink" title="转置矩阵回顾"></a>转置矩阵回顾</h3><p>之前简单介绍过转置矩阵，即：</p><script type="math/tex; mode=display">A=\begin{bmatrix}1 & 3\\2 & 3\\4 & 1\\\end{bmatrix},A^T=\begin{bmatrix}1 & 2 & 4\\3 & 3 & 1\\\end{bmatrix}</script><p>用符号来表示就是对<script type="math/tex">A</script>矩阵以及<script type="math/tex">A^T</script>矩阵中每一个元素，都有：</p><script type="math/tex; mode=display">(A^T)_{ij}=A_{ji}</script><p>也就是说，转置矩阵中，行元素与列元素交换了，理解转置很简单。</p><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>对称矩阵，顾名思义，就是主对角线两侧元素对应相等的矩阵。或者说，对于矩阵 A，如果有<script type="math/tex">A=A^T</script>，那么矩阵 A 就是一个对称矩阵，如 <script type="math/tex">\begin{bmatrix}3 & 1 & 7\\1 & 2 & 9\\7 & 9 & 4\\\end{bmatrix}</script>。</p><p>那么我们如何获取到对称矩阵呢？很简单，矩阵<script type="math/tex">A</script>与<script type="math/tex">A^T</script>相乘得到的方阵一定是对称矩阵，因为我们从对称矩阵的定义来看，取<script type="math/tex">(A^TA)^T</script>，根据转置的运算规律，可知<script type="math/tex">(AB)^T=B^TA^T</script>，所以有：</p><script type="math/tex; mode=display">(A^TA)^T=A^TA^{TT}=A^TA</script><p>所以任何的<script type="math/tex">A^TA</script>，转置仍然是其本身，故称为对称矩阵。</p><h2 id="向量空间与子空间"><a href="#向量空间与子空间" class="headerlink" title="向量空间与子空间"></a>向量空间与子空间</h2><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>首先明确“向量空间”的概念，它表示一整个空间的向量，但是要注意，不是任意向量的集合都能被称为向量空间。所谓的向量空间，必须满足一定规则，就是：<strong>该空间对线性运算(相加，数乘)封闭</strong>。类似：v-&gt;3v 或者 v, w-&gt; v+w 运算，若得到的 3v 或者 v+w 都仍然在此空间中，则这个空间可称为向量空间。</p><p>举个例子，<script type="math/tex">R^2</script>就是一个向量空间，其中的向量均为二维实向量。在<script type="math/tex">R^2</script>上就存在线性组合，我们举例说明：</p><p><script type="math/tex">\begin{bmatrix}3\\2\\\end{bmatrix},\begin{bmatrix}0\\0\\\end{bmatrix},\begin{bmatrix}\pi\\e\\\end{bmatrix}</script>均在<script type="math/tex">R^2</script>的实数二维向量空间中，对它们做线性运算，得到的结果仍然在<script type="math/tex">R^2</script> 空间中。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix0.png" alt="transport_matrix0"></p><p>显然，<script type="math/tex">R^2</script>的向量空间可以构成一个平面，即是图上的 xoy 平面。这个向量空间存在的关键在于上图中平面上任何向量都在<script type="math/tex">R^2</script>向量空间中，尤其是<strong>零向量</strong>。因为线性运算是“数乘”“相加”，任何向量乘上 0 或者加上其反向向量后得到的都是零向量，所以它必然存在于所有向量空间中，这一点十分重要。</p><p>同样，推广到<script type="math/tex">R^3</script>空间，<script type="math/tex">R^3</script>中是三维的向量，每个分量均为实数，例如 <script type="math/tex">\begin{bmatrix}3\\2\\0\\\end{bmatrix}</script>，这样的向量就在<script type="math/tex">R^3</script> 空间中。</p><p>再进行推广，<script type="math/tex">R^n</script>空间中包括所有的 n 维向量，每个列向量有 n 个分量，且分量均为实数。</p><p>再举一个不是向量空间的例子：</p><p>还是<script type="math/tex">R^2</script>空间中，但是这次我们只取第一象限内的区域 D：</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix1.png" alt="transport_matrix1"></p><p>显然，这部分空间无法满足“线性组合仍在空间中”的要求，比如数乘运算时，随便取个负数，向量就会跑到第三象限去，脱离 D 空间范围内了。</p><h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><p>上面的反例已经证明，在向量空间里随便取其一部分，很可能得到的不是向量空间。那如果我们取向量空间的一部分，构成的有没有可能是向量空间呢？ 答案是有的，这样还能构成向量空间的部分我们称之为子空间，还是以<script type="math/tex">R^2</script>为例：</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix2.png" alt="transport_matrix2"></p><p>如图，整个坐标平面表示的就是原向量空间<script type="math/tex">R^2</script>，而这条<strong>穿过原点的直线</strong>就是<script type="math/tex">R^2</script>的子空间之一。检验一下这条直线上的任意向量，他们的“数乘”，“相加”运算结果全部仍在这条直线上，这就构成了一个子空间。而如果这条直线不过原点，那么零向量都不在这个空间中，就更别谈什么子空间了。</p><p>那<script type="math/tex">R^2</script>空间中，还有没有其他的子空间呢？既然我们这么强调零向量，那就让它单独成一个空间就好了。记为 Z，其中之后一个零向量，它也是<script type="math/tex">R^2</script>的子空间之一。</p><p>再稍微推广一下，<script type="math/tex">R^3</script>的子空间就是如下三个：</p><ol><li>穿过原点的平面；</li><li>穿过原点的直线；</li><li>Z，原点；</li></ol><h3 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h3><p>上面介绍的子空间都是基于已知的图像来寻找的，接下来我们<strong>通过具体的矩阵来构造一个子空间</strong>，比如：列向量构造出的列空间。</p><p>我们以 <script type="math/tex">A=\begin{bmatrix}1 & 3\\2 & 3\\4 & 1\\\end{bmatrix}</script>为例。首先能看出来，各列向量<script type="math/tex">\begin{bmatrix}1\\2\\4\\\end{bmatrix},\begin{bmatrix}3\\3\\1\\\end{bmatrix}</script>均属于<script type="math/tex">R^3</script>，而且由这两个向量张开的子空间必须满足“线性运算封闭”这一性质。也就是说<script type="math/tex">\begin{bmatrix}1\\2\\4\\\end{bmatrix},\begin{bmatrix}3\\3\\1\\\end{bmatrix}</script>以及它们的线性组合构成了一个<script type="math/tex">R^3</script> 的子空间，我们称之为：列空间，记为 C(A)。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix3.png" alt="transport_matrix3"></p><p>因为 <script type="math/tex">\begin{bmatrix}1\\2\\4\\\end{bmatrix},\begin{bmatrix}3\\3\\1\\\end{bmatrix}</script> 不在同一条直线上，所以，这个列空间表现在图像上，就是<strong>一个过原点与这两个列向量的平面</strong>。</p><p>两个向量 <script type="math/tex">\begin{bmatrix}1\\2\\4\\\end{bmatrix},\begin{bmatrix}3\\3\\1\\\end{bmatrix}</script>以及它们的所有线性组合都在这个二维平面上，构成一个空间。这里需要我们好好理解，用教授的话说“<script type="math/tex">R^3</script>情况下还可以作图，但是更高维的类似于<script type="math/tex">R^{10}</script>情况你要怎么办？譬如求<script type="math/tex">R^{10}</script> 空间中 5 个向量线性组合是什么样的？如果不共线，我们就可以类似地理解为一个十维空间中的五维平面之类的东西。”</p><p>这里还要注意列向量之间的性质，如果列向量之间就是共线的，那么其列空间就是一条过原点的直线。</p><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>这节介绍了向量空间和子空间，并由子空间引出了通过具体的列向量构成的空间—列空间。如何理解空间的概念非常重要，本节中对低维的空间做了图，目的是便于我们理解“空间”这一概念。</p>]]></content>
    
    
    <summary type="html">转置矩阵与向量空间</summary>
    
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/categories/Linear-Algebra/"/>
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>芯片的工艺角</title>
    <link href="http://david-luge.cn/2025/03/16/IC/Basic/%E8%8A%AF%E7%89%87%E7%9A%84%E5%B7%A5%E8%89%BA%E8%A7%92/"/>
    <id>http://david-luge.cn/2025/03/16/IC/Basic/%E8%8A%AF%E7%89%87%E7%9A%84%E5%B7%A5%E8%89%BA%E8%A7%92/</id>
    <published>2025-03-16T03:34:39.000Z</published>
    <updated>2025-03-16T03:34:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="芯片的工艺角"><a href="#芯片的工艺角" class="headerlink" title="芯片的工艺角"></a>芯片的工艺角</h1><h2 id="芯片领域中的工艺角：概念与原理"><a href="#芯片领域中的工艺角：概念与原理" class="headerlink" title="芯片领域中的工艺角：概念与原理"></a><strong>芯片领域中的工艺角：概念与原理</strong></h2><p>在芯片设计中，“工艺角”（Process Corner）通常指的是制造过程中由于工艺参数的离散性（例如阈值电压、栅极氧化层厚度、掺杂浓度等）而造成的晶体管性能差异。<strong>不同的工艺角会导致芯片在速度、功耗等方面出现差异</strong>。为了保证芯片在各种可能的制造偏差条件下都能正常工作，设计工程师会在仿真阶段对不同工艺角进行分析和验证。</p><h3 id="1-什么是工艺角？"><a href="#1-什么是工艺角？" class="headerlink" title="1. 什么是工艺角？"></a><strong>1. 什么是工艺角？</strong></h3><p>工艺角（Process Corner）可以理解为在晶圆制造工艺允许的范围内，器件性能的最坏或最好情况的组合。通常用几个关键词来描述：</p><ul><li><strong>SS（Slow-Slow）</strong>：NMOS 和 PMOS 都是“最慢”工艺角。</li><li><strong>FF（Fast-Fast）</strong>：NMOS 和 PMOS 都是“最快”工艺角。</li><li><strong>TT（Typical-Typical）</strong>：NMOS 和 PMOS 都是“典型”工艺角。</li><li><strong>SF（Slow-Fast）</strong>：NMOS 慢、PMOS 快。</li><li><strong>FS（Fast-Slow）</strong>：NMOS 快、PMOS 慢。</li></ul><p>这里的“慢”和“快”并不是指实际的时钟速度，而是<strong>指器件的特性</strong>：阈值电压较高时，器件会偏慢；阈值电压较低时，器件会偏快。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/NXz3bLJ0IoffE9xsET2cQNhln1e.png" alt="NXz3bLJ0IoffE9xsET2cQNhln1e"></p><h3 id="2-为什么要考虑工艺角？"><a href="#2-为什么要考虑工艺角？" class="headerlink" title="2. 为什么要考虑工艺角？"></a><strong>2. 为什么要考虑工艺角？</strong></h3><p>半导体制造过程中不可避免地会有一定的工艺波动（Process Variation）。如果只针对“典型”工艺角进行设计和验证，那么在实际制造时可能会遇到比典型情况更差或更好的器件性能，从而造成电路无法正常工作、功耗或速度不达标等问题。</p><ul><li><strong>在慢角（SS）下</strong>：器件速度变慢，电路延迟增加；同时器件阈值电压通常更高，漏电流更小，静态功耗会有所降低，但动态功耗也会因为速度减慢而有不同表现。</li><li><strong>在快角（FF）下</strong>：器件速度加快，电路延迟降低；但阈值电压通常更低，漏电流更大，可能导致静态功耗上升。</li></ul><p>因此，设计工程师需要在快角、慢角等极端情况下进行时序和功耗分析，以确保芯片在这些最坏或最好条件下依然能够正常工作。</p><hr><h2 id="其他影响芯片性能的因素：电压与温度"><a href="#其他影响芯片性能的因素：电压与温度" class="headerlink" title="其他影响芯片性能的因素：电压与温度"></a><strong>其他影响芯片性能的因素：电压与温度</strong></h2><p>除了工艺本身的差异外，芯片在不同电压和温度下的性能也会发生变化。为了全面反映芯片的工作范围，工程师通常会考虑<strong>PVT（Process、Voltage、Temperature）三个因素的组合，也称为PVT Corners</strong>。</p><ul><li><strong>电压（Voltage）</strong>：工作电压的上限和下限会影响晶体管的驱动能力和漏电流。</li><li><strong>温度（Temperature）</strong>：高温会增加漏电流、减小迁移率，导致器件速度下降；低温则可能使器件速度上升。</li></ul><p>因此，芯片设计通常要在最坏和最好的电压、温度条件下进行时序和功耗分析，确保芯片能够在整个 PVT 范围内可靠工作。</p><hr><h2 id="工艺角可能造成的影响"><a href="#工艺角可能造成的影响" class="headerlink" title="工艺角可能造成的影响"></a><strong>工艺角可能造成的影响</strong></h2><h3 id="对-PIN-信号的影响"><a href="#对-PIN-信号的影响" class="headerlink" title="对 PIN 信号的影响"></a><strong>对 PIN 信号的影响</strong></h3><p>不同工艺角会影响 <strong>信号完整性、时序、功耗和驱动能力</strong>，对 <strong>输入（Input）</strong> 和 <strong>输出（Output）</strong> PIN 均有影响。</p><h4 id="1-数字信号-PIN"><a href="#1-数字信号-PIN" class="headerlink" title="(1) 数字信号 PIN"></a><strong>(1) 数字信号 PIN</strong></h4><p><strong>影响因素：</strong></p><ul><li><p><strong>传播延迟（Propagation Delay）</strong></p><ul><li><strong>FF 工艺角</strong>：MOSFET 开关速度快，延迟最短，可能导致时序收敛困难，甚至产生 <strong>赛道竞争（Race Condition）</strong> 问题。</li><li><strong>SS 工艺角</strong>：MOSFET 速度慢，延迟最长，可能导致 Setup 时间（Tsetup）或 Hold 时间（Thold）违例，影响时序可靠性。</li></ul></li><li><p><strong>上升/下降时间（Rise/Fall Time）</strong></p><ul><li>FF 工艺角时，边沿更陡，可能导致高频噪声更强。</li><li>SS 工艺角时，边沿变缓，可能影响高速通信接口，如 <strong>DDR、PCIe</strong> 等。</li></ul></li><li><p><strong>电平阈值（Logic Threshold）</strong></p><ul><li>不同工艺角会导致输入信号的<strong>高低电平阈值变化</strong>，影响输入信号的识别可靠性。</li></ul></li></ul><h4 id="2-模拟信号-PIN"><a href="#2-模拟信号-PIN" class="headerlink" title="(2) 模拟信号 PIN"></a><strong>(2) 模拟信号 PIN</strong></h4><p><strong>影响因素：</strong></p><ul><li><p><strong>增益与失真（Gain &amp; Distortion）</strong></p><ul><li>FF 工艺角：MOSFET 的跨导（gm）更大，增益可能变高，但非线性失真也可能增大。</li><li>SS 工艺角：跨导变小，增益可能下降，影响放大器性能。</li></ul></li><li><p><strong>输入偏置电流（Input Bias Current）</strong></p><ul><li>FF 工艺角：漏电流增加，输入偏置电流可能增大，影响高阻抗模拟电路（如 ADC、运放）。</li><li>SS 工艺角：偏置电流较小，但可能增加噪声。</li></ul></li><li><p><strong>带宽和相位裕量</strong></p><ul><li>FF 工艺角：MOSFET 速度快，带宽可能增加，但相位裕量可能降低，导致不稳定。</li><li>SS 工艺角：带宽下降，信号可能变得更慢，影响 ADC 采样率。</li></ul></li></ul><hr><h3 id="对干扰（EMI-噪声）的影响"><a href="#对干扰（EMI-噪声）的影响" class="headerlink" title="对干扰（EMI/噪声）的影响"></a><strong>对干扰（EMI/噪声）的影响</strong></h3><p>工艺角会影响 <strong>电磁干扰（EMI）、串扰（Crosstalk）和电源噪声（Power Noise）</strong>，进而影响 PIN 信号的稳定性。</p><h4 id="1-电磁干扰（EMI）"><a href="#1-电磁干扰（EMI）" class="headerlink" title="(1) 电磁干扰（EMI）"></a><strong>(1) 电磁干扰（EMI）</strong></h4><ul><li><p><strong>FF 工艺角</strong>：</p><ul><li>MOSFET 速度快，信号切换更陡峭，高频分量更强，容易产生更强的 EMI。</li><li>需要额外考虑 <strong>PCB 走线屏蔽、地弹噪声（Ground Bounce）</strong> 及 <strong>去耦电容（Decoupling Cap）</strong> 的优化。</li></ul></li><li><p><strong>SS 工艺角</strong>：</p><ul><li>由于信号上升/下降时间变慢，EMI 相对较弱，但会导致信号质量下降，如<strong>眼图（Eye Diagram）收缩</strong>。</li></ul></li></ul><h4 id="2-串扰（Crosstalk）"><a href="#2-串扰（Crosstalk）" class="headerlink" title="(2) 串扰（Crosstalk）"></a><strong>(2) 串扰（Crosstalk）</strong></h4><ul><li><p><strong>FF 工艺角</strong>：</p><ul><li>信号上升时间短，高频分量增加，容易导致相邻信号线（特别是高速总线，如 DDR）之间的串扰增强。</li><li>需要增加 <strong>信号屏蔽、差分走线</strong> 或调整 PCB 布局。</li></ul></li><li><p><strong>SS 工艺角</strong>：</p><ul><li>信号传播时间变长，串扰相对较弱，但过慢的信号可能影响数据传输速率。</li></ul></li></ul><h4 id="3-电源噪声（Power-Noise）"><a href="#3-电源噪声（Power-Noise）" class="headerlink" title="(3) 电源噪声（Power Noise）"></a><strong>(3) 电源噪声（Power Noise）</strong></h4><ul><li><p><strong>FF 工艺角</strong>：</p><ul><li>由于开关速度快，电流突变更剧烈，容易引起 <strong>电源纹波（Power Ripple）</strong> 和 <strong>地弹噪声（Ground Bounce）</strong>，导致信号抖动（Jitter）。</li><li>需要优化电源去耦和 LDO/电感的设计。</li></ul></li><li><p><strong>SS 工艺角</strong>：</p><ul><li>电流变化较小，电源噪声较低，但电路性能可能不足，如振荡器频率下降、PLL 锁定时间变长。</li></ul></li></ul><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><div class="table-container"><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">FF 影响</th><th style="text-align:center">SS 影响</th></tr></thead><tbody><tr><td style="text-align:center">高速数字接口（DDR, PCIe, USB）</td><td style="text-align:center">EMI 增加，可能出现信号反射</td><td style="text-align:center">速度变慢，数据吞吐量下降</td></tr><tr><td style="text-align:center">ADC/DAC</td><td style="text-align:center">增益偏移，噪声增大</td><td style="text-align:center">带宽变小，响应速度下降</td></tr><tr><td style="text-align:center">PLL（锁相环）</td><td style="text-align:center">锁定时间缩短，但相位噪声增加</td><td style="text-align:center">锁定时间变长，可能无法正常工作</td></tr><tr><td style="text-align:center">电源管理（LDO, DC-DC）</td><td style="text-align:center">纹波增大，可能需要更大的去耦电容</td><td style="text-align:center">稳压变慢，响应滞后</td></tr></tbody></table></div><hr><h2 id="设计优化策略"><a href="#设计优化策略" class="headerlink" title="设计优化策略"></a><strong>设计优化策略</strong></h2><h3 id="1-数字电路优化"><a href="#1-数字电路优化" class="headerlink" title="(1) 数字电路优化"></a><strong>(1) 数字电路优化</strong></h3><ul><li>采用 <strong>静态时序分析（STA）</strong>，确保在 <strong>SS 工艺角</strong> 仍满足时序要求。</li><li>在 FF 角测试 <strong>EMI</strong>，如果过大，可调整信号上升时间（如插入小电容）。</li><li>适当调整 <strong>驱动强度</strong>，减少串扰影响。</li></ul><h3 id="2-模拟电路优化"><a href="#2-模拟电路优化" class="headerlink" title="(2) 模拟电路优化"></a><strong>(2) 模拟电路优化</strong></h3><ul><li>在 <strong>SS 工艺角</strong> 下确保带宽足够，避免增益衰减影响信号质量。</li><li>在 <strong>FF 工艺角</strong> 下关注功耗和失真，避免 MOSFET 过驱动。</li></ul><h3 id="3-电源优化"><a href="#3-电源优化" class="headerlink" title="(3) 电源优化"></a><strong>(3) 电源优化</strong></h3><ul><li>采用 <strong>更好的去耦电容（如 X7R/X5R 陶瓷电容）</strong>，减少电源噪声。</li><li>在 PLL 设计中，优化 <strong>环路滤波器（Loop Filter）</strong> 以适应不同工艺角。</li><li>适当增加 <strong>电源裕量（Voltage Margining）</strong>，确保不同工艺角下都能稳定工作。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>工艺角（TT、SS、FF）不仅影响芯片的核心逻辑，还会对 <strong>PIN 信号质量、EMI、串扰、电源噪声</strong> 等方面产生显著影响：</p><ul><li><strong>FF 工艺角</strong>：信号快、噪声大、功耗高、串扰强，时序更紧张。</li><li><strong>SS 工艺角</strong>：信号慢、功耗低、噪声小，但可能影响电路性能。</li><li><strong>SF/FS 工艺角</strong>：主要影响模拟电路的 P/N 不匹配问题，如放大器失调。</li></ul><p>在设计时，需要 <strong>PVT（Process-Voltage-Temperature）联合仿真</strong>，并针对不同工艺角进行 <strong>时序分析、信号完整性优化、去耦设计</strong>，确保系统可靠运行。</p><p>在半导体工艺不断缩进（如从 7nm 向 5nm、3nm 演进）的过程中，器件的工艺波动日益显著，对设计的精细化管理也提出了更高要求。只有深入理解并有效应对工艺角的挑战，才能在芯片设计中保证高良率、高性能和低功耗，为最终产品提供可靠的技术支撑。</p>]]></content>
    
    
    <summary type="html">简述芯片的工艺角</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>线性代数04-矩阵LU分解</title>
    <link href="http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-4/"/>
    <id>http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-4/</id>
    <published>2025-03-16T03:14:39.000Z</published>
    <updated>2025-03-16T03:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra-矩阵的-LU-分解-04"><a href="#Linear-Algebra-矩阵的-LU-分解-04" class="headerlink" title="Linear Algebra-矩阵的 LU 分解-04"></a>Linear Algebra-矩阵的 LU 分解-04</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>这一节首先完善之前讲到的逆矩阵内容，然后使用消元矩阵介绍 A 的 LU 分解，即将矩阵 A 分解为矩阵 L 与上三角矩阵 U，介绍这种运算的普遍规律。最后再一次提起之前介绍的“行交换矩阵”，引入置换矩阵的概念。</p><h2 id="逆矩阵性质补充"><a href="#逆矩阵性质补充" class="headerlink" title="逆矩阵性质补充"></a>逆矩阵性质补充</h2><p>首先考虑一个问题：如果 A，B 都是可逆矩阵的话，AB 的逆矩阵是什么呢？这个问题并不复杂，想求出逆矩阵，无非就是令<script type="math/tex">AB\times(AB)^{-1}=I</script>，而我们不难想到<script type="math/tex">ABB^{-1}A^{-1}=I</script>，因此有：</p><script type="math/tex; mode=display">(AB)^{-1}=B^{-1}A^{-1}</script><p>由于下一章中要涉及到矩阵的转置问题，我们在这里一起讨论矩阵转置和矩阵的逆的关系。</p><p>首先介绍一下转置矩阵，转置矩阵就是将原矩阵各行转换为各列所得到的新矩阵，如：</p><script type="math/tex; mode=display">A=\begin{bmatrix}1 & 2\\3 & 4\\4 & 1\end{bmatrix},A^T=\begin{bmatrix}1 & 3 & 4\\2 & 4 & 1\end{bmatrix}</script><p>接下来我们看看转置矩阵和逆矩阵有什么联系。说到逆矩阵，最经典的式子无非就是<script type="math/tex">AA^{-1}=I</script>。为了找到转置矩阵<script type="math/tex">A^T</script>与逆矩阵<script type="math/tex">A^{-1}</script>间的关系，我们对<script type="math/tex">AA^{-1}=I</script>两边同时进行转置运算，得到：</p><script type="math/tex; mode=display">(AA^{-1})^T=(A^{-1})^TA^T=I</script><p>为什么<script type="math/tex">(A^{-1})^T</script>会变换到<script type="math/tex">A^T</script>的前面来呢？我们用非方阵 A 来理解一下这个过程，假设 A 是一个 <script type="math/tex">3\times 4</script>的矩阵，则A的右逆<script type="math/tex">A^{-1}</script>是一个<script type="math/tex">4\times 3</script>的矩阵，二者相乘是一个 <script type="math/tex">3\times 3</script> 的单位矩阵。</p><p>对其求转置，如果<script type="math/tex">A^T</script>在<script type="math/tex">(A^{-1})^T</script>前面，则会得到一个 <script type="math/tex">4\times 4</script> 的单位矩阵，矛盾。</p><p>再次观察此式：<script type="math/tex">(A^{-1})^TA^T=I</script>，由于 A 是方阵，则<script type="math/tex">A^{T}</script>必然也是方阵，那么我们就能得到<script type="math/tex">A^T</script>的逆矩阵，即为<script type="math/tex">(A^{-1})^T</script>，也就是说：<script type="math/tex">(A^T)^{-1}=(A^{-1})^T</script></p><p>这个结果告诉我们：<strong>对于单个矩阵，转置和取逆两个运算顺序可以颠倒。</strong></p><h2 id="矩阵的-LU-分解"><a href="#矩阵的-LU-分解" class="headerlink" title="矩阵的 LU 分解"></a>矩阵的 LU 分解</h2><p>我们熟悉的消元法都是直接使用行变换得来的，而由于消元矩阵的存在，说明用矩阵乘法也可以达到与之一样的消元效果。所以，现在假设有可逆矩阵 A，如果有：<script type="math/tex">A-初等行变换->U(上三角矩阵)</script>，就一定有类似于这样的形式：<script type="math/tex">E\times A=U</script>的等式存在，使 A 相当于进行了初等行变换成为了 U。而我们已经学习了逆矩阵，E 这样的矩阵一定有逆矩阵，因为它本身就是由单位阵变化过来的。所以<script type="math/tex">E\times A=U</script>可以写成<script type="math/tex">A=E^{-1}\times U</script>。这一形式即为<script type="math/tex">A=LU</script>形式，这个过程就是 LU 分解过程。</p><p>那么<strong>矩阵 L(下三角矩阵)</strong>是否有什么特别之处呢？我们可以通过一道例题来探讨下：</p><p>【例】现有<script type="math/tex">E_{32}E_{31}E_{21}A=U</script>，已知 <script type="math/tex">E_{32}=\begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & -5 & 1\\\end{bmatrix}</script>，<script type="math/tex">E_{21}=\begin{bmatrix}1 & 0 & 0\\-2 & 1 & 0\\0 & 0 & 1\\\end{bmatrix}</script>，<script type="math/tex">E_{31}=I</script>，求<script type="math/tex">A=LU</script> 分解后的 L。</p><p>思路：</p><ol><li>逆矩阵化简为<script type="math/tex">A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U</script>；</li><li>后面计算各个矩阵：<script type="math/tex">E_{21}^{-1}=\begin{bmatrix}1 & 0 & 0\\2 & 1 & 0\\0 & 0 & 1\\\end{bmatrix}</script>，<script type="math/tex">E_{32}^{-1}=\begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 5 & 1\\\end{bmatrix}</script></li><li>直接带入计算：<script type="math/tex">L=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}=\begin{bmatrix}1 & 0 & 0\\2 & 1 & 0\\0 & 5 & 1\\\end{bmatrix}</script></li></ol><p>观察发现，L 具有一个非常重要的特点，L 矩阵中各个元素都是<script type="math/tex">E_{21}^{-1}</script>与<script type="math/tex">E_{32}^{-1}</script>中对应位置的元素。</p><p>以上的结论给了我们启示，在使用<script type="math/tex">A=LU</script>分解矩阵的时候，我们只需要从 U 入手，反过来考虑：<strong>看如何通过行变换可以将上三角矩阵 U 变回 A，然后再将单位阵按此形式变化，就得到了 L 矩阵。</strong>这个性质也是<script type="math/tex">A=LU</script>形式分解矩阵的最大优点。</p><h3 id="LU-分解意义"><a href="#LU-分解意义" class="headerlink" title="LU 分解意义"></a>LU 分解意义</h3><p>对于线性方程组 <script type="math/tex">Ax = b</script>，当矩阵 A 可以进行 LU 分解<script type="math/tex">A = LU</script>时，原方程组可转化为 <script type="math/tex">LUx = b</script>。令 <script type="math/tex">Ux = y</script>，则先求解 <script type="math/tex">Ly = b</script>（因为 L 是下三角矩阵，求解相对容易，可通过前代法逐步计算），得到 y；再求解 <script type="math/tex">Ux = y</script>（U 是上三角矩阵，可通过回代法求解），从而得到原方程组的解 x。相比于直接求解 <script type="math/tex">Ax = b</script>，这种方法在计算量上通常更具优势，尤其是对于大型矩阵，可显著减少计算量和计算时间。</p><h3 id="运算量"><a href="#运算量" class="headerlink" title="运算量"></a>运算量</h3><p>以上，我们已经学会了 A=LU 分解矩阵方法，那么现在有一个额外问题，就是消元的运算量问题，比如现在我们有一个 <script type="math/tex">100\times 100</script> 的大矩阵(无 0 元素)。我们需要运算(将一个数乘系数后加到另一数上消元，每一个这样的过程称为一次运算)多少次后，才能将其化为上三角矩阵呢？</p><p>这个问题我们先从列的角度进行考虑，第一列消元运算结束后，矩阵将会变成 <script type="math/tex">\begin{bmatrix}1 & ... & ... & ...\\0 & ... & ... & ...\\... & ... & ... & ...\\0 & ... & ... & ...\\\end{bmatrix}</script>的形式，这一步中，第一列的元素运算了100次，而第一行一共有100个元素，于是仅第一行与第一列的消元结束后，我们就运算了<script type="math/tex">100^2</script>次。之后我们要研究的就变成了剩下的 <script type="math/tex">99\times 99</script>的矩阵。以此类推，最后的运算量为：<script type="math/tex">\sum_{k=1}^{n}k^2</script></p><p>这种写法看上去比较难计算，我们可以根据微积分中学到的知识，加入我们计算的不是离散点之和，而是连续区域上函数的黎曼和的话，我们可以通过积分来计算区域面积值的和。我们可以采用积分来估计和，也就是这样估算：<script type="math/tex">\sum_{k=1}^{n}k^2=\int_{1}^{n}x^2dx</script>。</p><h2 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h2><p>我们之前接触过行变换所用到的矩阵，即是将单位阵 I 按照对应行变换方式进行操作之后得到的矩阵。它可以交换矩阵中的两行，代替矩阵行变换。什么时候我们需要使用矩阵行变换呢？一个经典的例子就是：在消元过程中，当矩阵主元位置上面为 0 时，我们就需要用行变换将主元位置换位非 0 数。</p><p>这样的由单位阵变换而来的矩阵，通过矩阵乘法可以使被乘矩阵行交换。我们将这样的矩阵称为置换矩阵 P。我们通过一个例子来熟悉一下置换矩阵。</p><p>【例】求矩阵 <script type="math/tex">\begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\\\end{bmatrix}</script> 的所有置换矩阵，并判断其性质。</p><p>一共有 6 个置换矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\\\end{bmatrix}\begin{bmatrix}0 & 1 & 0\\1 & 0 & 0\\0 & 0 & 1\\\end{bmatrix}\begin{bmatrix}1 & 0 & 0\\0 & 0 & 1\\0 & 1 & 0\\\end{bmatrix}\begin{bmatrix}0 & 1 & 0\\0 & 0 & 1\\1 & 0 & 0\\\end{bmatrix}\begin{bmatrix}0 & 0 & 1\\0 & 1 & 0\\1 & 0 & 0\\\end{bmatrix}\begin{bmatrix}0 & 0 & 1\\1 & 0 & 0\\0 & 1 & 0\\\end{bmatrix}</script><p>这可以理解为一个群，很明显，我们任取两个矩阵相乘，结果仍在这个群中。</p><blockquote><p>推广到 n 阶矩阵，n 阶矩阵有(n!)个置换矩阵，就是将单位矩阵 I 各行重新排列后所有可能的情况数量。其中(n!)的计算过程如下：首先单看第一行，有 n 种选择，其次看第二行，有(n-1)中选择，依次到最后一行，因此一共有(n!)个置换矩阵。</p></blockquote><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>本节我们对矩阵的转置、逆矩阵的性质进行了部分介绍，学习了矩阵的 LU 分解，了解了这种分解方式的优点所在，并学会了直接构造 L 矩阵，简化消元过程。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/matrix_lu_xmind.png" alt="matrix_lu_xmind"></p>]]></content>
    
    
    <summary type="html">矩阵的LU分解</summary>
    
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/categories/Linear-Algebra/"/>
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>线性代数03-矩阵乘法和逆矩阵</title>
    <link href="http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-3/"/>
    <id>http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-3/</id>
    <published>2025-03-16T02:54:39.000Z</published>
    <updated>2025-03-16T02:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra-乘法和逆矩阵-03"><a href="#Linear-Algebra-乘法和逆矩阵-03" class="headerlink" title="Linear Algebra-乘法和逆矩阵-03"></a>Linear Algebra-乘法和逆矩阵-03</h1><h2 id="知识概要"><a href="#知识概要" class="headerlink" title="知识概要"></a>知识概要</h2><p>前面介绍了向量与矩阵之间的乘法，这一节我们要介绍两个矩阵之间的乘法，并讨论逆矩阵存在的条件。最后介绍了求解逆矩阵的方法。</p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><h3 id="矩阵乘法最常见求解方式"><a href="#矩阵乘法最常见求解方式" class="headerlink" title="矩阵乘法最常见求解方式"></a>矩阵乘法最常见求解方式</h3><p>首先了解下矩阵之间进行乘法时，我们是如何求解单个元素的呢？</p><p>以$C=A\times B$为例，矩阵 C 中第 i 行第 k 列的元素等于矩阵 A 的第 i 行元素与矩阵 B 的第 k 列对应元素乘积之和。</p><p>设矩阵 A 是一个 $3\times4$的矩阵，矩阵B是一个$4\times4$的矩阵，根据矩阵乘法规则，它们的乘积$C = AB$是一个 $3\times4$的矩阵。其计算公式为：<script type="math/tex">c_{ik}=\sum_{j = 1}^{4}a_{ij}b_{jk}=a_{i1}b_{1k}+a_{i2}b_{2k}+a_{i3}b_{3k}+a_{i4}b_{4k}</script></p><p>推广到一般：<script type="math/tex">C_{ij}=(A的第i行)\cdot(B的第j列)=\sum_{k=1}^{n}a_{ik}b_{kj}</script></p><p>需要注意的是矩阵的规格问题，从向量点乘的角度看，<strong>A 的列数必须要与 B 的行数相同</strong>。</p><h3 id="列组合与行组合方式"><a href="#列组合与行组合方式" class="headerlink" title="列组合与行组合方式"></a>列组合与行组合方式</h3><h4 id="列组合"><a href="#列组合" class="headerlink" title="列组合"></a>列组合</h4><p>上一节我们学习到，矩阵与列向量的乘积，结果是一个列向量，该列向量可视为矩阵各列的线性组合。</p><p>那我们在计算矩阵间的乘法时，<strong>B 矩阵中的各列其实就是用来组合 A 矩阵的各列向量</strong>。其中<script type="math/tex">b_{0},b_{1}</script>等分别是 B 矩阵的列向量：</p><script type="math/tex; mode=display">A\times B = A\times \begin{bmatrix}b_{0} & b_{1} & b_{2} & b_{3}\end{bmatrix}=\begin{bmatrix}Ab_{0} & Ab_{1} & Ab_{2} & Ab_{3}\end{bmatrix}=C</script><p>该方法关键在于将右侧矩阵 B 看做列向量的线性组合，将问题转化为矩阵与向量的乘法问题。表明了矩阵 C 就是矩阵 A 中各列向量的线性组合，而 B 其实是在告诉我们，要以什么样的方式组合 A 中的列向量。</p><h4 id="行组合"><a href="#行组合" class="headerlink" title="行组合"></a>行组合</h4><p>同理，我们还学过行向量与矩阵的乘法，得到一个行向量。</p><script type="math/tex; mode=display">\begin{bmatrix}   m & n & k\end{bmatrix}\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\\   a_{2,1} & a_{2,2} & a_{2,3}\\   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix}=m\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\end{bmatrix}+n\begin{bmatrix}   a_{2,1} & a_{2,2} & a_{2,3}\end{bmatrix}+k\begin{bmatrix}   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix}</script><p>因此这次就把矩阵 A 看做行向量的组合就行了，其中<script type="math/tex">a_{0}^{T},a_{1}^{T}</script>分别是 A 的行向量：</p><script type="math/tex; mode=display">A\times B=\begin{bmatrix}   a_{0}^{T} \\   a_{1}^{T} \\   a_{2}^{T}\end{bmatrix}\times B=\begin{bmatrix}   a_{0}^{T}\times B \\   a_{1}^{T}\times B \\   a_{2}^{T}\times B\end{bmatrix} = C</script><p>即矩阵 B 各行的线性组合组成了 C 的各行。</p><h3 id="列乘以行"><a href="#列乘以行" class="headerlink" title="列乘以行"></a>列乘以行</h3><p>常规方法中，计算$A\times B=C$的矩阵乘法时，使用 A 的行向量乘上 B 的列向量得到 C 中各个位置的元素。</p><p>而我们这次介绍的方法，是用 A 的列向量乘以 B 的行向量，得到各个矩阵，再将矩阵相加，得到 C。</p><p>我们通过一个例子来说明：</p><p>【例】求解 <script type="math/tex">\begin{bmatrix}2 & 7\\3 & 8\\4 & 9\end{bmatrix}\begin{bmatrix}1 & 6\\1 & 2\end{bmatrix}</script></p><p>列乘行方法：</p><script type="math/tex; mode=display">\begin{bmatrix}2 & 7\\3 & 8\\4 & 9\end{bmatrix}\begin{bmatrix}1 & 6\\1 & 2\end{bmatrix}=\begin{bmatrix}2\\3\\4\end{bmatrix}\begin{bmatrix}1 & 6\end{bmatrix}+\begin{bmatrix}7\\8\\9\end{bmatrix}\begin{bmatrix}1 & 2\end{bmatrix}=\begin{bmatrix}2 & 12\\3 & 18\\4 & 24\end{bmatrix}+\begin{bmatrix}7 & 14\\8 & 16\\9 & 18\end{bmatrix}=\begin{bmatrix}9 & 26\\11 & 34\\13 & 42\end{bmatrix}</script><p>注意这里每一次都是用列向量与行向量相乘得到一个矩阵，而每次得到的矩阵都是有特点的，比如 <script type="math/tex">\begin{bmatrix}2\\3\\4\end{bmatrix}\begin{bmatrix}1 & 6\end{bmatrix}=\begin{bmatrix}2 & 12\\3 & 18\\4 & 24\end{bmatrix}</script>，其中<script type="math/tex">\begin{bmatrix}2 & 12\\3 & 18\\4 & 24\end{bmatrix}</script>的每一列都与<script type="math/tex">\begin{bmatrix}2\\3\\4\end{bmatrix}</script>同向，每一行都与<script type="math/tex">\begin{bmatrix}1 & 6\end{bmatrix}</script> 同向。因此，该矩阵的列空间(矩阵列所有可能的线性组合)和行空间(矩阵行所有可能的线性组合)都是一条直线。</p><h3 id="分块乘法"><a href="#分块乘法" class="headerlink" title="分块乘法"></a>分块乘法</h3><p>分块乘法就是宏观上的矩阵乘法，比如现在有一个 $50\times 50$的矩阵与$50\times 50$矩阵相乘，一个个进行运算很麻烦，尤其是如果矩阵在某一区域上有一定的性质(如某一矩阵分块内全部为 0 元素)，那么我们可以将其分块，如：</p><script type="math/tex; mode=display">\begin{bmatrix}A_{1} & A_{2}\\A_{3} & A_{4}\end{bmatrix}\begin{bmatrix}B_{1} & B_{2}\\B_{3} & B_{4}\end{bmatrix}=\begin{bmatrix}C_{1} & C_{2}\\C_{3} & C_{4}\end{bmatrix}</script><p>其中的<script type="math/tex">A_{i},B_{i}</script>都是划分后的一块块矩阵，如：</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/blocked_matrix_mulply.png" alt="blocked_matrix_mulply"></p><p>而<script type="math/tex">C_{1}=A_{1}B_{1}+A_{2}B_{3}</script>，和矩阵乘法的计算步骤一样，只是这里的<script type="math/tex">A_{1}B_{1},A_{2}B_{3}</script>都是矩阵间的乘法而已。只要 A 和 B 分块相互匹配，就可以用这样的分块乘法求解。</p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="逆矩阵介绍"><a href="#逆矩阵介绍" class="headerlink" title="逆矩阵介绍"></a>逆矩阵介绍</h3><p>之前我们介绍过一些逆矩阵的定义，对于一个<strong>方阵</strong> A，如果 A 可逆，就有$A^{-1}$，使得：$AA^{-1}=I=A^{-1}A$。</p><p>如果 A 是<strong>非方阵</strong>，左侧的$A^{-1}$与右侧的$A^{-1}$不可能相同，因为此时左右侧的$A^{-1}$形状一定不相同。</p><p>再以一个没有逆的矩阵为例：<script type="math/tex">\begin{bmatrix}1 & 2\\3 & 6\end{bmatrix}</script>，矩阵中的两个列向量互为倍数，也就是说其中一个向量对他们的线性组合无意义，那么这个 A 不可能有逆，换句话说：<strong>若存在非零向量 x，使得 Ax=0，那么 A 就不可能有逆矩阵。</strong></p><p>为什么呢？如果 A 有逆，且 x 是非零向量。则我们在$Ax=0$这个等式两边同时乘上$A^{-1}$，就有$A^{-1}Ax=Ix=0$，又因为$Ix=x$不是零向量，矛盾。因此此时 A 没有逆矩阵。</p><p>此时再回头看矩阵 <script type="math/tex">\begin{bmatrix}1 & 2\\3 & 6\end{bmatrix}</script>，由于两个列向量线性相关，一定有一个x，使得$Ax=0$，如<script type="math/tex">\begin{bmatrix}3\\-1\end{bmatrix}</script>，因此该矩阵不可逆。</p><h3 id="逆矩阵求解"><a href="#逆矩阵求解" class="headerlink" title="逆矩阵求解"></a>逆矩阵求解</h3><p>其实求逆矩阵就是解方程组的过程，举例说明：</p><p>【例】求解 <script type="math/tex">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}</script> 的逆矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}\begin{bmatrix}a & b\\c & d\end{bmatrix}=I=\begin{bmatrix}1 & 0\\0 & 1\end{bmatrix}</script><p>从列向量的角度看，得到两个方程：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}\begin{bmatrix}a\\c\end{bmatrix}=\begin{bmatrix}1\\0\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}\begin{bmatrix}b\\d\end{bmatrix}=\begin{bmatrix}0\\1\end{bmatrix}</script><p>解这个方程就行了，但是这样做低阶矩阵还好，高阶矩阵计算量未免太大了。所以这里介绍一下高斯-若尔当方法。</p><h3 id="高斯-若尔当方法"><a href="#高斯-若尔当方法" class="headerlink" title="高斯-若尔当方法"></a>高斯-若尔当方法</h3><p>还是上面的例子，两个方程：<script type="math/tex">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}\begin{bmatrix}a\\c\end{bmatrix}=\begin{bmatrix}1\\0\end{bmatrix}</script>，<script type="math/tex">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}\begin{bmatrix}b\\d\end{bmatrix}=\begin{bmatrix}0\\1\end{bmatrix}</script></p><p>这个方法就是可以同时处理两个方程组，即使用增广矩阵联系两个方程。增广矩阵格式如下：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 3 & 1 & 0\\2 & 7 & 0 & 1\end{bmatrix}</script><p>接下来进行行变换，将左侧的 $2\times 2$ 矩阵消为单位矩阵 I，此时右侧矩阵即为逆矩阵。</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 3 & 1 & 0\\2 & 7 & 0 & 1\end{bmatrix}->\begin{bmatrix}1 & 3 & 1 & 0\\0 & 1 & -2 & 1\end{bmatrix}->\begin{bmatrix}1 & 0 & 7 & -3\\0 & 1 & -2 & 1\end{bmatrix}</script><p>即逆矩阵为 <script type="math/tex">\begin{bmatrix}7 & -3\\-2 & 1\end{bmatrix}</script>。</p><p>接下来我们论证其合理性：</p><p>上面这个过程，对 <script type="math/tex">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}</script>进行消元处理使它变成单位矩阵I，就相当于<strong>左乘一堆的消元矩阵</strong>，设为E，就有<script type="math/tex">E\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}=I</script>，那么E肯定就是$A^{-1}$。再看右边，单位矩阵I经历了与<script type="math/tex">\begin{bmatrix}1 & 3\\2 & 7\end{bmatrix}</script>同样的消元过程，最后的结果相当于$EI=A^{-1}$，那虚线右侧得到的结果就是$A^{-1}$。</p><h2 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h2><p>本节介绍了认识矩阵乘法的不同角度，并介绍了逆矩阵的相关知识以及如何求解逆矩阵。MIT 的课程少有繁琐的证明，更多的是理解和类比，多从向量、空间、线性组合的角度去认识矩阵之间的运算。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/linear_algebra_multiply_and_inverse.png" alt="linear_algebra_multiply_and_inverse"></p>]]></content>
    
    
    <summary type="html">矩阵乘法和逆矩阵</summary>
    
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/categories/Linear-Algebra/"/>
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>线性代数02-矩阵消元</title>
    <link href="http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-2/"/>
    <id>http://david-luge.cn/2025/03/16/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-2/</id>
    <published>2025-03-16T01:54:39.000Z</published>
    <updated>2025-03-16T01:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra-矩阵消元-02"><a href="#Linear-Algebra-矩阵消元-02" class="headerlink" title="Linear Algebra-矩阵消元-02"></a>Linear Algebra-矩阵消元-02</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>这一节中我们介绍一下消元法，即是上一节中我们提到的“系统化”求解方程所用的方法，通过矩阵的消元运算可以很轻松地求解复杂方程。另外介绍了消元矩阵，即消元运算在矩阵乘法中所表现的形式。并从消元矩阵引入，介绍逆矩阵的基础知识。</p><h2 id="消元法求解方程"><a href="#消元法求解方程" class="headerlink" title="消元法求解方程"></a>消元法求解方程</h2><h3 id="消元法介绍"><a href="#消元法介绍" class="headerlink" title="消元法介绍"></a>消元法介绍</h3><p>对于一些“好”的系数矩阵（可逆）A 来说，我们可以使用<strong>消元法</strong>来求解方程$Ax=b$，我们还是从一个例子开始谈起。</p><p>求解方程：$x+2y+z=2, 3x+8y+z=12, 4y+z=2$</p><p>还是使用矩阵运算，将方程写成矩阵的形式$Ax=b$，$\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>3 &amp; 8 &amp; 1 \\<br>0 &amp; 4 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>x \\<br>y \\<br>z<br>\end{bmatrix}=\begin{bmatrix}<br>2 \\<br>12 \\<br>2<br>\end{bmatrix}$</p><p>所谓矩阵的消元法，与我们初等数学中学习的解二元一次方程组的消元法其实师出同门，都是将不同行的方程进行消元运算来简化方程，最后能得到简化的方程组，只不过这里我们是将系数单独抽出来做运算，<strong>寻找一种矩阵情况下的普遍规律而已</strong>。</p><p>消元针对的是系数矩阵 A：$\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \<br>3 &amp; 8 &amp; 1 \<br>0 &amp; 4 &amp; 1<br>\end{bmatrix}$。首先注意，左上角的 1 是消元法的关键，被称为主元“1”，接下来通过我们熟悉的“将一行乘倍数加到另一行”的行化简方法将第一列中除了主元之外的元素全变为 0。</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 2 & 1 \\   3 & 8 & 1 \\   0 & 4 & 1\end{bmatrix}-(2,1)->\begin{bmatrix}   1 & 2 & 1 \\   0 & 2 & -2 \\   0 & 4 & 1\end{bmatrix}</script><p>第一步目标达成，我们在第一列中只留下了主元 1，很好，接下来我们可以认为第一行与第一列已经“完工”了，再看去掉第一行第一列之后右下角剩下的部分：$\begin{bmatrix}<br>2 &amp; -2 \\<br>4 &amp; 1<br>\end{bmatrix}$，同样，我们将左上角的 2 视为主元，消元第一列，使其列上（不包括已经完成消元的第一行中的元素）除此主元 2 外都为 0。</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 2 & 1 \\   0 & 2 & -2 \\   0 & 4 & 1\end{bmatrix}-(3,2)->\begin{bmatrix}   1 & 2 & 1 \\   0 & 2 & -2 \\   0 & 0 & 5\end{bmatrix}</script><p>这时候第三行只剩下 5，我们直接将其处理为主元即可。得：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 2 & 1 \\   3 & 8 & 1 \\   0 & 4 & 1\end{bmatrix}-(2,1)->\begin{bmatrix}   1 & 2 & 1 \\   0 & 2 & -2 \\   0 & 4 & 1\end{bmatrix}-(3,2)->\begin{bmatrix}   1 & 2 & 1 \\   0 & 2 & -2 \\   0 & 0 & 5\end{bmatrix}</script><p>由于<strong>矩阵 A 可逆</strong>，因此经过消元处理得到的上三角矩阵 $U=\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>0 &amp; 2 &amp; -2 \\<br>0 &amp; 0 &amp; 5<br>\end{bmatrix}$ 中有三个主元。至此，消元结束，得到的 U 即为我们想要化简的形式。</p><blockquote><p>TIPS：<br>并不是所有的矩阵都可以消元处理，需要注意在消元过程中，如果主元位置(左上角)为 0，那么意味着这个主元不可取，需要进行“换行处理”，首先看它的下一行对应位置是不是 0，如果不是，就将这两行位置互换，将非零数视为主元。如果是，就再看下下行，以此类推。若其下面每一行都看到了，仍然没有非零数的话，那就意味着这个矩阵不可逆，消元法求出的解不唯一。下面是三个例子：<br>$\begin{bmatrix}<br>0 &amp; 2 &amp; 1 \\<br>0 &amp; 2 &amp; -2 \\<br>0 &amp; 0 &amp; 5<br>\end{bmatrix}$，$\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>0 &amp; 0 &amp; -2 \\<br>0 &amp; 0 &amp; 5<br>\end{bmatrix}$，$\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>0 &amp; 2 &amp; -2 \\<br>0 &amp; 0 &amp; 0<br>\end{bmatrix}$</p></blockquote><h3 id="回带求解"><a href="#回带求解" class="headerlink" title="回带求解"></a>回带求解</h3><p>其实回带求解应该跟消元法同时进行，只不过一些在一些软件的工作原理中他们是分别进行的，所以这里我们分开讨论，先介绍增广矩阵：</p><p>仍然是例一中的方程：$\begin{bmatrix}<br>1 &amp; 2 &amp; 1 \\<br>3 &amp; 8 &amp; 1 \\<br>0 &amp; 4 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>x \\<br>y \\<br>z<br>\end{bmatrix}=\begin{bmatrix}<br>2 \\<br>12 \\<br>2<br>\end{bmatrix}$，我们先给出增广矩阵形式：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 2 & 1 & 2\\   3 & 8 & 1 & 12\\   0 & 4 & 1 & 2\end{bmatrix}</script><p>显然，就是把系数矩阵 A 和向量 b 拼接成一个矩阵就行了。</p><p>然后像我们之前说的那样消元，但是这次要带着增广的 $b=\begin{bmatrix}<br>2 \\<br>12 \\<br>2<br>\end{bmatrix}$ 一起进行：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 2 & 1 & 2\\   3 & 8 & 1 & 12\\   0 & 4 & 1 & 2\end{bmatrix}-(2,1)->\begin{bmatrix}   1 & 2 & 1 & 2\\   0 & 2 & -2 & 6\\   0 & 4 & 1 & 2\end{bmatrix}-(3,2)->\begin{bmatrix}   1 & 2 & 1 & 2 \\   0 & 2 & -2 & 6\\   0 & 0 & 5 & -10\end{bmatrix}</script><p>之后，我们再带回方程$Ax=b$，变为：</p><script type="math/tex; mode=display">x+2y+z=2, 2y-2z=6, 5z=-10</script><p>从下向上开始求解，就很容易求出 x, y, z 的值了。</p><h2 id="消元矩阵"><a href="#消元矩阵" class="headerlink" title="消元矩阵"></a>消元矩阵</h2><h3 id="行向量与矩阵的乘法"><a href="#行向量与矩阵的乘法" class="headerlink" title="行向量与矩阵的乘法"></a>行向量与矩阵的乘法</h3><p>上面的消元法是从简单的变换角度介绍了消元的具体操作，接下来我们需要用矩阵来表示变换的步骤，这是十分必要的，因为这是一种“系统地”变换矩阵的方法。</p><p>首先介绍向量与矩阵之间的乘法，上一节中我们提到了矩阵和列向量之间的乘法，是矩阵中列向量的线性组合，如：</p><script type="math/tex; mode=display">\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\\   a_{2,1} & a_{2,2} & a_{2,3}\\   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix}\begin{bmatrix}   m\\   n\\   k\end{bmatrix}=m\begin{bmatrix}   a_{1,1}\\   a_{2,1}\\   a_{3,1}\end{bmatrix}+n\begin{bmatrix}   a_{1,2}\\   a_{2,2}\\   a_{3,2}\end{bmatrix}+k\begin{bmatrix}   a_{1,3}\\   a_{2,3}\\   a_{3,3}\end{bmatrix}</script><p>但这并不能解决我们现在的问题，因为我们在消元法中使用到的是行变换，那么我们就要思考，行向量和矩阵的乘积是什么呢？</p><script type="math/tex; mode=display">\begin{bmatrix}   m & n & k\end{bmatrix}\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\\   a_{2,1} & a_{2,2} & a_{2,3}\\   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix}=m\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\end{bmatrix}+n\begin{bmatrix}   a_{2,1} & a_{2,2} & a_{2,3}\end{bmatrix}+k\begin{bmatrix}   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix}</script><p>从上面的过程可以看出，<strong>行向量和矩阵的乘积是矩阵中行向量的线性组合</strong>。</p><p>至于行向量为什么放左边则是从矩阵乘法的维数匹配去考虑，以上式为例，行向量维数为 $1\times3$，矩阵维数为$3\times3$，因此行向量只能置于矩阵的左侧。</p><h3 id="消元矩阵介绍"><a href="#消元矩阵介绍" class="headerlink" title="消元矩阵介绍"></a>消元矩阵介绍</h3><p>该部分内容是重点。学会了行向量与矩阵之间的乘法，我们就可以使用行向量对矩阵的行进行操作了。所谓消元矩阵，就是将消元过程中的行变换转化为矩阵之间的乘法形式。</p><p>首先需知下面三个式子成立：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 0 & 0\end{bmatrix}\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\\   a_{2,1} & a_{2,2} & a_{2,3}\\   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix} = \begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}   0 & 1 & 0\end{bmatrix}\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\\   a_{2,1} & a_{2,2} & a_{2,3}\\   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix} = \begin{bmatrix}   a_{2,1} & a_{2,2} & a_{2,3}\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}   0 & 0 & 1\end{bmatrix}\begin{bmatrix}   a_{1,1} & a_{1,2} & a_{1,3}\\   a_{2,1} & a_{2,2} & a_{2,3}\\   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix} = \begin{bmatrix}   a_{3,1} & a_{3,2} & a_{3,3}\end{bmatrix}</script><p>此时将 $\begin{bmatrix}<br>1 &amp; 0 &amp; 0<br>\end{bmatrix}\begin{bmatrix}<br>0 &amp; 1 &amp; 0<br>\end{bmatrix}\begin{bmatrix}<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}$构成一个矩阵：单位阵：$\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}$，易得单位阵与矩阵相乘不改变矩阵。消元矩阵就是单位阵的变换形式，我们仍以例一中的矩阵说明：</p><script type="math/tex; mode=display">\begin{bmatrix}   ? & ? & ?\\   ? & ? & ?\\   ? & ? & ?\end{bmatrix}\begin{bmatrix}   1 & 2 & 1\\   3 & 8 & 1\\   0 & 4 & 1\end{bmatrix}=\begin{bmatrix}   1 & 2 & 1\\   0 & 2 & -2\\   0 & 4 & 1\end{bmatrix}</script><p>首先明确：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 0 & 0\\   0 & 1 & 0\\   0 & 0 & 1\end{bmatrix}\begin{bmatrix}   1 & 2 & 1\\   3 & 8 & 1\\   0 & 4 & 1\end{bmatrix}=\begin{bmatrix}   1 & 2 & 1\\   3 & 8 & 1\\   0 & 4 & 1\end{bmatrix}</script><p>消元过程的第一步是将第一行乘(-3)加到第二行，这是对第二行的操作，那么我们就从单位阵的第二行着手：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 0 & 0\\   0 & 1 & 0\\   0 & 0 & 1\end{bmatrix}-[L2=L2+L1*(-3)]->\begin{bmatrix}   1 & 0 & 0\\   -3 & 1 & 0\\   0 & 0 & 1\end{bmatrix}</script><p>根据先前的结论，“<strong>行向量和矩阵的乘积是矩阵中行向量的线性组合”</strong>。因此</p><script type="math/tex; mode=display">\begin{bmatrix}   -3 & 1 & 0\end{bmatrix}\begin{bmatrix}   1 & 2 & 1\\   3 & 8 & 1\\   0 & 4 & 1\end{bmatrix}=-3\begin{bmatrix}   1 & 2 & 1\end{bmatrix}+1\begin{bmatrix}   3 & 8 & 1\end{bmatrix}=\begin{bmatrix}   0 & 2 & -2\end{bmatrix}</script><p>因此，经验证，这一步的消元矩阵就是 $\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>-3 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}$，我们将其记为$E_{21}$，意义是将矩阵 A 中 2 行 1 列(2,1)位置变为 0 的消元矩阵。</p><p>同样，计算 $\begin{bmatrix}<br>1 &amp; 2 &amp; 1 &amp; 2\\<br>0 &amp; 2 &amp; -2 &amp; 6\\<br>0 &amp; 4 &amp; 1 &amp; 2<br>\end{bmatrix}-(3,2)-&gt;\begin{bmatrix}<br>1 &amp; 2 &amp; 1 &amp; 2\\<br>0 &amp; 2 &amp; -2 &amp; 6\\<br>0 &amp; 0 &amp; 5 &amp; -10<br>\end{bmatrix}$ 这一步的消元矩阵，即为：</p><script type="math/tex; mode=display">\begin{bmatrix}   1 & 0 & 0\\   0 & 1 & 0\\   0 & 0 & 1\end{bmatrix}-[L3=L3+L2*(-2)]->\begin{bmatrix}   1 & 0 & 0\\   0 & 1 & 0\\   0 & -2 & 1\end{bmatrix}</script><p>得到：</p><script type="math/tex; mode=display">E_{32}E_{21}A=U(Upper\ triangular\ matrix)</script><p>其中 U 为上三角矩阵。使用矩阵乘法的结合律，先计算<script type="math/tex">E_{32}E_{21}</script>，即为 E，则 E 就是整个此次消元过程的消元矩阵。</p><p>核心：求消元矩阵就是从单位阵 I 入手，按照 A 每次变换的消元步骤操作 I 矩阵，能分别得到$E_{row,col}$，最后相乘得到 E 即可。</p><h3 id="行交换矩阵与逆矩阵"><a href="#行交换矩阵与逆矩阵" class="headerlink" title="行交换矩阵与逆矩阵"></a>行交换矩阵与逆矩阵</h3><h4 id="行变换与列变换"><a href="#行变换与列变换" class="headerlink" title="行变换与列变换"></a>行变换与列变换</h4><p>有了上面消元矩阵的启发，易得能够交换 $2\times2$ 矩阵中两行的矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix}   0 & 1\\   1 & 0\end{bmatrix}\begin{bmatrix}   a & b\\   c & d\end{bmatrix}=\begin{bmatrix}   c & d\\   a & b\end{bmatrix}</script><p>而交换 $2\times2$ 矩阵中两列的矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix}   a & b\\   c & d\end{bmatrix}\begin{bmatrix}   0 & 1\\   1 & 0\end{bmatrix}=\begin{bmatrix}   b & a\\   d & c\end{bmatrix}</script><p>所以，<strong>左乘等同于行变换，右乘等同于列变换</strong>。</p><h4 id="逆矩阵初探"><a href="#逆矩阵初探" class="headerlink" title="逆矩阵初探"></a>逆矩阵初探</h4><p>可以说我们学会了消元矩阵，就相当于我们可以用矩阵乘法对一个矩阵进行任何变化了，那么我们考虑一个逆过程，即我们如何把一个消元结束的矩阵 U 变为未经消元的矩阵 A 呢？答案就是乘上一个逆矩阵。</p><p>如例一中的$E_{21}$，是第一行乘以3到第二行，即</p><script type="math/tex; mode=display">E_{21}=\begin{bmatrix}1 & 0 & 0\\-3 & 1 & 0\\0 & 0 & 1\end{bmatrix}</script><p>那么与之相反，我们在第二行加上第一行$\times3$就可以复原这一运算过程，即：$\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>3 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>-3 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}=\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}=I$。其中的I是单位矩阵。<br>此时的$\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>3 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}$称为<script type="math/tex">E_{21}^{-1}</script>，就有了<script type="math/tex">E_{21}^{-1}E_{21}=I</script>。</p><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>本节从矩阵消元的角度，介绍解方程的通用做法，并介绍了消元矩阵，使我们从矩阵乘法层面理解了消元的过程，并延伸了消元矩阵的应用：就是基于单位阵 I 的变化，对矩阵 A 进行行列变换的过程。</p>]]></content>
    
    
    <summary type="html">矩阵消元</summary>
    
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/categories/Linear-Algebra/"/>
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>线性代数01-方程组的几何解释</title>
    <link href="http://david-luge.cn/2025/03/15/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-1/"/>
    <id>http://david-luge.cn/2025/03/15/Linear_Algebra/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-1/</id>
    <published>2025-03-15T05:54:39.000Z</published>
    <updated>2025-03-15T05:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra-方程组的几何解释-01"><a href="#Linear-Algebra-方程组的几何解释-01" class="headerlink" title="Linear Algebra-方程组的几何解释-01"></a>Linear Algebra-方程组的几何解释-01</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>从本节开始，我们重新开始学习线性代数的有关知识。首先从解方程谈起，学习线性代数的应用之一就是求解复杂的方程问题，本文的核心就是从行图像和列图像的角度解方程。</p><h2 id="方程组的几何解释"><a href="#方程组的几何解释" class="headerlink" title="方程组的几何解释"></a>方程组的几何解释</h2><h3 id="二维的行图像"><a href="#二维的行图像" class="headerlink" title="二维的行图像"></a>二维的行图像</h3><p>首先我们可以通过一个例子来从行图像角度求解方程：</p><p>[例]求解方程：$2x-y=0, -x+2y=3$</p><p>我们首先按行将方程写成矩阵形式：$\begin{bmatrix}<br>2 &amp; -1 \\<br>-1 &amp; 2<br>\end{bmatrix}\begin{bmatrix}<br>x \\<br>y<br>\end{bmatrix}=\begin{bmatrix}<br>0 \\<br>3<br>\end{bmatrix}\\<br>$</p><p>系数矩阵(A)：将方程系数按行提取出来，构成一个矩阵；</p><p>未知向量(x)：将方程未知数提取出来，按列构成一个向量；</p><p>向量(b)：将等号右侧结果按列提取，构成一个向量；</p><p>下面我们可以通过行图像来求解这个方程，所谓行图像，就是在系数矩阵上，一次取一行构成方程，在坐标系上作图。和我们在初等数学中学习的作图求解方程的过程无异。由图可知，图中的绿点(1,2)就是方程组的解。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/EhNZbaZKooRziqxci8bccsZznzc.png" alt="矩阵解的几何形式"></p><h3 id="二维的列图像"><a href="#二维的列图像" class="headerlink" title="二维的列图像"></a>二维的列图像</h3><p>从列图像角度，我们再次求解这个方程 $2x-y=0, -x+2y=3$</p><p>这一次我们求解过程中，我们将方程按列提取，使用的矩阵为：$x\begin{bmatrix}<br>2 \\<br>-1<br>\end{bmatrix}+y\begin{bmatrix}<br>-1 \\<br>2<br>\end{bmatrix}=\begin{bmatrix}<br>0 \\<br>3<br>\end{bmatrix}$</p><p>如上，我们使用列向量构成系数矩阵，<strong>将问题转化为</strong>：</p><p>如何将向量 $\begin{bmatrix}<br>2 \\<br>-1<br>\end{bmatrix}$与向量$\begin{bmatrix}<br>-1 \\<br>2<br>\end{bmatrix}$正确组合，得到结果向量$\begin{bmatrix}<br>0 \\<br>3<br>\end{bmatrix}$?</p><p>接下来我们使用列图像求解此方程：</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/linear_column_pic0.png" alt="linear_column_pic0"></p><p>即寻找合适的 x，y 使得 x 倍的(2, -1) + y 倍的(-1, 2)得到最终的向量(0, 3)。很明显能看出来，x 为 1，y 为 2 时满足条件。反映在图像上，显然结果正确。</p><p>进一步思考的话，对于 $x\begin{bmatrix}<br>2 \\<br>-1<br>\end{bmatrix}+y\begin{bmatrix}<br>-1 \\<br>2<br>\end{bmatrix}$ 这个方程，如果 x 和 y 可以取任意值，那么可以得到什么呢？显然<strong>我们可以得到二维平面中任何方向的向量。</strong></p><h2 id="方程组的几何解释推广"><a href="#方程组的几何解释推广" class="headerlink" title="方程组的几何解释推广"></a>方程组的几何解释推广</h2><h3 id="高维行图像"><a href="#高维行图像" class="headerlink" title="高维行图像"></a>高维行图像</h3><p>我们将方程维数推广，从三维开始，$2x-y=0, -x+2y-z=-1, -3y+4z=4$，如果我们继续使用行图像的方法求解，那么会得到一个很复杂的图像。</p><p>矩阵形式如下：</p><p>$A=\begin{bmatrix}<br>2&amp;-1&amp;0\\<br>-1&amp;2&amp;-1\\<br>0&amp;-3&amp;4<br>\end{bmatrix}$，$b=\begin{bmatrix}<br>0\\<br>-1\\<br>4<br>\end{bmatrix}$，方程：$Ax=b$，$\begin{bmatrix}<br>2&amp;-1&amp;0\\<br>-1&amp;2&amp;-1\\<br>0&amp;-3&amp;4<br>\end{bmatrix}\begin{bmatrix}<br>x\\<br>y\\<br>z<br>\end{bmatrix}=\begin{bmatrix}<br>0\\<br>-1\\<br>4<br>\end{bmatrix}$</p><p>如果绘制行图像，这是 3 个平面相交得到一点，常见的思路是先联立其中两个平面，使其相交于一条直线，再研究这条直线与剩下的第三个平面相交于哪个点，最后得到的点坐标即为方程的解。直观上这种求解方式很难直接绘制更高维数的图像。</p><h3 id="高维列图像"><a href="#高维列图像" class="headerlink" title="高维列图像"></a>高维列图像</h3><p>还是刚刚的例子，$2x-y=0\\-x+2y-z=-1\\-3y+4z=4$，如果我们使用列图像的思路进行计算，那么矩阵形式就变为：</p><script type="math/tex; mode=display">x\begin{bmatrix}   2\\\\   -1\\\\   0\end{bmatrix}+y\begin{bmatrix}   -1\\\\   2\\\\   -3\end{bmatrix}+z\begin{bmatrix}   0\\\\   -1\\\\   4\end{bmatrix}=\begin{bmatrix}   0\\\\   -1\\\\   4\end{bmatrix}</script><p>左侧是线性组合，右侧是线性组合组成的结果，这样一来思路就清晰多了，“寻找线性组合”成为了解题的关键。</p><p>显然这道题是一个特例，明显$x=0,y=0,z=1$是方程的解，这在行图像中并不明显。</p><p>我们之所以更推荐使用列图像求解方程，是因为<strong>这是一种更系统的求解方法，即寻找线性组合</strong>，而不用绘制每个行方程的图像后寻找那个很难直观看出来的交点坐标。另一个优势在于，如果我们改变最后的结果 b，如本题中，我们将其改为 $x\begin{bmatrix}<br>2\\<br>-1\\<br>0<br>\end{bmatrix}+y\begin{bmatrix}<br>-1\\<br>2\\<br>-3<br>\end{bmatrix}+z\begin{bmatrix}<br>0\\<br>-1\\<br>4<br>\end{bmatrix}=\begin{bmatrix}<br>1\\<br>1\\<br>-3<br>\end{bmatrix}$，那么我们就重新寻找一个线性组合就够了。但如果我们使用的是行图像呢？那意味着我们要完全重画三个平面图像，就简便性来讲，两种方法高下立判。</p><p>另外，还要注意的一点是，对任意的 b 是不是都能求解$Ax=b$这个矩阵方程呢？也就是对于 $3\times3$的系数矩阵A，其列的线性组合是否都能覆盖整个三维空间呢？对于我们上面举的这些例子，都是可以的。但是有些矩阵就是不行的，比如三个列向量本身就只构成了一个平面，那么这样的三个向量组成的向量只能分布在该平面上，肯定无法覆盖整个三维空间。如三个列向量分别为：$\begin{bmatrix}<br>2\\<br>-1\\<br>0<br>\end{bmatrix}$，$\begin{bmatrix}<br>-1\\<br>2\\<br>-3<br>\end{bmatrix}$，$\begin{bmatrix}<br>1\\<br>1\\<br>-3<br>\end{bmatrix}$。这三个向量就构成了一个平面，其中$\begin{bmatrix}<br>2\\<br>-1\\<br>0<br>\end{bmatrix}+\begin{bmatrix}<br>-1\\<br>2\\<br>-3<br>\end{bmatrix}=\begin{bmatrix}<br>1\\<br>1\\<br>-3<br>\end{bmatrix}$。对于这个方程组而言，就无法实现对于任意的 b，方程的解都存在。</p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>如 Ax，如果我们已知一个矩阵 A 和一个向量 x，那么我们如何求解它们的积呢？例如 $A=\begin{bmatrix}<br>2&amp;5\\<br>1&amp;3<br>\end{bmatrix}$，$x=\begin{bmatrix}<br>1\\<br>2<br>\end{bmatrix}$，我们这样求：</p><ul><li>法一：将矩阵 A 看做列向量的组合：</li></ul><script type="math/tex; mode=display">\begin{bmatrix}   2&5\\\\   1&3\end{bmatrix}\begin{bmatrix}   1\\\\   2\end{bmatrix}=1\begin{bmatrix}   2\\\\   1\end{bmatrix}+2\begin{bmatrix}   5\\\\   3\end{bmatrix}=\begin{bmatrix}   12\\\\   7\end{bmatrix}</script><p>即 x 每个分量与矩阵中各列向量相乘，再将其求和。</p><ul><li>法二：向量点乘</li></ul><script type="math/tex; mode=display">\begin{bmatrix}   2&5\\\\   1&3\end{bmatrix}\begin{bmatrix}   1\\\\   2\end{bmatrix}=\begin{bmatrix}   (2,5)\cdot(1,2)\\\\   (1,3)\cdot(1,2)\end{bmatrix}=\begin{bmatrix}   12\\\\   7\end{bmatrix}</script><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>该部分内容是对线性代数内容的初涉，从解方程谈起，引入列空间的概念，可以发现从列空间角度将求解方程，变化为求列向量的线性组合，这种方法更加科学，并从列向量的线性组合方式了解矩阵乘法。</p>]]></content>
    
    
    <summary type="html">方程组的几何解释</summary>
    
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/categories/Linear-Algebra/"/>
    
    
    <category term="Linear_Algebra" scheme="http://david-luge.cn/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>EVM-概念与数学原理</title>
    <link href="http://david-luge.cn/2025/03/12/Com/EVM-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <id>http://david-luge.cn/2025/03/12/Com/EVM-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</id>
    <published>2025-03-12T13:54:39.000Z</published>
    <updated>2025-03-12T13:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EVM：概念与数学原理"><a href="#EVM：概念与数学原理" class="headerlink" title="EVM：概念与数学原理"></a>EVM：概念与数学原理</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h3><p>在无线通信系统中，信号的质量直接影响数据传输的稳定性和速率。误差向量幅度（Error Vector Magnitude, EVM）是衡量调制信号质量的重要参数，广泛应用于 Wi-Fi、蜂窝网络和其他无线技术。本文将详细介绍 EVM 的概念、数学原理以及它对 Wi-Fi 传输性能的影响。</p><hr><h3 id="1-什么是-EVM？"><a href="#1-什么是-EVM？" class="headerlink" title="1. 什么是 EVM？"></a><strong>1. 什么是 EVM？</strong></h3><p>EVM 是衡量接收信号与理想信号之间误差的指标。它描述了调制信号在接收端与发送端理想信号之间的偏差程度，通常以百分比（%）或 dB（分贝）表示。</p><p>在 Wi-Fi（IEEE 802.11 标准）中，EVM 被用来评估不同调制方案（如 BPSK、QPSK、16-QAM、64-QAM、256-QAM）的信号质量。较低的 EVM 值表示更好的信号质量，而较高的 EVM 值则意味着更多的误差，可能导致数据误码率（BER）上升。</p><hr><h3 id="2-EVM-的数学原理"><a href="#2-EVM-的数学原理" class="headerlink" title="2. EVM 的数学原理"></a><strong>2. EVM 的数学原理</strong></h3><h4 id="2-1-EVM-的计算公式"><a href="#2-1-EVM-的计算公式" class="headerlink" title="2.1 EVM 的计算公式"></a><strong>2.1 EVM 的计算公式</strong></h4><p>EVM 计算的基本公式如下：</p><script type="math/tex; mode=display">EVM_{rms} = \sqrt{\frac{\sum_{i=1}^{N} |S_i - R_i|^2}{\sum_{i=1}^{N} |S_i|^2}} \times 100</script><p>其中：</p><ul><li>$S_i$ 是理想信号（发送信号）的 IQ 复数坐标。</li><li>$ R_i $ 是实际接收到的信号 IQ 复数坐标。</li><li>$ N $ 是符号的总数。</li><li>$ |S_i - R_i| $ 表示发送信号与接收信号之间的误差向量。</li><li>$ |S_i| $ 是理想信号的幅度。</li></ul><p>该公式表示误差向量的均方根（RMS）值与理想信号功率的比值，并转换为百分比形式。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/KSpjbVNUno0b8Axrnl9chsa5nij.png" alt="KSpjbVNUno0b8Axrnl9chsa5nij"></p><h4 id="2-2-dB-形式的-EVM-计算"><a href="#2-2-dB-形式的-EVM-计算" class="headerlink" title="2.2 dB 形式的 EVM 计算"></a><strong>2.2 dB 形式的 EVM 计算</strong></h4><p>在无线通信测试中，EVM 常以 dB 形式表示，其计算公式为：</p><script type="math/tex; mode=display">EVM_{dB} = 10 \log_{10} \left( \frac{\sum_{i=1}^{N} |S_i - R_i|^2}{\sum_{i=1}^{N} |S_i|^2} \right)</script><p>这种形式的 EVM 便于与其他无线通信参数（如信噪比 SNR）进行对比。</p><hr><h3 id="3-EVM-对-Wi-Fi-传输的影响"><a href="#3-EVM-对-Wi-Fi-传输的影响" class="headerlink" title="3. EVM 对 Wi-Fi 传输的影响"></a><strong>3. EVM 对 Wi-Fi 传输的影响</strong></h3><p>EVM 直接影响 Wi-Fi 设备的通信质量，并与以下因素密切相关：</p><h4 id="3-1-调制方式与-EVM-要求"><a href="#3-1-调制方式与-EVM-要求" class="headerlink" title="3.1 调制方式与 EVM 要求"></a><strong>3.1 调制方式与 EVM 要求</strong></h4><p>不同的 Wi-Fi 调制方式（BPSK、QPSK、16-QAM、64-QAM、256-QAM、1024-QAM）对 EVM 的要求不同，调制阶数越高，对 EVM 的要求越严格。例如：</p><table><tr><td>调制方式<br/></td><td>典型 EVM 要求 (dB)<br/></td></tr><tr><td>BPSK<br/></td><td>-5 dB<br/></td></tr><tr><td>QPSK<br/></td><td>-10 dB<br/></td></tr><tr><td>16-QAM<br/></td><td>-16 dB<br/></td></tr><tr><td>64-QAM<br/></td><td>-22 dB<br/></td></tr><tr><td>256-QAM<br/></td><td>-28 dB<br/></td></tr><tr><td>1024-QAM<br/></td><td>-32 dB<br/></td></tr></table><p>当 EVM 超过规定的阈值时，接收端可能无法正确解调信号，导致数据误码率上升，从而降低吞吐量。</p><h4 id="3-2-影响-EVM-的主要因素"><a href="#3-2-影响-EVM-的主要因素" class="headerlink" title="3.2 影响 EVM 的主要因素"></a><strong>3.2 影响 EVM 的主要因素</strong></h4><ol><li><strong>射频链路非理想性</strong>：包括相位噪声、非线性放大、IQ 失衡等。</li><li><strong>信号干扰</strong>：其他 Wi-Fi 设备、电磁干扰源可能会影响信号质量。</li><li><strong>多径效应</strong>：无线信号在传播过程中经过反射、衍射等现象，会导致信号失真。</li><li><strong>天线和匹配网络设计</strong>：不良的天线匹配会影响信号传输质量。</li></ol><hr><h3 id="4-如何优化-EVM-以提高-Wi-Fi-质量？"><a href="#4-如何优化-EVM-以提高-Wi-Fi-质量？" class="headerlink" title="4. 如何优化 EVM 以提高 Wi-Fi 质量？"></a><strong>4. 如何优化 EVM 以提高 Wi-Fi 质量？</strong></h3><p>为了降低 EVM 并提高 Wi-Fi 通信质量，可以采取以下措施：</p><ol><li><strong>优化射频设计</strong>：改进功放线性度，减少 IQ 失衡。</li><li><strong>增强信号处理算法</strong>：采用数字预失真（DPD）等技术补偿非线性失真。</li><li><strong>减少干扰</strong>：使用 5GHz 或 6GHz 频段，避免 2.4GHz 的拥塞。</li><li><strong>天线优化</strong>：使用高质量天线，并确保阻抗匹配。</li><li><strong>提高 SNR</strong>：使用更高增益的天线，减少环境噪声，提高接收灵敏度。</li></ol><hr><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h3><p>EVM 是衡量 Wi-Fi 信号质量的重要指标，它通过计算误差向量的均方根值来评估接收信号与理想信号的偏差。较低的 EVM 值意味着更好的调制解调性能，从而提高数据传输的稳定性和速率。通过优化射频设计、减少干扰、提升 SNR，可以有效降低 EVM，提升 Wi-Fi 设备的通信质量。</p><p>随着 Wi-Fi 6（802.11ax）和 Wi-Fi 7（802.11be）的发展，EVM 在高阶调制（如 1024-QAM、4096-QAM）中的作用将更加关键。因此，深入理解 EVM 及其优化方法，对无线通信工程师而言至关重要。</p>]]></content>
    
    
    <summary type="html">简要介绍了EVM指标</summary>
    
    
    
    <category term="Communication" scheme="http://david-luge.cn/categories/Communication/"/>
    
    
    <category term="Communication" scheme="http://david-luge.cn/tags/Communication/"/>
    
  </entry>
  
  <entry>
    <title>DPD-数字预失真</title>
    <link href="http://david-luge.cn/2025/03/12/Com/DPD-%E6%95%B0%E5%AD%97%E9%A2%84%E5%A4%B1%E7%9C%9F/"/>
    <id>http://david-luge.cn/2025/03/12/Com/DPD-%E6%95%B0%E5%AD%97%E9%A2%84%E5%A4%B1%E7%9C%9F/</id>
    <published>2025-03-12T02:54:39.000Z</published>
    <updated>2025-03-12T02:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DPD-数字预失真"><a href="#DPD-数字预失真" class="headerlink" title="DPD-数字预失真"></a>DPD-数字预失真</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>家人们，今天咱来唠唠通信界的一个超重要 “选手”——数字预失真 DPD(Digital Pre-Distortion)，它在通信领域那可是相当有存在感，就像游戏里的神助攻，能让射频放大器变得超厉害！</p><h1 id="DPD-是个啥"><a href="#DPD-是个啥" class="headerlink" title="DPD 是个啥"></a>DPD 是个啥</h1><p>DPD 这名字听起来有点绕，简单来说，就是让正常的数字信号提前 “变个样”。</p><p>“数字” 嘛，说明是在数字的地盘儿搞事情，和模拟域没啥关系；</p><p>“预” 就是提前的意思，在射频功率放大器 “开工” 之前就先行动；</p><p>“失真” 呢，信号在传输过程中走样了就叫失真，DPD 就是故意让原始信号 “失失真” 。这就好比给信号提前做了个 “变形手术”，专门用来对付功率放大器的那些小脾气。</p><p>既然 DPD 是为了对付 PA 的小脾气的，自然在信号处理系统中，DPD 就要放在 PA 的前面。</p><h1 id="为啥需要-DPD"><a href="#为啥需要-DPD" class="headerlink" title="为啥需要 DPD"></a>为啥需要 DPD</h1><p>这就得吐槽一下射频功率放大器啦！它有个让人头疼的毛病，输入功率加到一定程度，就开始 “耍小性子”，进入非线性区。这时候，输入和输出不再是 “铁哥们”，不再成线性关系。增加输入功率，输出功率却不给力，效率直线下降，信号还失真了。就好比你使劲给车加油，车却跑不起来，还跑偏了。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Oqirbaoknoleu8xUGgscVMTJnge.png" alt="DPD示意图"></p><p>接收端收到失真信号后，还会继续 “捣乱”，把失真加剧。那咋办呢？</p><p>一般有两种办法，要么降低输入信号功率，躲开非线性区这个 “大坑”；要么增加输入信号功率，牺牲点能量换信号不失真。</p><p>DPD 就属于后者，它就像个聪明的 “信号整形师”，让原先的信号朝着和功率放大器相反的方向 “变形”，抵消掉功率放大器的非线性影响 。这么一来，输出和输入信号之间的线性关系区间变宽了，功率放大器效率也提升了，不过功耗也增加了点，就当是给效率提升交的 “小电费” 吧。而且用了 DPD，无线基站的效率能大幅提升，能给网络运营商省下不少钱呢！</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Oqirbaoknoleu8xUGgscVMTJnge1.png" alt="PA特性"></p><h1 id="谁能搞定-DPD？"><a href="#谁能搞定-DPD？" class="headerlink" title="谁能搞定 DPD？"></a>谁能搞定 DPD？</h1><h2 id="设备厂家"><a href="#设备厂家" class="headerlink" title="设备厂家"></a>设备厂家</h2><p>那些大型设备厂家，像华为、中兴、爱立信、诺基亚、三星，都是 DPD 技术的 “大拿”，自家都有厉害的 DPD 技术，就像有独家秘籍一样。</p><p>小厂就有点尴尬啦，大多没有自己的 DPD 技术，毕竟没积累嘛。没办法，只能找学校 “取经”，或者直接买 FPGA 公司提供的 IP core，就像借别人的工具来干活。</p><h2 id="芯片厂家"><a href="#芯片厂家" class="headerlink" title="芯片厂家"></a>芯片厂家</h2><p>FPGA 芯片厂家可就牛了，不仅能提供高性能的 DPD 解决方案，而且 IP 核参数还能自己调，不用手动一点点定制，省了好多事儿，就像给你一把万能钥匙，直接打开 DPD 的大门，还能提供超小占位面积、低成本的 FPGA 解决方案。</p><h1 id="DPD-有什么实现难点？"><a href="#DPD-有什么实现难点？" class="headerlink" title="DPD 有什么实现难点？"></a>DPD 有什么实现难点？</h1><p>DPD 想发挥好作用，也不是一帆风顺的。首先，它的数学模型和参数得和功率放大器（PA）完美匹配，PA 要是变了，DPD 的数学模型或参数也得跟着变，就像脚变了，鞋也得换。</p><p>随着 5G 时代到来，载波带宽越来越宽，都能达到 800MHz。以前 4G 的 DPD 数学模型在 5G 基站 PA 这儿就 “水土不服” 了，性能根本不达标，所以还得深入研究新的数学模型。</p><p>最后，DPD 不管是用 FPGA、CPU 还是 DSP 来实现，都得从实现难度、资源消耗、成本控制、研发周期等多方面综合考虑，这里面的技术门道可多了，一般人还真搞不定。</p><h1 id="功率放大器的模型是什么样？"><a href="#功率放大器的模型是什么样？" class="headerlink" title="功率放大器的模型是什么样？"></a>功率放大器的模型是什么样？</h1><h2 id="“宽带”-功放线性区数学模型"><a href="#“宽带”-功放线性区数学模型" class="headerlink" title="“宽带” 功放线性区数学模型"></a>“宽带” 功放线性区数学模型</h2><p>所谓 “宽带”，就是信号带宽超宽，啥频率都能在功率放大器里畅通无阻。假设输入是 IQ 调制信号，线性区模型就是输出和输入是简单的倍数关系。经过功率放大器后，信号频谱不变，幅度还放大了，就像给信号打了一针 “放大剂”。</p><h2 id="“宽带”-功放非线性区数学模型"><a href="#“宽带”-功放非线性区数学模型" class="headerlink" title="“宽带” 功放非线性区数学模型"></a>“宽带” 功放非线性区数学模型</h2><p>到了非线性区，情况就复杂了。可以用幂指数函数或者幂级数函数来描述。</p><p>幂指数函数的图像如下：</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/WnTobcCD8oiC5px9lqMcRnBCnWc.png" alt="幂指函数"></p><p>幂级数函数是用来模拟非线性特性的</p><p>拿幂级数函数来说，它适合模拟无记忆的弱非线性系统。</p><script type="math/tex; mode=display">y=\sum_{n=0}^{\infty}a_{n}(x-x_{0})^{n}</script><p>上面的公式被称为幂级数，其中$x<em>{0}$为常数，$a</em>{0},a<em>{1},…a</em>{n}$称为幂级数的系数。</p><p>下面以输出信号为 IQ 调制信号为例，来说明经过功率放大器后会产生很多的谐波分量；</p><p><strong>假设 1</strong>：输入信号为 IQ 调制信号(双音正弦信号)：</p><script type="math/tex; mode=display">x(t)=A_{1}cos(wt)+A_{2}sin(wt)</script><p><strong>假设 2</strong>：功率放大器是三阶函数：</p><script type="math/tex; mode=display">y(t)=a_{1}x(t)+a_{2}x^{2}(t)+a_{3}x^{3}(t)</script><p>则输出信号的频谱为：基波分量 W，二阶谐波分量 2W，三阶谐波分量 3W；</p><p>显然，经过功率放大器后，信号有很多的谐波分量，这就会导致信号的失真；</p><ul><li>产生的非基波频谱分量(二次、三次谐波分量)分走了本该作用在全部基波上的功率，造成了能量的损失；</li><li>产生的非基波频谱分量(二次、三次谐波分量)落在信号通带、邻带和其他有用通带内，如果不用滤波器加以滤除，则会对有用信号产生干扰；</li><li>如果产生谐波分量正好落在<strong>信号带宽内</strong>，这就<strong>无法滤除</strong>，产生无法消除的信号干扰；</li></ul><p>因此，如果功率放大器在非线性区对高频信号进行放大，损失能量是小事，最麻烦的问题是，会产生谐波干扰信号；</p><p>因此，要尽量避免功率放大器对输入信号进行非线性放大，要尽量对信号进行线性放大。</p><p>那么可能会有人说，直接让 PA 工作在线性区不就行了吗？实际的通信系统中会面临如下问题：</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Ww2tbZD2zoyDIgxCcrHc4GzpnMh.png" alt="DPD问题"></p><ul><li>信号的幅度变化较大，峰均比（信号峰值与信号均值的比值）比较高，这就意味着即使信号均值落在线性区，信号的峰值也有可能落在非线性区；</li><li>如果信号峰值和均值都落在线性区，这功率放大器的利用率就很低，大部分时间工作在低功率区，对功率放大器是很大的浪费，功率放大器的线性区间越宽，价格越贵，并且价格相差很大；</li><li>移动通信系统中，要增加信号的覆盖区，就需要增大发射功率；</li></ul><p>因此，无论是从成本，还是实际部署的角度考虑，都期望尽可能让输入信号的功率，<strong>工作在接近非线性区附近</strong>。</p><p>有了这些原因，才会有工程师想，能不能在 PA 之前，先对原始的输入信号$X(t)$进行预处理，得到$Z(t)$，使得功率放大器的输入信号$Z(t)$工作在非线性区，输出信号$Y(t)$与$X(t)$之间还是线性关系呢？</p><p>这就是数字预失真 DPD 和削峰 CFR；其中 CFR 的作用是降低信号的峰均比；</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/QkgHbEVYQorlGzxKlcRcCnrEnJh.png" alt="CFR+DPD"></p><p>这样带来两个好处：</p><ul><li>虽然 PA 工作在非线性区，但是如果 DPD+PA，从整体来看，PA 的输出信号和 DPD 的输入信号之间还是线性关系，没有导致输入信号失真；</li><li>从逻辑上看，在不改变功率放大器的情况下，增大了功率放大器的线性区间；</li></ul><h2 id="“带限”-系统的-Volterra-级数模型"><a href="#“带限”-系统的-Volterra-级数模型" class="headerlink" title="“带限” 系统的 Volterra 级数模型"></a>“带限” 系统的 Volterra 级数模型</h2><p>实际系统大多是 “带限” 系统，带宽有限制，DAC 对带宽影响很大。带宽增加，不仅会带来记忆效应，对 ADC 要求也更高。“带限” 系统只关心载带和邻带信号，数学模型是 Volterra 级数模型，不同阶数的非线性多项式对应不同带宽的信号非线性分量。为了让建模更准，还得在传统模型里加带限函数。</p><p>下图是 DPD 结构的一个示意图</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/STW0bDuZUo1cvIx3egycJTjHnie.png" alt="DPD结构示意图"></p><p>我们使用 Volterra 级数模型对 PA 进行建模的话，可以同时考虑到非线性和记忆效应；</p><script type="math/tex; mode=display">F[x(n)]=\sum_{k=1}^K\sum_{q=0}^Qa_{kq}x(n-q)\left|x(n-q)\right|^{k-1}</script><p>其中 K 是多项式级数，Q 是记忆深度。</p><blockquote><p>From Xilinx DPD IP Doc，Xilinx 对于$a_{kq}$的求解</p></blockquote><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/whiteboard_exported_image.png" alt="DPD思维导图"></p>]]></content>
    
    
    <summary type="html">简要介绍了数字预失真技术</summary>
    
    
    
    <category term="Communication" scheme="http://david-luge.cn/categories/Communication/"/>
    
    
    <category term="Communication" scheme="http://david-luge.cn/tags/Communication/"/>
    
  </entry>
  
  <entry>
    <title>AXI协议概述</title>
    <link href="http://david-luge.cn/2024/04/15/IC/AXI/AXI%E5%8D%8F%E8%AE%AE/"/>
    <id>http://david-luge.cn/2024/04/15/IC/AXI/AXI%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-04-15T13:39:39.000Z</published>
    <updated>2024-04-15T13:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AXI是一种总线协议，由ARM公司提出，面向高性能、高带宽、低延迟的片内总线。主要的特点有：</p><ol><li>分离的地址/控制、数据通道；</li><li>支持非对齐的数据传输；</li><li>基于Burst传输，仅需传输首地址；</li><li>分离的读写数据通道，可供DMA使用(MM2S、S2MM)；</li><li>支持超前传输，可以连续发送多个突发传输的首地址而无需等待之前的突发传输完成，这有助于处理流水处理Transaction；</li><li>支持乱序传输；</li><li>易于添加寄存器级来实现时序收敛；</li></ol><p>与AXI传输有关的三个概念：</p><ul><li>Transaction：两个AXI组件为了传输一组数据而进行的所有交互称为AXI Transaction，包括所有5个通道上的交互；</li><li>Burst：在AXI Transaction中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个Transfer因为使用一个周期，又被称为一拍数据（Beat）；</li><li>Transfer/Beat：一次成功握手，占用一个时钟周期；</li></ul><h2 id="AXI读写架构"><a href="#AXI读写架构" class="headerlink" title="AXI读写架构"></a>AXI读写架构</h2><p>AXI协议是基于Burst的传输，共定义了以下5个独立的传输通道：<strong>读地址、读数据、写地址、写数据、写响应通道；</strong>这五个通道都只支持单向传输。</p><p>AXI使用<strong>基于VALID/READY的握手机制</strong>传输数据，发送端使用VALID表明地址/控制、数据信号是有效的，目的端使用READY表明自己能够接收信息；这是一种<strong>双向流控机制</strong>，指发送方通过置起VALID信号控制发送的时机和速度，接收方也可以通过READY信号的置起与否控制接收速度。<strong>发送方具有传输的主动权，但接收方在不具备接收能力时，也能够通过置低信号停止传输，反压发送方；</strong></p><p>此处应注意置起VALID信号是完全主动与独立的过程，接收方的READY信号可以依赖发送方的VALID信号，主要目的是为避免死锁情况，即VALID不能等READY，READY可以等VALID；（注：<strong>协议建议将READY的默认电平设置为高电平</strong>，这样减少传输过程的时间开销）</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/read_transaction11.png" alt="read_transaction"></p><p><strong>读操作</strong></p><p>读操作仅涉及两个通道，首先主机在读地址通道（AR）上写入本次传输操作待读取数据的地址以及控制信息；</p><p>从机在接收到地址后，将该地址上的数据通过读数据通道（R）传输给主机；</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/write_transaction.png" alt="read_transaction"></p><p><strong>写操作</strong></p><p>写操作涉及三个通道，主机先在写地址通道（AW）上告知从机本次写传输操作的属性，包括地址和控制信息；然后在写数据通道上（W）向从机写入数据，一次传输操作中可能包括多个数据传输；最后从机在收完写数据后，通过写响应通道将本次传输操作的响应告知主机，作为写传输操作结束的标志。此处应注意，<strong>写回复是针对整个传输（Transaction）操作的，而不是针对每个写入数据（Data Transfer）</strong></p><h2 id="AXI一些情况的说明"><a href="#AXI一些情况的说明" class="headerlink" title="AXI一些情况的说明"></a>AXI一些情况的说明</h2><h3 id="跨4K问题"><a href="#跨4K问题" class="headerlink" title="跨4K问题"></a>跨4K问题</h3><p>单次Burst传输中的数据，其传输地址不能跨越4K边界，注意此处说的不是容量。因为底层Page的存储容量为4KB，一个Burst的数据必须在同一个Page里，否则会出错；</p><h3 id="Response问题"><a href="#Response问题" class="headerlink" title="Response问题"></a>Response问题</h3><p>Read操作每次transfer都会有一个response，而Write操作的每次Burst才有一次response。为什么AXI spec要做如此规定呢？</p><ol><li>对于Read操作，spec明确规定必须先写addr，再读read data，那么slave返回read data时，已经能确定该transfer是否成功，因此这时的response是确知的，response就可以和read data一起回给master。</li><li>对于Write操作，addr和data均是从master到slave，而response是从slave到master，因此需要增加一个response通道。那么为什么不是每次transfer都有response？因为<strong>写地址和写数据没有先后依赖关系</strong>，因此，<strong>第n次transfer时，slave可能只收到data，而没收到addr，此时还无法判断response结果</strong>，所以write操作做不到每次transfer都给出response，而是每次burst有一次response。</li></ol><h3 id="能否提前结束突发传输"><a href="#能否提前结束突发传输" class="headerlink" title="能否提前结束突发传输"></a>能否提前结束突发传输</h3><p>通信双方都不能在传输事务的所有Transfer完成前提前结束。哪怕发生错误，也需要走完传输事务的全流程。</p><p>但主机也有办法减少传输的数据量：发送方<strong>可以通过置低所有写数据的有效位（WSTRB）信号，使写数据无效</strong>。在读传输事务中，主机可以直接丢弃读取到的数据。</p><blockquote><p>No component can terminate a burst early. However, to reduce the number of data transfers in a write burst, the Manager can disable further writing by deasserting all the write strobes. In this case, the Manager must complete the remaining transfers in the burst. In a read burst, the Manager can discard read data, but it must complete all transfers in the burst.</p></blockquote><h3 id="握手间的依赖关系"><a href="#握手间的依赖关系" class="headerlink" title="握手间的依赖关系"></a>握手间的依赖关系</h3><p>双箭头表示强依赖</p><p><strong>读Transaction</strong></p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/R_channel_dependency.png" alt="R_channel_dependency"></p><p><strong>写Transaction</strong></p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/W_channel_dependency.png" alt="W_channel_dependency"></p><h3 id="读写数据结构"><a href="#读写数据结构" class="headerlink" title="读写数据结构"></a>读写数据结构</h3><p>在AXI数据传输过程中，主要涉及到窄位宽数据传输（Narrow Transfer）、非对齐传输（Unaligned Transfer）以及混合大小端传输（mix_endianness）等问题。</p><h4 id="窄位宽数据传输"><a href="#窄位宽数据传输" class="headerlink" title="窄位宽数据传输"></a>窄位宽数据传输</h4><p>当本次传输中数据位宽小于通道本身的数据位宽时，称为窄位宽数据传输。</p><p>在窄位宽数据传输中，主机需要告知从机数据通道中哪些字节是有效的，需要使用到写数据通道上的WSTRB信号。<strong>WSTRB信号中的单个bit置起，表示对应位置上的字节有效</strong>。WSTRB信号比特位宽等于数据通道位宽的字节数量，比如32bit位宽的数据通道对应WSTRB信号位宽为4bit。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/narrow_transfer.png" alt="narrow_transfer"></p><h4 id="非对齐传输"><a href="#非对齐传输" class="headerlink" title="非对齐传输"></a>非对齐传输</h4><p>AXI协议支持地址非对齐的传输，允许突发传输的首字节地址，即起始地址与<strong>突发传输位宽</strong>不对齐。举例说明，当总线位宽为32bit时，如果地址为0x1002，则产生了非对齐现象。与32bit位宽总线对齐的地址需要能被4整除，即ADDR[1:0]=2’b0。</p><p><strong>注意</strong>：此处对齐与否应当取决于突发传输的宽度，而不是总线位宽。</p><p>对于非对齐传输，主机会进行两项操作：</p><ul><li>即使起始地址非对齐，也保证所有传输地址是对齐的；</li><li>在首个transfer中添加填充数据，将首次传输填充至对齐，填充数据使用WSTRB信号标记为无效。<img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/unaligned_transfer.png" alt="unaligned_transfer"></li></ul><p>上图是在64位宽的数据总线上传输突发传输位宽为32bit的数据，起始地址为0x07，其中阴影部分是不传输的数据（WSTRB=0）</p><h4 id="混合大小端传输"><a href="#混合大小端传输" class="headerlink" title="混合大小端传输"></a>混合大小端传输</h4><p>内存中有两种大小端模式，<strong>大端认为高字节（MSB）应该存在低地址，小端认为低字节（LSB）才应该存在低地址。</strong></p><p>为使大小端模式在存储中共存，AXI协议设计了一种字节顺序恒定的（Byte-invariant）的大小端传输方案：</p><ul><li>无论大小端模式，每个数据结构存储空间的分配方式是相同的；</li><li>大小端仅决定低地址是高字节还是低字节，与数据无关；</li><li>在传输过程中不考虑数据的大小端，<strong>按字节原先存储的顺序，原样传输并存放至对面</strong>；</li></ul><p>这样做的意义在于传输双方均不对数据结构的大小端进行解析，而严格按照字节的存储顺序进行传输并转存。</p><h3 id="读写回复结构"><a href="#读写回复结构" class="headerlink" title="读写回复结构"></a>读写回复结构</h3><p>读写传输事务（Transaction）都存在2bit位宽的回复信号RRESP/BRESP，分别存在4种回复情况，分别为：</p><ol><li>OKAY，常规访问成功；</li><li>EXOKAY，独占访问成功；</li><li>SLVERR，从机错误，尽管从机收到了访问请求，但因种种原因向主机返回了一个错误状态，可能包括以下错误场景：FIFO或缓冲区溢出；主机发起了不支持的传输位宽；尝试向读保护的地址写入数据；超时；</li><li>DECERR，解码错误，一般由interconnect组件产生，表示主机发送的传输事务地址无效，无法将传输事务发送给某个从机。</li></ol><p>协议转换的使用中忽视回复信号，默认都是OKAY。</p><h3 id="AxCACHE信号，缓存相关"><a href="#AxCACHE信号，缓存相关" class="headerlink" title="AxCACHE信号，缓存相关"></a>AxCACHE信号，缓存相关</h3><p>含义可参考<a href="https://zhuanlan.zhihu.com/p/148813963">深入AXI4总线</a></p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AxCACHE.png" alt="AxCACHE"></p><p><strong>Modifiable</strong></p><ul><li>单个传输事务可以被<strong>分解</strong>为多个传输事务</li><li>同理，多个传输事务也可被<strong>聚合</strong>为一个</li><li>读传输事务中，可以<strong>预取</strong>相邻地址上的读数据，要求目的地址返回比主机需求更多的数据</li><li>写传输事务中，可以<strong>访问比需求地址跨度更大的区域</strong>，其中使用 WSTRB 信号防止更新不相关的数据</li></ul><p><strong>cache-allocate</strong></p><p><strong>allocate</strong></p><p>当前地址的数据可能因为前期的访问，已经分派空间并缓存于 cache 中</p><p><strong>other allocate</strong></p><p>当前地址的数据可缓存于 cache 中，是因为其他主机事务而分派空间缓存，或者是本机其他类型的事务而缓存。（对于读事务来说，就是先前的写事务，反之亦然）</p><ul><li>当AxCACHE的高两bit为2‘b00时，表示CPU指示该传输事务<strong>无需</strong>至CACHE中查找，<strong>必须直接</strong>从主存储中读取或写入主存储；</li><li>当AxCACHE的高两bit为2’b11时，表示该传输事务必须<strong>首先</strong>在CACHE中查找，<strong>缺失的情况下</strong>再访问主存储。</li></ul><p><strong>Bufferable</strong></p><p>表示该传输事务在传输至目的地的途中，<strong>可以被 interconnect 或者任意的 AXI 组件缓存</strong>，延迟若干个周期。一般应用于写传输事务。</p><p>注：Write-through访问与Write-back访问的区别，<strong>Write-through</strong>指缓存的写入策略为直写，即<strong>数据写入缓存的同时，也写入主存储器中</strong>；<u>Write-back</u>指缓存的写入策略为写回，<u>数据仅写入缓存，修改的缓存仅在被替换时写入主存储</u>。</p><h3 id="超前传输"><a href="#超前传输" class="headerlink" title="超前传输"></a>超前传输</h3><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_axi.jpg" alt="outstanding_axi"></p><p>超前传输是指主机在当前传输事务完成前，就可以开始下一个传输事务。因此<strong>系统中可能存在多个进行中的传输事务。</strong>AXI从机可选地支持超前传输，假设从机不支持超前传输，<strong>只需要在接收到第一次Burst请求后置低AxREADY信号就可以阻止主机超前传输</strong>。</p><blockquote><p>从应用角度来思考这个问题，如传输一段数据，假设没有outstanding，必须要等到地址握手成功了才可以传输数据，而每一次握手过程中都不能保证主从机此刻都准备好，那这样在数据传输过程中就难免会有气泡，难以实现真正的全流水和高性能；所以从设计的角度，我们就有多发几个地址的需求，比如我们可以发出去10个地址，尽管我们还没给数据，但是可以让从机知道，我们接下来要向这些地址写数据，这样就可以不用刻板地遵循，每次都要写地址握手成功再写数据。</p><p>所以，outstanding就是发出去的地址数量，未处理的地址可以先存放在AXI总线的缓存里，等完成一次传输事物之后，无需再握手传输地址，即可立即进行下一次的数据传输，所以outstanding本质上是为了实现数据传输的pipeline。</p></blockquote><p>使用超前传输深度（outstanding depth）这一指标，衡量一个主机超前传输的能力，表示主机正在进行中的事务数量。<strong>更大的超前传输深度需要更大的缓冲区</strong>用于保存在途事务的信息，并接受缓存读数据。<strong>通过较大的超前传输深度能够提高系统的性能。</strong></p><p>在超前传输<strong><u>且支持交织功能</u></strong>的情况中，事务到达顺序与数据就绪顺序是可能不一致的，所以<strong>超前传输需要相应的机制来标识数据所属的事务。</strong>AXI协议在各通道设计了ID信号。</p><ul><li>主机制定并发送：AWID、ARID用于标识传输事务；</li><li>从机制定并发送：RID、BID用于标识数据或者回复，代表传输事务已完成；</li></ul><p>以<strong>读事务为例</strong>，协议规定：</p><p>1、<strong>对于ARID一致的多个事务，从机必须按照接收事务的顺序返回其读取的数据</strong>；</p><p>实现中可以为每个ARID维护一个缓冲区用于维护读数据的顺序；</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_exp1.png" alt="outstanding_exp1"></p><p>上图就是先读出RDATA1，再读出RDATA0，与接收事务的顺序不一致，需要<u><strong>数据缓冲区与事务缓冲区</strong></u>的地址匹配后才能进行输出。</p><p>2、<strong>具有不同ARID的事务之间可以乱序</strong>，从机只需要维护各个ARID所属事务的返回顺序。<strong>注意RID要与其对应事务的ARID保持一致。</strong></p><p>对于支持不同ARID的从机来说，实现上为每个ARID准备了一个事务与数据缓冲区，就绪数据可以根据RID分配至匹配的处理模块。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_exp2.png" alt="outstanding_exp2"></p><p>写事务与读事务类似：1、对于<strong>相同AWID的写事务</strong>，从机必须按照主机发出的顺序完成，包括发送的写回复（BID）信号；2、对于<strong>不同的AWID的写事务</strong>，从机完成的顺序没有限制；</p><blockquote><p>tips：面试问题</p><p>ID信号对于Outstanding是必须的吗？答：非必须，当没有乱序传输功能时可以省略ID信号，slave端依序即可。</p></blockquote><h3 id="多主机场景（Interconnect）"><a href="#多主机场景（Interconnect）" class="headerlink" title="多主机场景（Interconnect）"></a>多主机场景（Interconnect）</h3><p>在多主机场景下，如何将多主机的事务独立开是个大问题，有两种办法：</p><ul><li>各主机保证自己的ID与其他主机不同；</li><li>中间节点对不同主机的ID进行调整，即使主机发出的ID一致，也能使从机看到的ID不同；</li></ul><p>第一种方法看起来容易，一旦ID不同事务自然独立，但协议并<strong>没有在主机间设立消息共享机制</strong>，因此各主机无法知道其他主机所使用的ID，也就无法保证ID不同。</p><p>第二种方法是AXI协议采用的方法，中间的节点指AXI Interconnect组件或者AXI Smartconnect组件。对于Interconnect组件而言：</p><ul><li>任何主机事务前往任何从机必定经过Interconnect；</li><li>Interconnect可以从事务的来源端口，判断事务来自哪台主机；</li><li>当接收到从机返回的数据后，Interconnect根据其附加在其RID/BID上的主机端口信息，转发至发起事务的主机；</li></ul><p>Interconnect的另一个功能是<strong>仲裁</strong>，<strong>决定当前从哪个非空的缓冲区读取事务，输入交换结构</strong>。Interconnect的仲裁共有两种策略：1、轮询：轮流从各个主机的缓存通道读取事务；2、优先级仲裁：优先读取高优先级缓存通道中的事务。</p><p>此外，Interconnect还负责<strong>数据的重排序</strong>功能，由Interconnect负责保证数据返回主机的顺序，与主机发出事务的顺序一致，这要求Interconnect具有同从机类似的缓存功能以实现重排序。</p><hr><p><strong>Interconnect功能小总结</strong>：</p><ul><li>转发：ID</li><li>仲裁：轮询、优先级</li><li>重排序：事务、数据缓冲区</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.zhihu.com/column/c_1251094110297509888">AMBA Learning Hub</a></p><p><a href="https://developer.arm.com/documentation/ihi0022/latest">AMBA AXI Spec</a></p><p><a href="https://blog.csdn.net/lyfwill/article/details/92797912">跨4K问题</a></p><p><a href="https://blog.csdn.net/hit_shaoqi/article/details/53243173">AXI中模棱两可的概念</a></p>]]></content>
    
    
    <summary type="html">AXI协议概述</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="AXI" scheme="http://david-luge.cn/categories/IC/AXI/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>AXI4与AXI3的区别</title>
    <link href="http://david-luge.cn/2024/04/15/IC/AXI/AXI4%E4%B8%8EAXI3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://david-luge.cn/2024/04/15/IC/AXI/AXI4%E4%B8%8EAXI3%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-04-15T03:39:39.000Z</published>
    <updated>2024-04-15T03:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AXI3和AXI4区别-思维导图"><a href="#AXI3和AXI4区别-思维导图" class="headerlink" title="AXI3和AXI4区别-思维导图"></a>AXI3和AXI4区别-思维导图</h2><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI%E5%8C%BA%E5%88%AB.png" alt="AXI区别"></p><h3 id="Brust-support"><a href="#Brust-support" class="headerlink" title="Brust support"></a>Brust support</h3><p>AX4对burst length进行了扩展：</p><p>AXI3最大burst length是16 beats；AxLEN位宽是4bit</p><p>AXI4支持最大到256 beats，AxLEN位宽是8bit；但是这也是有限制的：</p><ol><li>只有INCR burst type支持超过16 beats的Burst；WRAP and FIXED burst types 最大还是支持16 beats的Burst，和AXI3保持一致；</li><li>Exclusive accesses 的burst length 必须小于 16.</li></ol><p>在实际使用中，很少使用支持超过Burst Length超过16的命令，因为Burst Length太长会一直占用总线，影响了系统性能；而且AXI总线的一个限制就是Burst一旦开始是不能取消的，如果Burst太长，一旦出错，影响比较大。</p><h3 id="AxCACHE-Update"><a href="#AxCACHE-Update" class="headerlink" title="AxCACHE Update"></a>AxCACHE Update</h3><p>AXI3中AxCACHE的含义</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI3_Axcache.png" alt="AXI3_Axcache"></p><p>AXI4中AxCACHE的含义</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI4_Axcache.png" alt="AXI4_Axcache"></p><p>含义可参考<a href="https://zhuanlan.zhihu.com/p/148813963">深入AXI4总线</a></p><p><strong>Modifiable</strong></p><ul><li>单个传输事务可以被分解为多个传输事务</li><li>同理，多个传输事务也可被聚合为一个</li><li>读传输事务中，可以预取相邻地址上的读数据，要求目的地址返回比主机需求更多的数据</li><li>写传输事务中，可以访问比需求地址跨度更大的区域，其中使用 WSTRB 信号防止更新不相关的数据</li></ul><p><strong>cache-allocate</strong></p><p><strong>allocate</strong></p><p>当前地址的数据可能因为前期的访问，已经分派空间并缓存于 cache 中</p><p><strong>other allocate</strong></p><p>当前地址的数据可缓存于 cache 中，是因为其他主机事务而分派空间缓存，或者是本机其他类型的事务而缓存。（对于读事务来说，就是先前的写事务，反之亦然）</p><ul><li>当AxCACHE的高两bit为2‘b00时，表示CPU指示该传输事务<strong>无需</strong>至CACHE中查找，<strong>必须直接</strong>从主存储中读取或写入主存储；</li><li>当AxCACHE的高两bit为2’b11时，表示该传输事务必须<strong>首先</strong>在CACHE中查找，<strong>缺失的情况下</strong>再访问主存储。</li></ul><p><strong>Bufferable</strong></p><p>表示该传输事务在传输至目的地的途中，可以被 interconnect 或者任意的 AXI 组件缓存，延迟若干个周期。一般应用于写传输事务。</p><h3 id="Addition-write-response-requirements"><a href="#Addition-write-response-requirements" class="headerlink" title="Addition write response requirements"></a>Addition write response requirements</h3><p>AXI3:must wait for both WVALID and WREADY to be asserted before asserting BVALID.</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI3_Write.png" alt="AXI3_Write"></p><p>AXI4:must wait for AWVALID、AWREADY、WVALID、WREADY、and WLAST to be asserted before asserting BVALID.</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI4_Write.png" alt="AXI4_Write"></p><p>AXI3对BVALID的规定其实是有漏洞的，可能Transaction还未真正完成就发送了写响应。AXI4的更新更加合理和严谨。</p><h3 id="Write-interleaving"><a href="#Write-interleaving" class="headerlink" title="Write interleaving"></a>Write interleaving</h3><p>AXI4协议去掉了WID信号，因此不支持写交错。这是AXI4和AXI3一个很重要的改变。</p><p>写交错的去除使得在WID信号上传递的信息是多余的。因为所有写入数据必须与相关的写入地址顺序相同，任何需要WID信息的部件都可以从写地址通道的AWID中获得这些信息。</p><p>写交错即指在AWID=0的数据还未发送完后，允许AWID=1的数据先发送；这样带来的代价是发送端必须要缓存多个ID的wdata，不管是master还是总线interconnect都必须要增加大量的缓存，所以增加了面积。</p><p>此外，写交错增加了系统总线设计的复杂度，且容易造成死锁。所以AXI4就把写交错功能去掉了。</p><h3 id="Locked-transactions"><a href="#Locked-transactions" class="headerlink" title="Locked transactions"></a>Locked transactions</h3><p>AXI4去掉了对locked transaction的支持，对信号的影响就是AxLOCK从AXI3的2-bits减少到了1bit</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI3_lock.png" alt="AXI3_lock"></p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI4_lock.png" alt="AXI4_lock"></p><p>为什么去掉Locked Access呢？按手册的说法(A7.3)，有如下原因</p><ul><li>大部分组件用不到这个功能</li><li>有Locked Access的话会增加互联(interconnect)的复杂性</li></ul><p>Locked Access和Exclusive access有哪些区别呢？其实最主要的区别是作用的对象不同。</p><p>Locked Access作用的对象为总线，一旦发生Locked Access，那么其它的master都不能通过总线对该Slave进行访问。在一个复杂的SOC系统中，Locked Access对系统的影响太大了。万一发出Locked Access的master出问题，那么系统就会挂死。这种牺牲整个系统来成就某个master的机制当然最后会被淘汰。</p><p>Exclusive Access作用的对象为对应的Slave，支持Exclusive Access的Slave会实现一个monitor，记录发起Exclusive Access的master的ID，并记录后续发起写过程的master的ID号，进行对比。Exclusive Access对总线系统是没有要求的，只是对slave做了特殊要求。即使出错也不会影响系统的其它部分，最多是Exclusive Access失败而已。</p><h3 id="Quality-of-service-signaling"><a href="#Quality-of-service-signaling" class="headerlink" title="Quality of service signaling"></a>Quality of service signaling</h3><p>AXI4增加了2个4bit的QoS命令信号AWQoS、ARQoS。但是AXI4协议没有规定QoS的用法，因为这是一个需要全面考虑的特性。AXI4建议的QoS是AxQoS值越大，优先级越高。</p><p>增加QoS信号是随着越来越多的master对总线需求的冲突越来越明显，系统的带宽没有显著提升。那么如何给不同的IP分配不同QoS就是架构师需要考虑的事情，且没有不变的规律可以遵守。</p><h3 id="Region-Signals"><a href="#Region-Signals" class="headerlink" title="Region Signals"></a>Region Signals</h3><p>AXI4为了支持区域标识，增加了AxREGION信号。区域标识符的使用意味着slave不必支持不同逻辑接口之间的地址解码。一般情况下使用地址的高位来区分不同的区域，而采用了区域标识符就不用采用地址解码区分了。另外，通过划分region，对某些physical allocation进行保护，比如某个region能被读写，而某个region只提供读权限。</p><p>这是一个可选的功能，ARM自己的CPU都很少支持。</p><h3 id="USER-signals"><a href="#USER-signals" class="headerlink" title="USER signals"></a>USER signals</h3><p>AMBA4中未对USER信号做任何规定，只是建议不要使用这个信号，防止IP直接互联不兼容。一般的IP厂商都不会使用，防止兼容性问题。</p><h2 id="AXI3和AXI4的互联"><a href="#AXI3和AXI4的互联" class="headerlink" title="AXI3和AXI4的互联"></a>AXI3和AXI4的互联</h2><p>我们分下面两种情况讨论</p><h3 id="AXI4-master连接到AXI3-slave"><a href="#AXI4-master连接到AXI3-slave" class="headerlink" title="AXI4 master连接到AXI3 slave"></a>AXI4 master连接到AXI3 slave</h3><ol><li>因为AXI4没有WID信号，而AXI3有。但我们还不能直接把AXI4 Master的AWID直连到AXI3 slave的WID上，因为如果AXI4 master能发出outstanding的命令，当前的AWID的值和WID的值就不是对应的关系。通常的做法是将AWID缓存到一个FIFO钟，等到传完数据(收到了WLAST)再切换到下一个AWID，把这样读出的AWID当做WID使用。</li><li>AXI3的AxLOCK信号是2bit的，直接将AXI3的AxLOCK信号的最低位连接到master上即可</li><li>AXI4 master不能产生超过16beat的brust，因为AXI3不支持。</li><li>系统总线要么统一用AXI3，要么统一用AXI4。</li><li>AXI3 slave必须注意BVALID的生成要符合AXI4协议，需要修改逻辑。</li><li>QoS、USER、REGION等多余的信号需做额外的处理，一般赋默认值。</li></ol><h3 id="AXI3-master连接到AXI4-slave"><a href="#AXI3-master连接到AXI4-slave" class="headerlink" title="AXI3 master连接到AXI4 slave"></a>AXI3 master连接到AXI4 slave</h3><ol><li>由于AXI4是没有WID信号的，所以直接把WID浮空就行；</li><li>AXI4 Slave的AxLOCK[0]连接到AXI3 master的AxLOCK即可；</li><li>AXI4 Slave的AxLEN[7:4]=4’h0 即可；</li><li>系统总线要么统一用AXI3, 要么统一用AXI4;</li><li>QOS/USER/REGION信号等多余的信号需要做额外的处理；</li><li>AXI3 master必须不能支持Write interleaving，否则必须修改AXI3 master的逻辑。</li></ol><h2 id="AXI接口部分名词解释"><a href="#AXI接口部分名词解释" class="headerlink" title="AXI接口部分名词解释"></a>AXI接口部分名词解释</h2><h3 id="outstanding"><a href="#outstanding" class="headerlink" title="outstanding"></a>outstanding</h3><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_axi.jpg" alt="outstanding_axi"></p><h3 id="interleaving"><a href="#interleaving" class="headerlink" title="interleaving"></a>interleaving</h3><p>AXI3中有，AXI4中被删除。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/interleave_axi3.png" alt="interleave_axi3"></p><h3 id="out-of-order"><a href="#out-of-order" class="headerlink" title="out-of-order"></a>out-of-order</h3><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/out_of_order.png" alt="out_of_order"></p><h2 id="AXI-Full-vs-AXI-Lite"><a href="#AXI-Full-vs-AXI-Lite" class="headerlink" title="AXI Full vs AXI Lite"></a>AXI Full vs AXI Lite</h2><p>AXI Lite是AXI Full协议的简化版，主要区别在以下几点</p><ol><li>突发长度固定为1；</li><li>数据通路要将数据位宽用满(不支持narrow transfer)，还可以使用WSTRB信号，数据位宽可选32或64；</li><li>所有的访问都是Non-modifiable、Non-bufferable；</li><li>不支持Exclusive access；</li></ol>]]></content>
    
    
    <summary type="html">简述AXI4与AXI3的区别</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="AXI" scheme="http://david-luge.cn/categories/IC/AXI/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>Verilog-Mode入门</title>
    <link href="http://david-luge.cn/2024/04/13/IC/EDA/Verilog-Mode%E5%85%A5%E9%97%A8/"/>
    <id>http://david-luge.cn/2024/04/13/IC/EDA/Verilog-Mode%E5%85%A5%E9%97%A8/</id>
    <published>2024-04-13T13:10:39.000Z</published>
    <updated>2024-04-13T13:10:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog-Mode"><a href="#Verilog-Mode" class="headerlink" title="Verilog Mode"></a>Verilog Mode</h1><h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>Verilog-mode是Emacs的一种编辑模式，主要面对verilog的开发环境，拥有很方便的自动缩进机制和AUTO机制。AUTO机制是Emacs verilog-mode中一些自动化实现脚本的功能，比如自动填充模块参数列表、自动完成模块例化、自动声明连线等。非常适合顶层模块集成使用，避免Designer的重复劳动和低级错误。</p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>verilog语法中有很多内容是冗余的，模块中必须出现却起不到什么功能作用，列举如下：</p><ul><li>模块参数列表和模块端口声明input/output；</li><li>reg语句和已经被声明为输出的信号；</li><li>子模块实例化的连线声明；</li><li>子模块的实例化语句和子模块的端口声明；</li><li>组合逻辑always语句的敏感信号列表（不过已经可以使用*来代替了）；</li></ul><p>可见verilog语法中的冗余信息还是不少的，不过这是语法规则导致的，是语言本身的缺陷，作为使用者只能遵守语法规则。这些冗余信息中比如参数列表和模块例化连线，不仅需要花费时间去编写，而且还特别容易出错，给RTL编写以及后续的修改维护都带来很多问题。那么如果解决这些问题，会带来什么效果呢？个人认为有以下几点：</p><ul><li>代码整洁，便于阅读；</li><li>提高编码效率，尤其是顶层实例化；</li><li>减少拼写错误；</li><li>便于维护，比如修改、增加和删除端口，无需修改参数列表，比如修改、增加和删除子模块端口，无需修改顶层实例化；</li></ul><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>Emacs verilog-mode的AUTO机制，就是在代码中相应的位置写一些/<em>AUTO</em>/类似的注释，verilog-mode可以自动替换为所需的内容。Emacs编辑器和verilog-mode的AUTO机制结合，可以很方便的看到AUTO的效果，而且AUTO是以注释形式添加到verilog文件，在语法上本身是合法的，不会影响EDA工具的使用。这个环境也可以在Vim编辑器下使用，举例如下：</p><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><ol><li>不想写入数据的输入输出信号列表、组合逻辑的敏感信号列表；</li></ol><blockquote><p>/*AUTOARG*/：自动生成模块参数表；</p><p>/*AUTOSENSE*/ or /*AS*/：自动生成组合逻辑的敏感信号列表；（在verilog 2000中，已经对语法做出了简化，比如使用@(<em>)来代替敏感信号列表，但是需要EDA工具的支持。不过现在EDA工具都已经支持verilog 2005了，可以将敏感信号列表直接写为@(\</em>)即可，所以AUTOSENSE功能可以不使用。）</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> auto_arg_as(<span class="comment">/*AUTOARG*/</span>);</span><br><span class="line"><span class="keyword">input</span> a;</span><br><span class="line"><span class="keyword">input</span> b;</span><br><span class="line"><span class="keyword">input</span> c;</span><br><span class="line"><span class="keyword">output</span> d;</span><br><span class="line"><span class="comment">/*AUTOREG*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="comment">/*AS*/</span>)</span><br><span class="line">d = a ^ b ^ c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//After Auto</span></span><br><span class="line"><span class="keyword">module</span> auto_arg_as(<span class="comment">/*AUTOARG*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line">d,</span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line">a, b, c</span><br><span class="line">);</span><br><span class="line"><span class="keyword">input</span> a;</span><br><span class="line"><span class="keyword">input</span> b;</span><br><span class="line"><span class="keyword">input</span> c;</span><br><span class="line"><span class="keyword">output</span> d;</span><br><span class="line"><span class="comment">/*AUTOREG*/</span></span><br><span class="line"><span class="comment">// Beginning of automatic regs (for this module&#x27;s undeclared outputs)</span></span><br><span class="line"><span class="keyword">reg</span> d;</span><br><span class="line"><span class="comment">// End of automatics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="comment">/*AS*/</span>a <span class="keyword">or</span> b <span class="keyword">or</span> c)</span><br><span class="line">d = a ^ b ^ c;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ol><li>不想写内部的wire、reg数据类型定义；</li></ol><blockquote><p>/*AUTOWIRE*/：自动补全wire的定义，在重复例化模块时使用，会将内部连线的信号自动生成wire定义；（注意只在重复例化的时候使用，设计功能模块时勿用）</p><p>/*AUTOREG*/：会将reg类型的output信号补全reg的定义；</p></blockquote><h2 id="自动例化与连线"><a href="#自动例化与连线" class="headerlink" title="自动例化与连线"></a>自动例化与连线</h2><ol><li>不想例化重复的模块；</li></ol><p>如果一个模块被实例化多次，你可以使用verilog的generate语法，也可以使用Emacs verilog-mode的<strong>AUTO_TEMPLATE</strong> 和 <strong>AUTO_INST</strong> 。Verilog-mode向上索引最近的模板，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。</p><blockquote><p>/*AUTO_TEMPLATE*/：TEMPLATE中的模块名称必须与实例中的模块名称相同，并且只需列出每次实例化时不同的那些信号就好了，要遵守此格式（每行只有一个端口，并且以逗号结尾，最后以分号结尾）</p><p>/*AUTOINST*/：如果没有/*AUTO_TEMPLATE*/，则/*AUTOINST*/会自动补全信号列表，默认实例化的端口名与子模块的端口名一致，如果不一致需要手动将不一致的端口连线，/*AUTOINST*/不会重复覆盖；如果有/*AUTO_TEMPLATE*/，Verilog-mode会向上索引最近的模板，按模板的格式进行例化，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。</p><p>/*AUTOINSTPARAM*/：在实例化时自动填充参数列表；</p><p>/*AUTOINPUT*/、/*AUTOOUTPUT*/：在top层中，一般只有子模块的例化，没有任何其它粘合逻辑，这也是最好的。这时top层通过 <strong>AUTOWIRE</strong> 声明了子模块的输出连线，<strong>AUTOINST</strong> 实现了子模块的实例化，其余未声明的信号，就是top模块的输入输出信号，我们可以通过  <strong>AUTOINPUT AUTOOUTPUT</strong> 完成输入输出信号的声明。特别注意Top层仅做例化，不包括其他逻辑。</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> submod(<span class="comment">/*AUTOARG*/</span>);</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>]  in_a;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>]  in_b;</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  out_a;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  out_b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> out_a = in_a ^ in_b;</span><br><span class="line"><span class="keyword">assign</span> out_b = in_a | in_b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> submod_wrapper0(<span class="comment">/*AUTOARG*/</span>);</span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">I/O</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOINPUT*/</span></span><br><span class="line"><span class="comment">/*AUTOOUTPUT*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Signal</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOWIRE*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Inst</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(din_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_stage1_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_0(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(dout_stage1_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_stage2_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_1(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(dout_stage2_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_2(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//Local Variables:</span></span><br><span class="line"><span class="comment">//verilog-library-directories:(&quot;.&quot;)</span></span><br><span class="line"><span class="comment">//End:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************************</span></span><br><span class="line"><span class="comment">//                     After Auto</span></span><br><span class="line"><span class="comment">//**********************************************************</span></span><br><span class="line"><span class="keyword">module</span> submod_wrapper0(<span class="comment">/*AUTOARG*/</span></span><br><span class="line"><span class="comment">//Outputs</span></span><br><span class="line">dout_b, dout_a,</span><br><span class="line"><span class="comment">//Inputs</span></span><br><span class="line">din_b, din_a</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">I/O</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOINPUT*/</span></span><br><span class="line"><span class="comment">//Beginning of automatic inputs (from unused autoinst inputs)</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_a;    <span class="comment">// To u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_b;    <span class="comment">// To u_submod_0 of submod.v</span></span><br><span class="line"><span class="comment">//End of automatics</span></span><br><span class="line"><span class="comment">/*AUTOOUTPUT*/</span></span><br><span class="line"><span class="comment">//Beginning of automatic outputs (from unused autoinst outputs)</span></span><br><span class="line">  <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_a;    <span class="comment">// To u_submod_2 of submod.v</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_b;    <span class="comment">// To u_submod_2 of submod.v</span></span><br><span class="line"><span class="comment">//End of automatics</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Signal</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOWIRE*/</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]    dout_stage1_a;    <span class="comment">//From u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]    dout_stage1_b;    <span class="comment">//From u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]    dout_stage2_a;    <span class="comment">//From u_submod_1 of submod.v</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]    dout_stage2_b;    <span class="comment">//From u_submod_1 of submod.v</span></span><br><span class="line"><span class="comment">//End of automatics</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Inst</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(din_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_stage1_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_0(<span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line"><span class="variable">.out_a</span>    (dout_stage1_a[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.out_b</span>    (dout_stage1_b[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line"><span class="variable">.in_a</span>    (din_a[<span class="number">1</span>:<span class="number">0</span>]),           <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.in_b</span>    (din_b[<span class="number">1</span>:<span class="number">0</span>])            <span class="comment">// Templated</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(dout_stage1_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_stage2_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_1(<span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line"><span class="variable">.out_a</span>    (dout_stage2_a[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.out_b</span>    (dout_stage2_b[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line"><span class="variable">.in_a</span>    (dout_stage1_a[<span class="number">1</span>:<span class="number">0</span>]),   <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.in_b</span>    (dout_stage1_b[<span class="number">1</span>:<span class="number">0</span>])    <span class="comment">// Templated</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(dout_stage2_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_2(<span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line"><span class="variable">.out_a</span>    (dout_a[<span class="number">1</span>:<span class="number">0</span>]),         <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.out_b</span>    (dout_b[<span class="number">1</span>:<span class="number">0</span>]),         <span class="comment">// Templated</span></span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line"><span class="variable">.in_a</span>    (dout_stage2_a[<span class="number">1</span>:<span class="number">0</span>]),   <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.in_b</span>    (dout_stage2_b[<span class="number">1</span>:<span class="number">0</span>])    <span class="comment">// Templated</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//Local Variables:</span></span><br><span class="line"><span class="comment">//verilog-library-directories:(&quot;.&quot;)</span></span><br><span class="line"><span class="comment">//End:</span></span><br></pre></td></tr></table></figure><h3 id="取消输出"><a href="#取消输出" class="headerlink" title="取消输出"></a>取消输出</h3><p>比如我们尝试在TOP模块做一个glue logic，将两个模块的输出接口（如a_dfx[15:0]和b_dfx[15:0]）组合为一个输出接口（dfx[31:0]）进行输出。如果使用/*AUTOOUTPUT*/方法，会将a_dfx[15:0]，b_dfx[15:0]也放到输出口，此时我们就需要<strong>verilog-auto-output-ignore-regexp</strong>方法来对这类接口进行特殊处理，避免将其放到输出端口上。代码示例如下，其中将匹配到‘_dfx’的信号全部ignore。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> abc(<span class="comment">/*AUTOARG*/</span>);</span><br><span class="line"><span class="comment">/*AUTOINPUT*/</span></span><br><span class="line"><span class="comment">/*AUTOOUTPUT*/</span></span><br><span class="line"><span class="comment">/*AUTOWIRE*/</span></span><br><span class="line"><span class="keyword">assign</span> dfx = &#123;a_dfx[<span class="number">15</span>:<span class="number">0</span>], b_dfx[<span class="number">15</span>:<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="keyword">module</span> u_1(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"><span class="keyword">module</span> u_2(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//Localvariables:</span></span><br><span class="line"><span class="comment">//verilog-auto-output-ignore-regexp:(&quot;_dfx&quot;)</span></span><br><span class="line"><span class="comment">//END:</span></span><br></pre></td></tr></table></figure><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>在顶层实例化时，有大量的信号需要重新命名，使用模板的话会增加大量的注释内容，不过往往这些信号命名有特定的规律，我们可以使用正则表达式来处理；</p><p>@在正则匹配中匹配到例化名称中最前面的连续数字；建议使用 @ 来匹配例化名称中的数字，使用正则来匹配信号中的数字；</p><blockquote><p>@ in the template takes the leading digits from the reference.</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取信号中固定位置的数字</span></span><br><span class="line"><span class="variable">.pci_req</span>\([<span class="number">0</span>-<span class="number">9</span>]+\)_j   (pci_req_jtag_[\<span class="number">1</span>]),</span><br><span class="line"><span class="variable">.pci_req12_j</span>           (pci_req_jtag_[<span class="number">12</span>]),</span><br><span class="line"><span class="comment">//---------------------------------------------</span></span><br><span class="line"><span class="comment">// 删除末尾下划线内容</span></span><br><span class="line">.\(.*\)_j              (\<span class="number">1</span>[]),</span><br><span class="line"><span class="variable">.pci_req_j</span>             (pci_req[<span class="number">7</span>:<span class="number">0</span>]),</span><br><span class="line"><span class="comment">//---------------------------------------------</span></span><br><span class="line"><span class="comment">// 对信号矢量化处理(将@改为\([0-9]+\)也是可以的)</span></span><br><span class="line">.\(.*[^<span class="number">0</span>-<span class="number">9</span>]\)@    (\<span class="number">1</span>[\<span class="number">2</span>]),</span><br><span class="line"><span class="variable">.pci_req0</span>         (pci_req[<span class="number">0</span>]),</span><br><span class="line"><span class="variable">.pci_req1</span>         (pci_req[<span class="number">1</span>]),</span><br><span class="line"><span class="variable">.pci_req2</span>         (pci_req[<span class="number">2</span>]),</span><br><span class="line"><span class="variable">.pci_req3</span>         (pci_req[<span class="number">3</span>]),</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> submod_wrapper1(<span class="comment">/*AUTOARG*/</span>);</span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">I/O</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOINPUT*/</span></span><br><span class="line"><span class="comment">/*AUTOOUTPUT*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Signal</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOWIRE*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Inst</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(din_\1_@[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_\1_@[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_0(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(din_\1_@[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_\1_@[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_1(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(din_\1_@[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_\1_@[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_2(<span class="comment">/*AUTOINST*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//Local Variables:</span></span><br><span class="line"><span class="comment">//verilog-library-directories:(&quot;.&quot;)</span></span><br><span class="line"><span class="comment">//End:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************************</span></span><br><span class="line"><span class="comment">//                     After Auto</span></span><br><span class="line"><span class="comment">//**********************************************************</span></span><br><span class="line"><span class="keyword">module</span> submod_wrapper1(<span class="comment">/*AUTOARG*/</span></span><br><span class="line"><span class="comment">//Outputs</span></span><br><span class="line">dout_b_2, dout_b_1, dout_b_0, dout_a_2, dout_a_1, dout_a_0,</span><br><span class="line"><span class="comment">//Inputs</span></span><br><span class="line">din_b_2, din_b_1, din_b_0, din_a_2, din_a_1, din_a_0</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">I/O</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOINPUT*/</span></span><br><span class="line"><span class="comment">//Beginning of automatic inputs (from unused autoinst inputs)</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_a_0;    <span class="comment">// To u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_a_1;    <span class="comment">// To u_submod_1 of submod.v</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_a_2;    <span class="comment">// To u_submod_2 of submod.v</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_b_0;    <span class="comment">// To u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_b_1;    <span class="comment">// To u_submod_1 of submod.v</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]  din_b_2;    <span class="comment">// To u_submod_2 of submod.v</span></span><br><span class="line"><span class="comment">//End of automatics</span></span><br><span class="line"><span class="comment">/*AUTOOUTPUT*/</span></span><br><span class="line"><span class="comment">//Beginning of automatic outputs (from unused autoinst outputs)</span></span><br><span class="line">  <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_a_0;    <span class="comment">// To u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_a_1;    <span class="comment">// To u_submod_1 of submod.v</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_a_2;    <span class="comment">// To u_submod_2 of submod.v</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_b_0;    <span class="comment">// To u_submod_0 of submod.v</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_b_1;    <span class="comment">// To u_submod_1 of submod.v</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  dout_b_2;    <span class="comment">// To u_submod_2 of submod.v</span></span><br><span class="line"><span class="comment">//End of automatics</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Signal</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*AUTOWIRE*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">Inst</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(din_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_stage1_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_0(<span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line"><span class="variable">.out_a</span>    (dout_a_0[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.out_b</span>    (dout_b_0[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line"><span class="variable">.in_a</span>    (din_a_0[<span class="number">1</span>:<span class="number">0</span>]),           <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.in_b</span>    (din_b_0[<span class="number">1</span>:<span class="number">0</span>])            <span class="comment">// Templated</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(dout_stage1_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_stage2_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_1(<span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line"><span class="variable">.out_a</span>    (dout_a_1[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.out_b</span>    (dout_b_1[<span class="number">1</span>:<span class="number">0</span>]),  <span class="comment">// Templated</span></span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line"><span class="variable">.in_a</span>    (din_a_1[<span class="number">1</span>:<span class="number">0</span>]),   <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.in_b</span>    (din_b_1[<span class="number">1</span>:<span class="number">0</span>])    <span class="comment">// Templated</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*submod AUTO_TEMPLATE(</span></span><br><span class="line"><span class="comment">.in_\(.*\)(dout_stage2_\1[]),</span></span><br><span class="line"><span class="comment">.out_\(.*\)(dout_\1[]),</span></span><br><span class="line"><span class="comment">);*/</span></span><br><span class="line">submod u_submod_2(<span class="comment">/*AUTOINST*/</span></span><br><span class="line"><span class="comment">// Outputs</span></span><br><span class="line"><span class="variable">.out_a</span>    (dout_a_2[<span class="number">1</span>:<span class="number">0</span>]),         <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.out_b</span>    (dout_b_2[<span class="number">1</span>:<span class="number">0</span>]),         <span class="comment">// Templated</span></span><br><span class="line"><span class="comment">// Inputs</span></span><br><span class="line"><span class="variable">.in_a</span>    (din_a_2[<span class="number">1</span>:<span class="number">0</span>]),   <span class="comment">// Templated</span></span><br><span class="line"><span class="variable">.in_b</span>    (din_b_2[<span class="number">1</span>:<span class="number">0</span>])    <span class="comment">// Templated</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//Local Variables:</span></span><br><span class="line"><span class="comment">//verilog-library-directories:(&quot;.&quot;)</span></span><br><span class="line"><span class="comment">//End:</span></span><br></pre></td></tr></table></figure><h2 id="获取模块路径"><a href="#获取模块路径" class="headerlink" title="获取模块路径"></a>获取模块路径</h2><p>现在我们可能会好奇，Verilog-Mode如何知道给定的模块声明的路径。</p><p>verillog-mode首先在当前文件中查找，以防您在那里定义了多个模块。然后它在verilog-library-extensions中查找带有每个扩展名的模块名，通常是一个’.v’。最后，它在每个定义了在verilog-library-directories的目录中搜索。</p><p>因此，如果我们有一个需要在子目录中查找子模块的顶级模块，我们需要告诉verilog-mode在子目录中查找。最好的方法是在每个需要库变量的Verilog文件的末尾定义它们：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Variables:</span></span><br><span class="line"><span class="comment">// verilog-library-directories:(&quot;.&quot; &quot;subdir&quot; &quot;subdir2&quot;)</span></span><br><span class="line"><span class="comment">// verilog-library-files:(&quot;/some/path/technology.v&quot; &quot;/some/path/tech2.v&quot;)</span></span><br><span class="line"><span class="comment">// verilog-library-extensions:(&quot;.v&quot; &quot;.h&quot;)</span></span><br><span class="line"><span class="comment">// End:</span></span><br></pre></td></tr></table></figure><p>这三个变量的作用如下:<br><code>verilog-library-directories</code><br>变量<code>verilog-library-directories</code>包含了要在其中查找模块的目录列表，至少应包含当前目录。<br><code>verilog-library-extension</code><br>变量<code>verilog-library-extensions</code>包含一个文件扩展名列表，试图将其附加到模块名以生成文件名。通常只是“.v”。<br><code>verilog-library-files</code><br>变量<code>verilog-library-files</code>包含一个文件列表，这些文件将完整地搜索模块。这通常是到技术文件的完整路径，其中定义了许多标准单元。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>verilog-mode还有其他实用的功能，不过掌握其20%的知识足够应付80%的场景了。其余的功能还包括缩进对齐，自动补齐复位信号等。不过还是建议只在顶层连线使用verilog-mode功能，内部的IP设计还是需要各Designer仔细检查。</p><p><a href="https://veripool.org/verilog-mode/help/">Verilog-Mode User Guide</a></p><p><a href="https://www.cnblogs.com/Alfred-HOO/articles/16366743.html">Verilog-Mode使用方法总结</a></p>]]></content>
    
    
    <summary type="html">Verilog-Mode工具扫盲</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="EDA" scheme="http://david-luge.cn/categories/IC/EDA/"/>
    
    
    <category term="EDA" scheme="http://david-luge.cn/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>聊聊git的revert</title>
    <link href="http://david-luge.cn/2024/04/08/Misc/%E8%81%8A%E8%81%8Agit%E7%9A%84revert/"/>
    <id>http://david-luge.cn/2024/04/08/Misc/%E8%81%8A%E8%81%8Agit%E7%9A%84revert/</id>
    <published>2024-04-08T12:00:00.000Z</published>
    <updated>2024-04-08T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的revert命令"><a href="#Git的revert命令" class="headerlink" title="Git的revert命令"></a>Git的revert命令</h1><p>git的revert命令用来取消某次特定的提交内容。</p><p>当我们使用revert命令时，需要考虑两种情况。因为commit就分两种类型：一种是常规的commit，也就是使用<code>git commit</code>命令得到的commit；另一种是merge commit，在使用<code>git merge</code>合并两个分支后，我们会得到一个新的merge commit。</p><p>merge commit和普通commit的不同之处在于，merge commit包含两个parent commit，代表merge commit是从哪两个commit合并而来。</p><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Snipaste_2024-04-07_21-58-15.png" alt="Snipaste_2024-04-07_21-58-15"></p><p>在上图所示的红框中有一个 merge commit，使用 <code>git show</code> 命令可以查看 commit 的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show 422ecbc</span></span><br><span class="line">commit 422ecbc384c9e091a4990789f890661055ae1c9e (HEAD -&gt; master)</span><br><span class="line">Merge: 26407b4 3d0cd1e</span><br></pre></td></tr></table></figure><p>这代表该 merge commit 是从 26407b4和 3d0cd1e两个 commit 合并过来的。</p><p>而常规的commit则没有“Merge”行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show b086f02</span></span><br><span class="line">commit b086f02120d257965a0d340d5442ad83df4c591f</span><br></pre></td></tr></table></figure><h2 id="revert常规commit"><a href="#revert常规commit" class="headerlink" title="revert常规commit"></a>revert常规commit</h2><p>使用<code>git revert &lt;commit id&gt;</code>即可，git 会生成一个新的 commit，将指定的 commit 内容从当前分支上撤销掉。</p><h2 id="revert-merge-commit"><a href="#revert-merge-commit" class="headerlink" title="revert merge commit"></a>revert merge commit</h2><p>revert merge commit 有一些不同，这时需要添加 <code>-m</code> 选项，用来表示这次 revert 的是一个merge commit</p><p>但如果直接使用 git revert，git 也不知道到底要撤除哪一条分支上的内容，这时需要指定一个 parent number 标识出”主线”，主线的内容将会保留，而另一条分支的内容将被 revert。</p><p>如上面的例子中，从 <code>git show</code> 命令的结果中可以看到，merge commit 的 parent 分别为 26407b4和 3d0cd1e，其中“26407b4”代表 master 分支（从图中可以看出），“3d0cd1e”代表DEV 分支。需要注意的是 -m 选项接收的参数是一个数字，数字取值为 1 和 2，也就是 Merge 行里面列出来的第一个还是第二个。</p><p>我们要 revert DEV 分支上的内容，即 保留主分支，应该设置主分支为主线，操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert -m 1 422ecbc</span><br></pre></td></tr></table></figure><h2 id="revert之后重新上线"><a href="#revert之后重新上线" class="headerlink" title="revert之后重新上线"></a>revert之后重新上线</h2><p>假设我们在自己的分支 david/a-cool-feature 上开发了一个功能，并合并到了 master 上，之后 master 上又提交了一个修改 h，这时提交历史如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="punctuation">-&gt;</span> b <span class="punctuation">-&gt;</span> c <span class="punctuation">-&gt;</span> f -- g <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">h</span> (master)</span><br><span class="line">           \      /</span><br><span class="line">            d <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">e</span>   (david/a-cool-feature)</span><br></pre></td></tr></table></figure><p>突然，大家发现David的分支存在严重的 bug，需要 revert 掉，于是大家把 g 这个 merge commit revert 掉了，记为 G，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="punctuation">-&gt;</span> b <span class="punctuation">-&gt;</span> c <span class="punctuation">-&gt;</span> f -- g <span class="punctuation">-&gt;</span> h <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">G</span> (master)</span><br><span class="line">           \      /</span><br><span class="line">            d <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">e</span>   (david/a-cool-feature)</span><br></pre></td></tr></table></figure><p>然后David回到自己的分支进行 bugfix，修好之后想重新合并到 master，<strong>直觉上</strong>只需要再 merge 到 master 即可，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="punctuation">-&gt;</span> b <span class="punctuation">-&gt;</span> c <span class="punctuation">-&gt;</span> f -- g <span class="punctuation">-&gt;</span> h <span class="punctuation">-&gt;</span> G <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">i</span> (master)</span><br><span class="line">           \      /               /</span><br><span class="line">            d <span class="punctuation">-&gt;</span> e <span class="punctuation">-&gt;</span> j <span class="punctuation">-&gt;</span> k ----    (david/a-cool-feature)</span><br></pre></td></tr></table></figure><p>i 是新的 merge commit。但需要注意的是，这 <strong>不能</strong> 得到我们期望的结果。因为现在的merge是基于G和k进行merge，又因为“d”和“e”两个提交曾经被“G”丢弃过，所以如此合并到 master 的代码，并不会重新包含“d”和“e”两个提交的内容，相当于只有 david/a-cool-feature 上的新 commit “j”和“k”被合并了进来，而 david/a-cool-feature 分支之前的内容，依然是被 revert 掉了。</p><p>所以，如果想恢复整个 david/a-cool-feature 所做的修改，应该先把“G” revert 掉：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="punctuation">-&gt;</span> b <span class="punctuation">-&gt;</span> c <span class="punctuation">-&gt;</span> f -- g <span class="punctuation">-&gt;</span> h <span class="punctuation">-&gt;</span> G <span class="punctuation">-&gt;</span> G&#x27; <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">i</span> (master)</span><br><span class="line">           \      /                     /</span><br><span class="line">            d <span class="punctuation">-&gt;</span> e <span class="punctuation">-&gt;</span> j <span class="punctuation">-&gt;</span> k ----------    (david/a-cool-feature)</span><br></pre></td></tr></table></figure><p>其中 G’ 是对 G 的 revert 操作生成的 commit，把之前撤销合并时丢弃的代码恢复了回来，然后再 merge david的分支，把解决 bug 写的新代码合并到 master 分支。</p>]]></content>
    
    
    <summary type="html">关于Git的revert命令</summary>
    
    
    
    <category term="Misc" scheme="http://david-luge.cn/categories/Misc/"/>
    
    <category term="Git" scheme="http://david-luge.cn/categories/Misc/Git/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="http://david-luge.cn/2024/04/01/Misc/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://david-luge.cn/2024/04/01/Misc/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-04-01T11:15:39.000Z</published>
    <updated>2024-04-01T11:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h2><p><a href="https://www.runoob.com/git/git-tutorial.html">Git教程|菜鸟教程</a><br><a href="https://git-scm.com/book/en/v2">Pro-Git</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此处主要是记录一些有用但之前自己所用较少的命令，并不包括一些最基础的命令，入门的话可以去看菜鸟教程的Git教程。</p><h2 id="记录仓库变动"><a href="#记录仓库变动" class="headerlink" title="记录仓库变动"></a>记录仓库变动</h2><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>要从 Git 中移除一个文件，必须先将其从跟踪文件中移除（更准确地说，是从暂存区域中移除），然后再提交。<code>git rm</code> 命令就能做到这一点，同时还能将文件从工作目录中移除，这样下次提交时就不会看到它是未跟踪文件了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line">rm &#x27;PROJECTS.md&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><br>Tips：可认为是rm file + git add file的结合体。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached README</span></span><br></pre></td></tr></table></figure><br><code>git rm --cached</code>命令的功能是将文件从 Git 的暂存区中移除，这样这些文件就不会被包含在下一次的提交中。然而，这些文件仍然会保留在你的工作目录中，这样你就可以继续对它们进行修改，而不会丢失文件的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>注意 * 前面的反斜线 ()，这是通配符的表达方式。这条命令会删除 log/ 目录下所有扩展名为 .log 的文件。</p><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>主要用于在仓库中重命名一个已跟踪的文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></table></figure><br>等价于下面的代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> file_from file_to</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> file_from</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file_to</span></span><br></pre></td></tr></table></figure></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>查看每次提交的简短统计信息，可以加上<code>--stat</code>选项；(常用)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><br>忽略所有merge的log，使用<code>--no-merges</code>选项；(常用)<br>查看特定路径或者文件的提交log；(常用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log file_name/location_name</span><br></pre></td></tr></table></figure><p>还可以使用<code>--pretty=format</code>定制化内容的输出格式；<br>或者使用<code>--pretty</code>选项搜寻满足特定条件的提交，可以包括对日期，作者，修改文件的约束；<br>使用<code>--graph</code>选项在日志旁以图形化方式显示分支和合并历史；</p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p><code>git reflog</code>是 Git 的一个命令，用于查看本地仓库中 HEAD 和分支的移动历史记录。它记录了本地仓库中的引用（reference）的变动情况，包括分支切换、提交、重置等操作，但不包括远程引用的变动。<br>该命令主要的使用场景有：当你意外地删除分支、回退到错误的提交、或者执行了其他误操作时(如git reset —hard)，可以使用 git reflog 找回之前的引用状态，然后进行恢复操作。通过查看 reflog，你可以找到误操作之前的引用状态，并恢复到正确的状态。</p><h2 id="撤销动作"><a href="#撤销动作" class="headerlink" title="撤销动作"></a>撤销动作</h2><h3 id="git-commit-—amend"><a href="#git-commit-—amend" class="headerlink" title="git commit —amend"></a>git commit —amend</h3><p><code>git commit --amend</code>允许你修改最新的提交，举例说明：假设你已经提交了一个修改，但后来发现有些内容遗漏了或者需要进行修正。且你不想创建一个新的提交来修正这些问题，因为这会使你的提交历史变得混乱。这时候，你可以使用<code>git commit --amend</code>命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;Initial commit&#x27;</span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><br>这会将<code>Initial commit</code>提交的内容与forgotten_file的commit合并，但提交历史上只保留一条记录。综上，<code>git commit --amend</code>命令允许你修改最新的提交，同时保持提交历史的整洁性。<br>有了该命令，我们就可以及时将工作区的修改内容进行commit，防止内容的丢失，后面都使用<code>--amend</code>选项保持提交历史的整洁，最后万事俱备再push上库。</p><h3 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD \"></a>git reset HEAD \<file\></h3><p>取消暂存区文件的提交，或者使用下面的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged &lt;file&gt;</span><br></pre></td></tr></table></figure></p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout \"></a>git checkout \<file\></h3><p>撤销工作区对文件的修改；<br>也可以使用下面的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore &lt;file&gt;</span><br></pre></td></tr></table></figure><br>如此看来<code>git restore</code>命令更加统一好用，同时也会出现在git的提示消息中；</p><h3 id="撤销commit-慎用"><a href="#撤销commit-慎用" class="headerlink" title="撤销commit(慎用)"></a>撤销commit(慎用)</h3><p>1.撤销并保留修改：<br>如果你想保留修改但是撤销最新的提交，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>这个命令会将 HEAD 移动到上一个提交，并将你的修改保留在工作目录和暂存区中，以便你可以继续修改并重新提交。<br>2.撤销并丢弃修改：<br>如果你想完全撤销最新的提交，并且不保留任何修改，可以使用以下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure><br>这个命令会将 HEAD 移动到上一个提交，并且会丢弃你的修改，恢复到上一个提交的状态。<br>也可以用具体的提交哈希值来代替 HEAD~1，比如 git reset —soft <commit_hash> 或 git reset —hard <commit_hash>。<br>需要注意的是，如果你的提交已经被推送到了远程仓库，并且其他人已经基于该提交进行了工作，撤销提交可能会导致一些问题。在这种情况下，最好与团队成员讨论，以确保撤销提交不会对项目产生负面影响。(可以使用后面所说的<code>git revert</code>命令来解决)<br>也就是说你可以修改没有push的commit，已经push的commit回退版本时要慎重，最好<strong>通过提交新的更改来修复问题，而不是直接撤销提交</strong>。这样可以保持提交历史的完整性，同时避免影响其他人的工作。</p><h2 id="远端仓库相关"><a href="#远端仓库相关" class="headerlink" title="远端仓库相关"></a>远端仓库相关</h2><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>git fetch 命令用于从远程仓库下载最新的提交和数据到你的本地仓库，<strong>但它不会合并这些改变到你的当前工作分支</strong>。其作用包括：</p><ol><li><p>更新远程跟踪分支： 执行 git fetch 后，Git 会下载远程仓库中的最新提交和数据，并将它们保存在本地仓库中。这些数据包括远程分支（如 origin/master）的引用，它们跟踪了远程仓库的状态。</p></li><li><p>获取最新提交： git fetch 会将远程仓库中的最新提交下载到本地，但不会修改你的工作目录或当前工作分支。这使得你可以查看远程仓库的最新状态，然后决定是否需要合并或拉取这些提交到你的工作分支。</p></li></ol><p>设想如下场景，你的同事新建了一分支，名为”branch_a”，并push到远端仓库。这时候你在本地，想直接拉取该分支，使用<code>git pull origin branch_a</code>命令时会报错，因为你没有将远端仓库的提交和数据下载到你的本地仓库，你的本地仓库中并没有“branch_a”的信息。要么你现在当前分支运行<code>git pull</code>命令获取远端仓库的最新提交和数据；要么先运行<code>git fetch</code>的命令，获取“branch_a”的分支信息，再进行后续的分支切换与拉取。</p><h3 id="git-remote-rename"><a href="#git-remote-rename" class="headerlink" title="git remote rename"></a>git remote rename</h3><p>给远端仓库重命名：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><br>取消远端仓库重命名：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p><h2 id="标签相关"><a href="#标签相关" class="headerlink" title="标签相关"></a>标签相关</h2><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>列出仓库中所有的tag，还可以搜索特定pattern的标签：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&quot;v1.8.5*&quot;</span></span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br></pre></td></tr></table></figure></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 支持两种类型的标签：轻量级标签和注释标签。轻量级标签可以理解为给commit的hash值重命名，没有任何额外信息，而注释标签可以保存创建标签的作者，注释和日期等信息；<br>下面是创建注释标签(Annotated Tags)的示例，在创建tag时需要增加<code>-a</code>的选项：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    Change version number</span><br></pre></td></tr></table></figure><p>轻量级标签只需要在<code>git tag</code>后添加标签名即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-lw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    Change version number</span><br></pre></td></tr></table></figure><p>如果我们要给之前的某个commit打标签的话，只需要在<code>git tag</code>后加入commit的hash值即可，如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.2 -m &quot;my version 1.2&quot; 9fceb02</span><br></pre></td></tr></table></figure></p><h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><p>默认情况下，<code>git push</code>不会将tag信息push上库，除非显式地指定，与分支上库相同，将tag同步到远端仓库的命令为：<code>git push origin &lt;tag_name&gt;</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.5</span></span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure><br>如果有许多tag要推送上库的话，可以使用<code>--tags</code>选项<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure></p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>删除标签有如下命令，本地删除tag：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4-lw</span></span><br><span class="line">Deleted tag &#x27;v1.4-lw&#x27; (was e7d5add)</span><br></pre></td></tr></table></figure><br>删除远端仓库的tag：<code>git push origin --delete &lt;tagname&gt;</code></p><h3 id="切换标签"><a href="#切换标签" class="headerlink" title="切换标签"></a>切换标签</h3><p>如果你想切换标签，可以使用<code>git checkout &lt;tag_name&gt;</code>即可。需要注意的是，在 “分离 HEAD “状态下，如果你做了修改，然后又创建了一个提交，tag将保持不变，但你的新提交将不属于任何分支，而且除了通过准确的提交哈希值访问外，将无法访问。因此，如果你需要进行修改，比如修复旧版本上的一个 bug，一般会先基于tag创建一个分支。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure><br>上述命令是基于tag v2.0.0创建分支version2并切换到version2分支，这样的话我们可以基于v2.0.0继续开发。</p><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><p>将本地分支与远端分支相关联，下面的示例代码是将当前的工作分支与远端的serverfix相关联；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin/serverfix</span><br></pre></td></tr></table></figure><br>新建分支并与远端分支相关联：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>Tips：有上述命令的快捷方式，较为常用。如果你要检出的分支名称（a）不存在，（b）只与一个远程上的名称完全匹配，同时满足a和b条件的话，Git会自动帮你创建一个跟踪分支。</p></blockquote><p>查看已设置的跟踪分支，并列出本地分支的各种信息，包括跟踪的远端分支名，是ahead or behind；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><br>删除远端分支：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete serverfix</span></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure></p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><code>git rebase</code>功能与<code>git merge</code>类似，区别在于log比较干净。适用于在推送之前进行rebase，确保log干净后再push上库，而不要对已推送的库上的内容进行rebase。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;base_branch&gt; &lt;topic_branch&gt;</span><br></pre></td></tr></table></figure><br>一. 进行分支合并<br><code>git rebase</code> 主要用于将一个分支的提交移动到另一个分支上，常用于将一个分支的提交合并到另一个分支上。相较于<code>git merge</code>的优点在于commit log里没有”merge xxx into xxx”的日志，看着比较舒服。下面示例将演示如何使用 <code>git rebase</code> 将一个分支的提交合并到另一个分支上。</p><p>假设我们有两个分支：<code>feature</code> 和 <code>master</code>。我们想要将 <code>feature</code> 分支上的提交合并到 <code>master</code> 分支上。</p><ol><li>首先，我们需要切换到 <code>feature</code> 分支：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure><ol><li>然后，我们运行 <code>git rebase</code> 命令来将 <code>master</code> 分支上的提交移动到 <code>feature</code> 分支上，可以执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i master</span><br></pre></td></tr></table></figure><ol><li><p>在执行上述命令后，Git 会将 <code>master</code> 分支上的提交逐个应用到 <code>feature</code> 分支上。如果在此过程中出现冲突，需要解决冲突并继续 rebase 过程。可以使用 <code>git status</code> 命令查看冲突的文件，并手动解决冲突。</p></li><li><p>解决完冲突后，使用以下命令继续 rebase 过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted_file&gt;</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li><li><p>重复步骤 3 和步骤 4，合并后进行merge完成feature的合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，我们使用 <code>git rebase</code> 将 <code>feature</code> 分支上的提交合并到了 <code>master</code> 分支上。这种方式可以使得提交历史保持线性，并且可以减少不必要的合并提交。<strong>使用rebase命令时一定切记，我们是否会修改其他同事也能看到的已经存在的commit内容，如果是，则不要使用rebase，尽量使用merge。</strong></p><p>如果远端仓库的分支名为master，在我们想push修改时，其他同事也在master上有修改，我们可以使用<code>git pull --rebase</code>，commit log是线性的，在rebase后再进行<code>git push</code>操作。需要注意的是使用<code>git pull --rebase</code>时，<strong>仓库内不能有modified的文件</strong>，我们可以在pull之前使用<code>git stash</code>命令。<br>参考资料：<br><a href="https://juejin.cn/post/6844903895160881166">git pull —rebase的正确使用</a><br><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing">merging vs. rebasing</a></p><p>二. 进行多次commit的合并<br>设想我们在新分支上进行了对同一文件进行了多次commit，有较多的历史信息，为了log的整洁性，我们希望把这多次commit进行整合，合并为一次commit，并修改提交信息。比如我们希望将最近的三次commit修改为一次commit，依次进行下面操作。<br>要使用 Git rebase 将最近的三个 commit 合并为一个 commit 并修改 commit 信息，你可以按照以下步骤进行操作：</p><ol><li>执行 <code>git rebase -i HEAD~3</code> 命令来启动交互式 rebase。这将打开一个文本编辑器，列出了最近的三个 commit。</li><li>在编辑器中，你会看到一个包含了最近三个 commit 的列表，每个 commit 都有一个前缀为 “pick” 的行。将除了第一个 commit 之外的所有 “pick” 行的前缀改为 “squash” 或 “s”（表示合并），这样 Git 将会将它们合并到第一个 commit 中。</li><li>保存并关闭编辑器。Git 将会继续 rebase 操作，并在需要的时候打开另一个编辑器，以便你编辑合并后的 commit 信息。</li><li>在新的编辑器中，修改合并后的 commit 信息，以反映你所做的更改。保存并关闭编辑器。</li><li>完成 rebase 操作后，你可能需要解决任何可能出现的合并冲突。Git 会提示你在 rebase 过程中遇到的任何冲突，并提供解决冲突的指导。</li><li>最后，使用 <code>git log</code> 确认你的 commit 已经合并并修改成功。</li></ol><p>以下是一个简单的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>编辑器中的内容：(其中git会提供较多的选项，我们按需选择就行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 1234567 Commit message 1</span><br><span class="line">squash abcdefg Commit message 2</span><br><span class="line">squash hijklmn Commit message 3</span><br></pre></td></tr></table></figure><p>编辑器中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># This is the new commit message.</span><br></pre></td></tr></table></figure><p>保存并关闭编辑器，然后解决可能出现的冲突，最后确认合并结果。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="空白行track"><a href="#空白行track" class="headerlink" title="空白行track"></a>空白行track</h3><p>在git commit之前，运行下面命令检查是否track了空白行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --check</span><br></pre></td></tr></table></figure><br>将开发分支合并到主分支上时，可以使用<code>git merge --squash</code>命令，它是 Git 中用于合并分支并压缩提交历史的命令。它的作用是<strong>将一个分支上的所有提交压缩成一个提交</strong>，并将这个提交合并到当前分支上，适用于需要保持提交历史清晰、整洁的情况。</p><h3 id="三点语法"><a href="#三点语法" class="headerlink" title="三点语法"></a>三点语法</h3><p>查看分支上(contrib)相对于主分支(master)的所有改动情况，可以使用<code>git diff master...contrib</code>来查看，该命令只显示当前主题分支与主分支的共同节点之后引入的工作。</p><h3 id="离线归档"><a href="#离线归档" class="headerlink" title="离线归档"></a>离线归档</h3><p>准备release版本时，可以使用<code>git archive</code>命令创建一个zip的归档文件，供那些不使用git的人查看或进行代码备份。<br>使用<code>git log --no-merges master --not v1.0</code>查看master分支自tag v1.0后的所有改动，不包括merge的变动，可以整理查看所有的改动情况。</p><h3 id="两点语法"><a href="#两点语法" class="headerlink" title="两点语法"></a>两点语法</h3><p>设想如下场景，你的主分支名字叫master，为新开发特性，新建分支featureA，随后master和featureA分支各自并行进行。最后featureA开发完毕，准备合并进入master时，你想看一下哪些commit是仅在featureA上而不在master上(因为我们是基于master新建的分支featureA，所以它也继承了之前master分支上的log)，你可以使用下面命令：<code>git log master..featureA</code>。<br>同理，想将本地push到远程，并查看有什么新的commit时，可以使用如下命令：<code>git log origin/master..HEAD</code>。其中下面两种写法与两点的语法同理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log ^master featureA</span><br><span class="line">git log featureA --not master</span><br></pre></td></tr></table></figure><p>通过上面的语法，我们可以更进一步：</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log refA refB ^refC</span><br><span class="line">git log refA refB --not refC</span><br></pre></td></tr></table></figure></h2><p>如果我们在一个文件中一次修改多个bug，但想分段进行commit，也就是分不同的修改部分进行commit，这时我们可以使用<code>git add -p</code>选项进行修改内容的选择跟踪。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>使用场景：当你正在进行一些修改，但需要切换到其他分支或者处理其他任务时，可以使用 git stash 临时保存当前工作目录的修改。这样可以避免将未完成的工作提交到版本库，保持工作目录的干净和整洁。使用<code>git stash</code>或者<code>git stash push</code>命令。使用<code>git stash list</code>查看stash列表，使用<code>git stash apply</code>将存储的状态取出来(取出来但还不会在list中删除，如果想取出随后就删除，请使用<code>git stash pop</code>命令)，默认取出的stash是<strong>最新压栈</strong>的。<br>当你只想保存工作目录中的部分修改，而不是全部修改时，可以先将需要提交的修改添加到暂存区中，然后运行<code>git stash --keep-index</code>命令保存工作目录的修改。这样可以确保保存的修改不包含已经暂存的部分。<br><code>git stash -u</code>是 Git 中 git stash 命令的一个选项，它用于将当前工作目录的修改临时保存到存储中，并且<strong>包括未跟踪的文件</strong>。<br>最后，如果我们增加“—patch”选项，git会交互式地与你确认哪些修改需要进行stash，而哪些不需要。</p><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p>如果我们想直接删除工作目录中untrack的文件，而不是把它压栈，可以使用<code>git clean</code>命令，为了安全起见，最好加上“-i”选项进行交互式删除。加上”-d”选项会自动删除untrack的空文件夹。</p><h3 id="git搜寻"><a href="#git搜寻" class="headerlink" title="git搜寻"></a>git搜寻</h3><p>使用下面命令查看特定字符串的提交或修改记录，其中<code>ZLIB_BUF_MAX</code>为我们想搜寻的字符，<code>--oneline</code>是输出的选项，以简易形式输出。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -S ZLIB_BUF_MAX --oneline</span><br></pre></td></tr></table></figure><br>使用<code>git blame file</code>查看file中每一行的最近改动，可以查看是谁引入了相关问题(所以是blame选项，找背锅的，哈哈哈)。<code>git blame -L 11,22 file</code>仅限查看file中11到22行的最近改动。</p><hr><p>查看特定文件中某一函数的改动情况，可以使用如下的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -L :git_deflate_bound:zlib.c</span><br></pre></td></tr></table></figure><br>如果我们想查看 zlib.c 文件中函数 git_deflate_bound 的每一次修改，可以运行上述命令，这将尝试找出该函数的边界，然后查看历史记录，以一系列补丁的形式向我们展示函数的每一次修改，直至函数首次创建。或者就在-L后面给出行数范围也可以。可以使用<code>git log --help</code>查看-L的使用方法。</p><h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><p>在我们合并分支或者<code>git stash pop</code>时，很有可能出现冲突的情况，下面主要给出merge失败的解决方案，即如何解冲突。<br>首先，如果我们目前没有时间去清除conflict，我们可以先使用<code>git merge --abort</code>命令，这样会回退到<code>git merge</code>或者<code>git stash pop</code>的状态之前，也就相当于撤销一次merge的操作。(如果没敲合并的命令不就没有合并冲突了，hhhhh)<br>如果我们确实想解冲突，但只是想拿本地分支或者待合入分支的文件版本，我们可以简单操作如下：<code>git checkout --ours file</code>，这是取我们当前分支的文件状态作为merge后的结果，<code>git checkout --theirs file</code>这是取待合入分支的文件作为merge的结果。<br>最后是常用的情况，我们确实想看文件中共同的改动在何处，并想仔细解冲突，可以先使用<code>diff3</code>来查看版本修改情况，这里“3”的含义是我们在解冲突时所需要的三份文件版本：1. 该文件在两分支上的共同祖先版本(BASE)；2. 本地分支的版本(LOCAL)；3. 待合入分支的版本(REMOTE)；<br>我们使用<code>git checkout --conflict=diff3 file</code>，此后打开file，会发现文件中的冲突之处有如下的特征：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours</span><br><span class="line">  puts &#x27;hola world&#x27;</span><br><span class="line">||||||| base</span><br><span class="line">  puts &#x27;hello world&#x27;</span><br><span class="line">=======</span><br><span class="line">  puts &#x27;hello mundo&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; theirs</span></span><br></pre></td></tr></table></figure><p>其中三部分内容以不同的分隔符进行分隔，其中ours是本地文件版本，base是共同祖先版本，theirs是待合入分支的文件版本，我们对其进行选择，随后将该段提示删除保存，即可完成解冲突操作。(解完冲突后进行<code>git add</code>+<code>git commit</code>操作)；还可以使用<code>git diff</code>查看尚未解完的冲突，适用于冲突较多的情况。<br>也许发生冲突的修改已经距离当前很远了，我们可以使用<code>git log --oneline --left-right --merge</code>来查看与冲突相关的提交，通过当时的commit message信息来决定如何解冲突。</p><h2 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h2><p>如果我们错误提交了一次commit，心里一定非常慌张。别急，git给你准备了补救手段。如果该commit还没有push上库，那么比较简单，直接<code>git reset --hard HEAD^</code>即可，回退到commit之前的版本。但如果上库了就没那么简单了，因为可能有其他同事基于你错误的版本已经在向前移动HEAD指针了，如果你强行reset可能会造成更严重的错误。其实想一下，每次查看git commit的log时，都会说此次commit修改了哪些哪些文件，那如果有一个命令让你逆向还原这些文件，不就一样实现了撤销commit的操作吗？这就是<code>git revert</code>的功能。该命令用起来很简单，<code>git revert commit-id</code>即可完成撤销，我们再进行<code>git add</code>和<code>git commit</code>即可。<br>需要注意的是，如果撤销的commit是merge分支的操作，那么后续如果再继续merge该分支时，需要一些额外操作，详细操作流程请查看Pro_Git的7.8节。<br>如果要处理大量重复的冲突，可以查阅<code>git rerere</code>工具。</p><h2 id="Debug何时引入错误"><a href="#Debug何时引入错误" class="headerlink" title="Debug何时引入错误"></a>Debug何时引入错误</h2><p><code>git bisect</code> 是 Git 提供的一个用于二分查找的工具，用于定位代码中引入 bug 的具体提交。它的主要作用是帮助开发者在一个较大的提交历史中快速定位引入 bug 的具体提交，从而更容易地进行问题追踪和修复。(bisect：binary search commit)</p><p>使用场景及示例说明如下：</p><p><strong>场景：</strong> 假设你的项目中出现了一个 bug，而你无法确定 bug 是在哪个具体的提交引入的，但你知道在项目的某个历史版本中是没有这个 bug 的。</p><p><strong>步骤：</strong></p><ol><li><strong>开始 bisect：</strong> 首先，你需要告诉 Git bug 的状态，即哪个提交是有 bug 的，哪个是没有 bug 的。你可以使用 <code>git bisect start</code> 命令开始 bisect 过程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br></pre></td></tr></table></figure>我们可以使用<code>git bisect start HEAD commit-id</code>，其中commit-id为已知的正确的版本，HEAD为已发生错误的版本，或者使用两个commit-id表明范围也行。</li><li><strong>标记 bad 和 good：</strong> 接着，你需要标记一个已知是有 bug 的提交为 “bad”，另一个已知是没有 bug 的提交为 “good”。这可以通过 <code>git bisect bad</code> 和 <code>git bisect good</code> 命令来完成。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect bad           <span class="comment"># 当前版本有 bug</span></span><br><span class="line">git bisect good          <span class="comment"># 当前版本没有 bug</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>开始二分查找：</strong> Git 现在将使用二分查找算法在两个标记的提交之间进行搜索，每次检出一个中间的提交，然后你需要测试该版本是否有 bug。如果有 bug，使用 <code>git bisect bad</code> 命令标记为 bad，否则标记为 good。</p></li><li><p><strong>重复步骤：</strong> 重复步骤 3，直到 Git 找到第一个引入 bug 的提交。此时，Git 将输出这个提交的信息，你就可以定位到引入 bug 的具体提交。</p></li><li><p><strong>结束 bisect：</strong> 当找到引入 bug 的提交后，使用 <code>git bisect reset</code> 命令结束 bisect 过程。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><p>通过以上步骤，你可以利用 <code>git bisect</code> 工具快速定位代码中引入 bug 的具体提交，从而帮助进行问题追踪和修复。这在大型项目中特别有用，因为通常情况下可能存在大量的提交历史。</p><h2 id="submodules"><a href="#submodules" class="headerlink" title="submodules"></a>submodules</h2><h3 id="添加submodules"><a href="#添加submodules" class="headerlink" title="添加submodules"></a>添加submodules</h3><p>在main project里添加submodule：<code>git submodule add https://xxx</code>；<br>之后会在main project中发现.gitmodules文件，里面记录了submodule的url，在main project中的路径以及其关联的分支名；这也是其它成员能知道submodule来源的配置文件；</p><h3 id="clone含submodules的project"><a href="#clone含submodules的project" class="headerlink" title="clone含submodules的project"></a>clone含submodules的project</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种方法</span><br><span class="line">git clone https://xxxxx</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">2. 第二种方法</span><br><span class="line">git clone --recurse-submodules https://xxxxx</span><br><span class="line">如果已经clone下来，还有补救方式：</span><br><span class="line">git clone https://xxxxx</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h3 id="更新含有submodules的project"><a href="#更新含有submodules的project" class="headerlink" title="更新含有submodules的project"></a>更新含有submodules的project</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">法一：</span><br><span class="line">git pull</span><br><span class="line">git submodule update --init --recursive(此时会将挂载在main project的当前分支上的submodule的更新merge进来)</span><br><span class="line">法二：</span><br><span class="line">git pull(或者git fetch)</span><br><span class="line">git submodule update --remote(此时会将.gitmodules配置文件中所记录的submodule的分支拉到最新，可能与main project的分支情况不一致，不推荐)</span><br><span class="line">特殊情况，如果main project在某次提交时修改了submodule的url，此时我们git submodule update就有可能失败，为解决该问题，我们可以使用git子模块同步命令：</span><br><span class="line">git submodule sync --recursive</span><br></pre></td></tr></table></figure><h3 id="push-submodule"><a href="#push-submodule" class="headerlink" title="push submodule"></a>push submodule</h3><ol><li>在main project里<code>git add submodule</code>，此时会将当前的提交点挂载在main project上；</li><li>git push<h3 id="merge-submodule"><a href="#merge-submodule" class="headerlink" title="merge submodule"></a>merge submodule</h3>如果submodule发生冲突，解决流程：</li><li><code>git pull</code>获取最新submodule状态，并发现发生冲突；</li><li><code>git diff</code>查看local与remote的commit id差异；</li><li>基于远端commit id新建分支，<code>git branch try_merge remote-commit-id</code>；</li><li><code>git merge try_merge</code>；</li><li>然后就是正常的解冲突；</li><li><code>git add, git commit, git push</code>；<h3 id="submodule-tips"><a href="#submodule-tips" class="headerlink" title="submodule tips"></a>submodule tips</h3>可以通过<code>foreach</code>的子模块命令对所有的子模块进行操作，这在项目中拥有较多submodules时比较有用。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach &#x27;git stash&#x27;</span><br><span class="line">git submodule foreach &#x27;git checkout -b featureA&#x27;</span><br><span class="line">git diff; git submodule foreach &#x27;git diff&#x27;</span><br></pre></td></tr></table></figure>使用alias将长命令缩短<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config alias.sdiff &#x27;!&#x27;&quot;git diff &amp;&amp; git submodule foreach &#x27;git diff&#x27;&quot;</span><br><span class="line">git config alias.spush &#x27;push --recurse-submodules=on-demand&#x27;</span><br><span class="line">git config alias.supdate &#x27;submodule update --remote --merge&#x27;</span><br><span class="line">使用：</span><br><span class="line">git spush</span><br><span class="line">git supdate</span><br></pre></td></tr></table></figure>如果在main project中，有的分支上有submodule，而有的分支上没有submodule，那么在切换main project的分支时，最好使用如下方式：<code>git checkout --recursive-submodules branch_name</code>。<h2 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h2><code>git bundle</code> 是 Git 提供的一个功能，它可以将 Git 仓库的部分或全部历史打包成一个单独的文件。这个文件可以在不连接到网络的情况下传递给其他人，他们可以通过将其导入到自己的本地仓库来恢复提交历史。<code>git bundle</code> 的主要作用是在没有网络连接或网络速度较慢的情况下，仍然能够方便地共享和传输 Git 仓库的历史记录。</li></ol><p>使用场景包括但不限于：</p><ol><li><p><strong>离线协作：</strong> 当你需要与其他人协作，但又无法连接到网络时，可以使用 <code>git bundle</code> 将你的本地仓库的提交历史打包成一个文件，并通过其他方式传递给他们，如 USB 磁盘或其他传输媒介。</p></li><li><p><strong>备份和归档：</strong> 将 Git 仓库的历史记录打包成一个 bundle 文件可以作为备份和归档的方式。你可以将 bundle 文件存档到云存储或外部硬盘中，以防止数据丢失。</p></li><li><p><strong>快速克隆：</strong> 当你需要在其他计算机上快速克隆 Git 仓库时，可以使用 bundle 文件代替从远程仓库克隆，特别是在网络速度较慢的情况下。</p></li></ol><p>下面是一个示例，演示了如何使用 <code>git bundle</code> 创建和使用 bundle 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 bundle 文件</span></span><br><span class="line">git bundle create repo.bundle master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 bundle 文件传递给其他人，如通过 USB 磁盘或其他传输媒介</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复提交历史到本地仓库</span></span><br><span class="line">git <span class="built_in">clone</span> repo.bundle repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新现有仓库的提交历史</span></span><br><span class="line">git pull repo.bundle master</span><br></pre></td></tr></table></figure><p>在上面的示例中，首先我们使用 <code>git bundle create</code> 命令创建了一个名为 <code>repo.bundle</code> 的 bundle 文件，其中包含了 <code>master</code> 分支的提交历史。然后，我们可以将这个 bundle 文件传递给其他人。其他人可以通过 git clone 命令从 bundle 文件中恢复提交历史到本地仓库，或者通过 git pull 命令更新现有仓库的提交历史。可以进行checkout到特定commit id的操作；<br><a href="https://git-scm.com/book/en/v2/Git-Tools-Bundling">Git-Tools-Bundling</a></p>]]></content>
    
    
    <summary type="html">对git命令做了整理，方便以后快速查阅</summary>
    
    
    
    <category term="Misc" scheme="http://david-luge.cn/categories/Misc/"/>
    
    <category term="Git" scheme="http://david-luge.cn/categories/Misc/Git/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>DC优化的常用方法</title>
    <link href="http://david-luge.cn/2023/10/30/IC/EDA/DC%E4%BC%98%E5%8C%96%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://david-luge.cn/2023/10/30/IC/EDA/DC%E4%BC%98%E5%8C%96%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2023-10-30T13:10:39.000Z</published>
    <updated>2023-10-30T13:10:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>优化是Design Compiler综合中的一个步骤，该步骤根据设计的功能、速度和面积要求，寻找特定目标逻辑库单元的最佳组合。DC提供了一些设计者能够自定义和控制优化的选项，本文将讨论这些选项。<br>DC的优化过程需要基于设计者对Design的约束，其中约束又分为两类，Design Rule Constraint（DRC）和Optimization Constraint，其中DRC的优先级较高（优先保证满足DRC）。</p><ul><li>Design Rule Constraint：Transition，Fanout，Capacitance；</li><li>Optimization Constraint：Timing，Area；<h2 id="Automatic-Ungrouping"><a href="#Automatic-Ungrouping" class="headerlink" title="Automatic Ungrouping"></a>Automatic Ungrouping</h2>DC工具中，使用<code>compile_ultra</code>命令对设计进行编译时，会自动将设计的层次结构打散。Ungrouping就是将小模块打散直接合并到大模块中，移除了层次结构的边界可以让DC工具“放开手脚”，可以通过减少逻辑级数来改善时序，并通过逻辑共享来降低面积。<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213123779.png" alt="image-20231030213123779"><br>在Ungrouping时，部分小模块会在接口上进行一些时序约束，如multicycle或false path等。在对模块进行Ungrouping时，DC会对这些约束进行保留，将其重新分配给相邻的仍存在的引脚。<br>对于设计者不想进行Ungrouping的模块，可以对该模块进行属性约束：<code>dont_touch</code>，<code>size_only</code>，<code>set_ungroup</code>等。</li></ul><h2 id="High-Level-Optimizations-and-Datapath-Optimization"><a href="#High-Level-Optimizations-and-Datapath-Optimization" class="headerlink" title="High-Level Optimizations and Datapath Optimization"></a>High-Level Optimizations and Datapath Optimization</h2><p>在数据路径的优化阶段，DC会根据时序和面积的约束，对资源进行合理的分配与共享。资源共享是指对多个操作使用同一硬件组件，通常可以减少面积。其他的优化包括算子优化以及通用的运算符共享在此阶段也会进行。<br>DC的算子优化其实就是使用DC自带的DesignWare库对算子进行高性能映射，可以选择Area优先或者Speed优先，需要额外的licence，这里不再详述。</p><h3 id="High-Level-Optimizations"><a href="#High-Level-Optimizations" class="headerlink" title="High-Level Optimizations"></a>High-Level Optimizations</h3><p>DC工具还提供<strong>优化树延迟和算子化简</strong>的优化手段。举例来说，表达式<code>a+b+c+d</code>描述的是一个3级级联加法器，DC可以对计算的顺序进行优化，变成<code>(a+b)+(c+d)</code>，这样可以提高电路速度（2级级联加法器）。算子化简由<code>compile_ultra</code>进行提供，有以下的化简案例：“(a+b-a) =&gt; a”，“(aX3X5) =&gt; (aX15)”；</p><h3 id="Resource-Sharing"><a href="#Resource-Sharing" class="headerlink" title="Resource Sharing"></a>Resource Sharing</h3><p><strong>资源共享</strong>减少了HDL中实现加法(+)等操作符所需的硬件数量。如果每个+操作符都构造一个加法器，则会大大增加设计的面积。有两种类型的资源共享:公共子表达式消除和互斥操作的共享。<br>为理解公共子表达式消除类型的资源共享，以下例进行说明：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Original RTL</span></span><br><span class="line">X = A &gt; B;</span><br><span class="line">Y = A &gt; B &amp;&amp; C;</span><br><span class="line"><span class="comment">// After Common Subexpression Elimination</span></span><br><span class="line">Temp = A &gt; B;</span><br><span class="line">X = Temp;</span><br><span class="line">Y = Temp &amp; C;</span><br></pre></td></tr></table></figure><p>上述优化方式将比较器由2个降低到1个，降低了面积。DC默认会将下列的操作符进行上述资源共享操作：比较符（=, &lt;, &gt;, &lt;=, &gt;=, !=），移位符（&lt;&lt;, &gt;&gt;, &lt;&lt;&lt;, &gt;&gt;&gt;），算术运算（+, -, x, /, **, %）。<br>此外，使用<code>compile_ultra</code>进行编译时，工具会自动识别公共子表达式，无需以相同的顺序对表达式进行书写。比如在表达式“A+B+C”和“B+A+D”中，”A+B”和“B+A”被识别为公共子表达式。<br>另外，DC工具既可以共享公共子表达式，也可以根据约束进行反向共享。以下面的表达式为例，<code>Z1&lt;=A+B+C</code>，<code>Z2&lt;=B+C+D</code>，各信号的arrive time为<code>A&lt;B&lt;D&lt;C</code>。下图展示了DC会根据约束决定资源共享或是反向共享。<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213224106.png" alt="image-20231030213224106"><br>下面介绍共享互斥操作，互斥在这里的含义就是操作不会被同时执行。下面的例子可以更好地帮助理解：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> resources(A,B,C,SEL);</span><br><span class="line"><span class="keyword">input</span> A,B,C;D</span><br><span class="line"> <span class="keyword">input</span> SEL;</span><br><span class="line"> <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] Z;</span><br><span class="line"> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] Z;</span><br><span class="line"><span class="keyword">always</span> @(A <span class="keyword">or</span> B <span class="keyword">or</span> C <span class="keyword">or</span> D <span class="keyword">or</span> SEL) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(SEL)</span><br><span class="line">Z = B + A;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Z = C + D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>使用资源共享后的综合结果如下：<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213256777.png" alt="image-20231030213256777"><br>与公共子表达式共享类似，DC会根据时序约束确定是共享还是反向共享。例如，当SEL信号到达较晚且，共享加法器会使QoR（Quality of Results)变差时，DC就不会共享加法器。</p><h3 id="Datapath-Optimization"><a href="#Datapath-Optimization" class="headerlink" title="Datapath Optimization"></a>Datapath Optimization</h3><p>DC对Datapath的优化主要通过以下手段：</p><ul><li>使用Design Ware库；</li><li>数据路径提取：如果数据的计算路径上有多级加法，可以使用多个树形结构的CSA（carry-save adders）加法器来提高加法的计算速度。使用该方式时有如下前提：1.各运算单元之间没有其他非算术逻辑；2.无法提取被例化的Design Ware模块；</li><li>合理使用乘法分配律，如：(a x c + b x c)被优化为(a + b) x  c；</li><li>比较器共享，比如a &gt; b，a &lt; b，a ≤ b会调用同一个减法器；</li><li>操作数重排序；<h2 id="Path-Group"><a href="#Path-Group" class="headerlink" title="Path Group"></a>Path Group</h2>默认情况下，DC根据时钟对path group进行划分，随后DC根据path group对时序进行收敛，默认是对path group中最差的路径进行优化。因此如果设计存在复杂的时钟或时序要求，用户可以将几条关键路径划分为一个path group，指定DC专注于该组路径的优化。<br>此外，设计者可以对时钟分组设置权重，权重的值范围为0.0-100.0。例如：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_path -name group0 -from in1 -to FF1/D -weight 2.5</span><br></pre></td></tr></table></figure><h2 id="Optimizing-near-critical-paths"><a href="#Optimizing-near-critical-paths" class="headerlink" title="Optimizing near-critical paths"></a>Optimizing near-critical paths</h2><p>默认情况下，DC只优化同一path group内的关键路径，即slack最差的路径。如果在关键路径附近指定一个范围，那么DC就会优化指定范围之内的所有路径。若指定范围较大，会增大DC运行时间，因此一般情况该范围设定为时钟周期的10%。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_critical_range 3.0 $current_design</span><br></pre></td></tr></table></figure><h2 id="Perform-high-effort-compile"><a href="#Perform-high-effort-compile" class="headerlink" title="Perform high-effort compile"></a>Perform high-effort compile</h2><p>High-effort compile能够使DC更加努力地达到约束目标，该选项在关键路径上进行重新综合，同时对关键路径周围的逻辑进行了restructure和remap。</p><blockquote><p>restructure主要目的是重新组织和优化设计的逻辑结构，以改进性能、功耗、面积或其他关键指标。以一个32bit的加法器为例说明restructure：在restructure优化前，电路采用传统的级联加法器结构，逻辑门按顺序连接，逻辑的排列和布局可能不是最优的，导致延迟较大，功耗较高；在restructure优化后，DC使用更高级的加法器结构，如Carry Look-Ahead Adder（CLA），代替传统结构，并重新组织逻辑，将关键路径上的逻辑门优化排列，以减小延迟。</p></blockquote><p>high-effort的指令有两种：</p><ul><li>compile_ultra附带两个option，-area_high_effort_script是面积优化，-timing_high_effort_script是时序优化。</li><li>compile附带一个option，<code>map_effort -high</code></li></ul><h2 id="Perform-high-effort-incremental-compile"><a href="#Perform-high-effort-incremental-compile" class="headerlink" title="Perform high-effort incremental compile"></a>Perform high-effort incremental compile</h2><p>通常使用增量编译可以提高电路优化的性能。如果电路在初次compile之后不满足约束，通过增量编译对不满足时序要求的电路进行门级优化。增量编译会增加编译时间，但是时序收敛的有效方法。为了减少DC运算时间，可将那些已经满足时序要求的模块设置为<code>dont_touch</code>属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dont_touch noncritical_blocks</span><br></pre></td></tr></table></figure><p>对于那些有很多违例逻辑模块的设计，增量编译通常是最有效的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile -map_effort high -incremental_mapping</span><br></pre></td></tr></table></figure><h2 id="Gate-level-optimization"><a href="#Gate-level-optimization" class="headerlink" title="Gate-level optimization"></a>Gate-level optimization</h2><p>DC工具内的门级优化主要是通过选择工艺库中合适的标准单元来对电路进行优化，主要有3个阶段。</p><h3 id="Delay-optimization"><a href="#Delay-optimization" class="headerlink" title="Delay optimization"></a>Delay optimization</h3><p>在该阶段，DC通过对关键路径进行遍历来修复Delay的违例。<br>改善电路的delay主要有以下的思路：</p><ol><li>打散关键路径上的层次结构，并使能boundary optimization；</li><li>使用Path Group对关键路径进行分组，并在关键路径附近指定一个范围，那么DC就会优化指定范围之内的所有路径；</li><li>在探索设计空间阶段，可以给设计的delay更高的优先级，探索设计能达到的最快速度（不一定满足DRC）；</li><li>对于扇出较大的net使用<code>balance_buffer</code>命令；</li></ol><p>在Delay optimization阶段，有下面几种改善电路delay的方式：upsizing, load isolation and splitting.<br>“upsize” 是一种优化技术，旨在通过增大某些逻辑门的规模来提高电路性能。将电路中的某些标准逻辑门替换成面积更大的逻辑门可以增强逻辑门的驱动能力，从而获得更低的传输延迟，但它会导致面积和功耗的增加，因此使用时需要注意。<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213405578.png" alt="image-20231030213405578"><br>load isolation and splitting旨在减小逻辑门的输出负载，来改善电路的性能指标。主要思想是将逻辑门的输出与输入负载隔离开，以减小输出驱动电流。这可以通过以下方式实现：1. 在输出端插入缓冲器，以减小输出电路的负载电容。这可以降低输出延迟，提高电路的时序性能。同时，缓冲器还可以提供更高的输出驱动能力；2. 重新组织电路逻辑，将一些逻辑元素拆分为多个阶段，以减小每个阶段的输出负载，这通常需要在逻辑层面进行重新设计。<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213426207.png" alt="image-20231030213426207"><br>需要注意的是，DC在此阶段已经开始考虑DRC。同样条件下，会选择DRC代价最小的方案。</p><h3 id="Design-Rule-Fixing"><a href="#Design-Rule-Fixing" class="headerlink" title="Design Rule Fixing"></a>Design Rule Fixing</h3><ul><li>DC主要通过Resize或者插Buffer等方式来满足DRC约束；</li><li>一般不会影响时序和面积结果，但必要时会导致optimization consrtaints违例；<h3 id="Area-Recovery"><a href="#Area-Recovery" class="headerlink" title="Area Recovery"></a>Area Recovery</h3></li><li>不会引起DRC和Delay的违例，一般只是对非关键路径进行优化，优化方式包括<code>Cell DownSize</code>和<code>buffer and inverter cleanup</code>；</li><li>如果没有设置面积约束，那么优化幅度会很小；</li></ul><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213449018.png" alt="image-20231030213449018"></p><h2 id="Adaptive-Retiming"><a href="#Adaptive-Retiming" class="headerlink" title="Adaptive Retiming"></a>Adaptive Retiming</h2><p>Adaptive Retiming（自适应时序调整）是DC工具中的一种优化技术，旨在调整电路中寄存器的位置以改善电路性能。它可以动态地适应电路中的性能需求，以达到设计目标。这对于高性能数字电路设计非常重要，尤其是在面临时序违规、时序紧迫性和电路性能优化的情况下。<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213604445.png" alt="image-20231030213604445"><br>由上图可知，发现设计的流水线划分不平衡时，就可以使用retiming策略。retiming策略有两种，分别是Backward Move和Forward Move，可在时序路径上前后移动寄存器，以提高电路的时序性能。如果没有违例的路径，则可用来减少寄存器的数量。<br>DC在移动寄存器的优化中，只有对有相同时序约束的寄存器进行调整，如果两个寄存器约束不同，则不能一起移动。<br>移动后的寄存器在网表中，名字通常带有一个R的前缀，和一个系列号，如<code>R_xxx</code>。<br>retime策略不能和compile_ultra的以下option一起使用：</p><ul><li>top</li><li>only_design_rule</li></ul><p>除此之外其他option都可以同时使用。</p><blockquote><p>“Uniquify” 在数字电路设计工具中的作用是确保设计中的信号名字（如寄存器、信号线等）在整个设计中是唯一的。把例化的多个模块转化成唯一的模块名字，这样优化时可以针对每个模块做优化而不影响其它模块。</p><h2 id="Pipelined-Logic-Retiming"><a href="#Pipelined-Logic-Retiming" class="headerlink" title="Pipelined-Logic Retiming"></a>Pipelined-Logic Retiming</h2><p>当设计者在综合之前描述RTL级别的电路时，很难找到最佳的寄存器放置位置并将其编码到HDL中。通过寄存器Retiming，时序逻辑中触发器的位置可以自动调整，以尽可能地平衡各阶段的延迟。<br>流水线Retiming在输入输出处的逻辑保持不变，因此不用改变TB相关的配置。但是，Retiming会改变设计中寄存器的位置、内容和名称。此时不能使用内部寄存器的输入和输出作为验证的参考点。<br>举一个比较夸张的例子，比如我们需要设计一个简单的IP，仅关注输入输出逻辑，验证时也仅看接口信号逻辑。此时IP内部我们可以全部用组合逻辑进行描述，然后进行打拍输出。再启用Pipelined-Logic Retiming对寄存器位置进行重排，如果不满足时序要求则继续增加输出的打拍数目。<br>Pipelined-Logic Retiming的示意图如下：<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213643298.png" alt="image-20231030213643298"></p></blockquote><p><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213655682.png" alt="image-20231030213655682"></p><h2 id="Verifying-function-equivalence"><a href="#Verifying-function-equivalence" class="headerlink" title="Verifying function equivalence"></a>Verifying function equivalence</h2><p>DC中部分优化手段会引起网表和HDL不一致，因此需要使用formality工具进行一致性检查，确认不一致的地方是否由DC优化造成。因此，DC在综合过程中必须生成formality的setup文件（默认为default.svf），给formality进行后续验证。其中可能会导致网表和HDL不一致的原因如下：</p><ul><li>由ungroup、group、uniquify、rename_design等约束造成部分寄存器、端口名字改变；</li><li>状态机的优化；</li><li>Retiming策略导致寄存器排布方式与HDL不一致；</li><li>等效和相反的寄存器被优化，常量寄存器被优化；</li><li>数据通路优化；</li></ul><h2 id="Partitioning-for-synthesis"><a href="#Partitioning-for-synthesis" class="headerlink" title="Partitioning for synthesis"></a>Partitioning for synthesis</h2><p>把一个设计分割成几个相对简单的部分，称为设计划分（Design Partition）。一般在编写HDL代码之前都需要对所要描述的系统做划分，根据功能或代码量的考虑将一个系统层次化地分成若干个子模块，这些子模块下面再进一步细分，模块（module）就是一个划分的单位。<br>在运用DC作逻辑综合的过程中，默认情况下各个模块的层次关系是保留着的，保留着的层次关系会对DC综合造成一定的影响。比如在优化的过程中，各个模块的管脚必须保留，这势必影响到模块边界的优化效果。<br>在HDL编写过程中，一般遵循如下的设计划分原则：</p><ul><li>避免让一个组合逻辑穿越过多模块；</li><li>将同步逻辑与异步逻辑剥离；</li><li>进行寄存输出；</li></ul>]]></content>
    
    
    <summary type="html">DC优化的常用方法</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="EDA" scheme="http://david-luge.cn/categories/IC/EDA/"/>
    
    
    <category term="EDA" scheme="http://david-luge.cn/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>DC入门</title>
    <link href="http://david-luge.cn/2023/10/23/IC/EDA/DC%E5%85%A5%E9%97%A8/"/>
    <id>http://david-luge.cn/2023/10/23/IC/EDA/DC%E5%85%A5%E9%97%A8/</id>
    <published>2023-10-23T13:10:39.000Z</published>
    <updated>2023-10-23T13:10:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Design Compile是所有IC工程师的必备工具，之前在校期间受限于平台只是使用FPGA的开发平台Vivado完成综合流程。进入公司后发现DC比较陌生，最近啃了一下Design Compile的User Guide，特用博客做记录用。开发环境为Design Compiler 2016。</p><h2 id="综合概述"><a href="#综合概述" class="headerlink" title="综合概述"></a>综合概述</h2><p>之前跟FPGA打过交道的同学应该对综合这个概念不陌生，FPGA里的综合是将HDL映射到FPGA的固有器件上，如LUT，BRAM，DSP等。而芯片中的综合也是类似，只不过底层被映射的器件变了。Design Compiler（以下简称DC）是Synopsys公司用于做电路综合的核心工具，可以将HDL转换为基于工艺库的门级网表。<br>DC工具中的综合主要分为以下三个阶段：</p><ul><li><p>Translation（转译）：把电路转换为EDA内部数据库GTECH（Generic Technology），这个数据库跟工艺库是独立无关的；</p><ul><li>analyze（分析）：对HDL进行语法检查；</li><li>elaborate（细化）：将HDL转换为GTECH；</li></ul></li><li>Optimozation（优化）：根据工作频率、面积、功耗来对电路优化，来推断出满足设计指标要求的门级网表；</li><li>Mapping（映射）：将门级网表映射到晶圆厂给定的工艺库上，最终形成该工艺库对应的门级网表。</li></ul><p>DC在综合过程中会将电路划分为下列的处理对象：</p><ul><li>Design：待综合的对象；</li><li>Port：Design最外部的端口；</li><li>Clock：时钟；</li><li>Cell：被例化的模块名；</li><li><p>Reference：例化的原电路；</p><p>举例说明：<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231023205816424.png" alt="DC的处理对象"><br>使用DC综合的流程如下图所示：<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/DC%E7%BB%BC%E5%90%88%E6%B5%81%E7%A8%8B.png" alt="DC综合流程"><br>我们对着上图进行说明。HDL文件不用多说，硬件设计的主要文件；首先经过Design Compiler将HDL转换为GTECH，完成了Translation，然后进行后续优化与映射工作；<br>图中左侧有5个输入的“参考”文件。Constraints为设计约束文件，为sdc（Synopsys Design Constraint）文件，对设计进行面积，时钟等方面的约束；IP Designware Library为Synopsys设计的高性能算子库，对“+ - × &gt;= &lt;”等基础算子或其他高级的算术运算进行深度优化，并可根据设计目标选择面积优先或者速度优先的实现方式，但需要购买额外的License才可以使用；Technology Library为工艺库，又称Target Library，由Vendor提供，内部包含一些基本的电路模块，如与或非门，FF，Latch等，供HDL进行映射；Symbol Library为符号库，它定义了在GUI界面中综合后的电路如何显示，在需要查看和分析电路图时需要指定，不指定时默认都按方框显示电路模块；DEF（Design Exchange Format）文件是一种标准的电子设计交换格式，主要用于表示物理设计和布局信息。在进行FloorPlan与Place&amp;Route后，对布局布线，版图信息等进行反标，提供给DC，用以更准确地对Timing，Area等进行评估与优化。<br>图的右侧是对Design进行时序和功耗的分析，中间则是优化的主要过程，如Timing, Datapath, Power, Area Optimization，进行时序收敛并对DFT（Design For Test）进行综合，最终得到优化后的netlist。<br>由于优化过程中的一些优化手段会改变原先的电路结构，因此在综合后需要对netlist与HDL进行一致性验证，也就是最右侧的Formal Verification（使用Formality工具)。最后我们将优化后的netlist提供给IC Compiler，完成Floorplan以及P&amp;R等工作。</p></li></ul><h2 id="Design-Compile的使用"><a href="#Design-Compile的使用" class="headerlink" title="Design Compile的使用"></a>Design Compile的使用</h2><h3 id="启动Design-Compile"><a href="#启动Design-Compile" class="headerlink" title="启动Design Compile"></a>启动Design Compile</h3><p>一般使用命令行的方式来启动DC，启动方式为<code>dc_shell -f script.tcl</code>。DC在启动时会自动在启动目录下创建“command.log”和“view_command.log”两个文件，用于记录用户在使用DC时所执行的命令及设置的参数。</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>首先DC需要读取HDL文件，有如下两种读取方式：</p><ul><li>使用read_file命令来读取文件；</li><li>同时使用analyze和elaborate指令；</li></ul><p>read_file命令可以同时完成两件事：1. analyze the design；2. translate the design into GTECH；<br>那它与（analyze+elaborate）有什么不同呢？</p><div class="table-container"><table><thead><tr><th>比较</th><th>read_file</th><th>analyze+elaborate</th></tr></thead><tbody><tr><td>输入文件类型</td><td>所有文件类型都支持，包括Verilog,VHDL,db文件等</td><td>仅支持Verilog和VHDL</td></tr><tr><td>使用时机</td><td>用来对综合的网表，预编译的结果及代码等进行综合</td><td>对VHDL和Verilog代码进行综合</td></tr><tr><td>参数</td><td>不允许在命令中对参数进行修改</td><td>可以通过elaborate修改设计中的Parameter</td></tr><tr><td>Link Design</td><td>必须使用link命令来解析模块引用</td><td>elaborate自动执行了link命令来解析模块引用，无需再执行link</td></tr></tbody></table></div><p>link中使用elaborate命令来重新对parameter进行赋值的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaborate chip_top -parameter &quot;DATA_WIDTH = 8,ADDR_WIDTH = 8&quot;</span><br></pre></td></tr></table></figure><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>读取完所要综合的模块之后，需要用link命令将读到DC暂存区中的模块或实体连接起来。在tcl文件中需要添加link_library，告诉DC到哪去找这些模块。同时还要注意search_path中的路径是否指向该模块或单元电路所在的目录。</p><blockquote><p>Tips：设置search_path后，DC会在search_path目录中自动查找指定的设计和库文件，无需指定其绝对路径，仅需指定其名字即可。search_path的作用范围不仅限于库文件，我们还可以将sdc，db等文件的路径放在其中，简化tcl文件的规模。</p><h2 id="标准工艺单元库"><a href="#标准工艺单元库" class="headerlink" title="标准工艺单元库"></a>标准工艺单元库</h2><p>DC需要工艺库文件来执行综合过程。工艺库文件是针对特定制造工艺的库文件，其中包含了对工艺的物理特性和约束信息进行建模。这些工艺库文件在综合过程中发挥着重要作用：</p></blockquote><ul><li><p>基本元件库： 工艺库文件包括了各种基本元件（如标准单元、存储器单元、I/O单元等）的信息。这些元件是IC设计中的基本构建块，它们的特性和电气特性必须准确建模以便综合工具能够正确地生成电路。</p></li><li><p>时序和电气特性模型： 工艺库文件中包含了不同元件的时序特性和电气特性的模型，例如延迟、功耗、面积、电压等。这些模型允许综合工具在生成电路时考虑这些关键性能参数。</p></li><li><p>约束信息： 工艺库文件包括与制造工艺相关的约束信息，如晶体管尺寸、金属层规则、布线资源、最小间距、最小尺寸等。这些约束信息确保生成的电路在特定工艺下能够正确制造。</p></li><li><p>优化和分析： 工艺库文件中的信息用于进行优化和分析。综合工具使用工艺库中的特性来选择最佳电路结构，以满足性能、功耗和面积等要求。</p></li><li><p>工艺相关的约束： 工艺库文件还包含了与工艺相关的约束，如抖动、噪声、温度等。这些约束信息在特殊情况下，如高性能或低功耗设计时，起到关键作用。</p></li><li><p>制造可行性： 工艺库文件确保综合工具生成的电路在实际工艺下是可制造的。这包括考虑工艺的限制，以避免制造上的问题。</p></li></ul><p>DC使用工艺库文件来将逻辑网表转化为物理电路，确保生成的电路在特定工艺下满足性能、功耗和面积等方面的要求。因此，工艺库文件是IC设计工具中至关重要的一部分，它们在整个设计流程中起着关键的作用。</p><h3 id="常见库文件"><a href="#常见库文件" class="headerlink" title="常见库文件"></a>常见库文件</h3><ol><li>目标库（target_library）：主要包含电路的标准单元；</li><li>链接库（link_library）：包含付费IP、存储器、IO、PAD；</li><li>符号库（symbol_library）：定义了在GUI界面中综合后的电路如何显示；</li><li>算术运算库（synthetic_library）：对基本的算子进行映射，即Design Ware library；<h3 id="目标库"><a href="#目标库" class="headerlink" title="目标库"></a>目标库</h3>目标库是综合后电路网表要最终映射到的库。<br>读入的HDL代码首先由Synopsys自带的GTECH库转成DC内部交换的格式，然后经过映射到目标库，最后生成优化的门级网表。<br>目标库一般是db格式，由lib格式转化而来。<br>目标库包含了各个门级单元的行为、引脚、面积、时序信息等，有的还包含了功耗方面的参数。<br>DC在综合时就是根据目标库中给出的信息来计算路径的延时，并根据各个单元的延时、面积和驱动能力的不同选择合适的单元来优化电路。</li></ol><h3 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h3><p>链接库是设置模块或单元电路的引用。<br>对于所有DC可能用到的库，我们都需要在link_library中指定，也包括要用到的IP。<br><strong>在link_library的设置中必须包含“*”，表示DC在引用实例化模块或者单元电路时首先搜索已经调进DC的模块和单元电路。</strong></p><h3 id="符号库"><a href="#符号库" class="headerlink" title="符号库"></a>符号库</h3><p>符号库是定义了单元电路显示的原理图库，查看分析电路图时，需要设置sdb格式的符号库。</p><h3 id="算术运算库"><a href="#算术运算库" class="headerlink" title="算术运算库"></a>算术运算库</h3><p>在初始化DC时，不需要设置标准的DesignWare库standard.sldb用于实现verilog描述的运算符，DC会把加法、乘法等运算综合成性能较差的电路。<br>如果需要扩展DesignWare，需要在synthetic_library中设置，同时需要在link_library中设置相应的库以使得在链接的时候DC可以搜索到相应运算符的实现。（注意：DesignWare需要更高级的licence）</p><h2 id="DC约束"><a href="#DC约束" class="headerlink" title="DC约束"></a>DC约束</h2><h3 id="DRC约束"><a href="#DRC约束" class="headerlink" title="DRC约束"></a>DRC约束</h3><p>DRC（Design Rule Check）用于确保生成的电路与制造工艺的物理规则和限制相符，在综合过程中的主要作用是确保所生成的电路在制造时不会违反工艺规则，从而提高设计的可制造性，减少错误，确保电路性能和功耗在预期范围内，并支持工艺迁移。这些约束对于确保IC设计的成功和高质量至关重要。<br>常见的DRC约束有以下三种：</p><ol><li>set_max_transition：约束design中的信号、端口、net最大transition不能超过这个值，值越小越苛刻；net的transition time取决于net的负载（fanout），负载越大，transition time越大；<ol><li>set_max_fanout：对design、net、output port进行操作，该约束用于限制一个逻辑门（或一个寄存器）的输出信号驱动的负载数量。它规定了一个逻辑门的输出可以连接到多少个输入；（Max fanout load of net is max number of loads the net can drive. ）</li><li>set_max_capacitance：该约束用于限制一个逻辑门（或一个寄存器）的输出信号所能驱动的总负载电容。它规定了一个输出信号的负载电容的上限。（Sets a maximum capacitance for the nets attached to the specified ports or to all the nets<br>in a design.）<br>上述约束的具体数值由工艺厂商提供，但在电路设计中可以进行过约。</li></ol></li></ol><blockquote><p>transition time is the time needed to transition from one logic state to the other.</p></blockquote><p><code>set_max_fanout</code>和<code>set_max_capacitance</code>都是对负载进行约束，它们的主要区别在于这两种约束的优化目标。<code>set_max_fanout</code> 约束主要关注电路的时序和延迟，而 <code>set_max_capacitance</code> 约束关注电路的功耗（电路的功耗与负载电容成正比）。</p><h3 id="面积约束"><a href="#面积约束" class="headerlink" title="面积约束"></a>面积约束</h3><p>DC中的面积约束用于规定电路的逻辑元件在芯片上的最大布局面积，有助于控制设计的复杂性。约束面积的命令示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_max_area 100</span><br></pre></td></tr></table></figure><p>上述命令中100的单位由库单元的面积单位决定，有以下三种单位：两输入与非门个数，晶体管个数，平方微米。<br><strong>一般会在面积约束时，将最大面积设置为0</strong>。因为在DC工具中，默认设置是Timing Constraints比Area Constraints的优先级高，因此DC会在首先保证时序收敛的同时，探索面积最小的综合结果。</p><h3 id="时序约束"><a href="#时序约束" class="headerlink" title="时序约束"></a>时序约束</h3><p>有很多学习资料将时序约束分析的非常透彻了，这里就暂时跳过了。后面可能会出关于时序约束分析的专题博客，给大家提供一个不错的学习网站，里面的STA分析的较为透彻。<a href="https://vlsitutorials.com/">VLSI Tutorials</a></p><h3 id="环境约束"><a href="#环境约束" class="headerlink" title="环境约束"></a>环境约束</h3><p>在对设计进行优化之前，我们必须定义Design预期运行的环境。通过指定操作条件、系统接口特征和线路负载模型来进行环境约束。操作条件包括温度、电压和工艺变化。系统接口特性包括输入驱动、输入输出负载和扇出负载。环境约束直接影响设计综合效果。</p><h4 id="设置操作条件"><a href="#设置操作条件" class="headerlink" title="设置操作条件"></a>设置操作条件</h4><p>工艺库中一般提供了几种工作条件的模型以供选择：</p><ul><li>最好情况（best case）：用于对保持时间的时序分析；</li><li>典型情况（typical case）：一般不考虑；</li><li><p>最坏情况（worst case）：用于对建立时间的时序分析；</p><h4 id="驱动强度"><a href="#驱动强度" class="headerlink" title="驱动强度"></a>驱动强度</h4><p>为了准确评估输入接口的时序结果，DC工具需要知道输入接口的驱动强度。驱动强度为Driver阻抗的倒数，输入接口的transition delay为Driver阻抗×输入端口的电容负载。DC默认Driver阻抗为0，即驱动强度为无穷。可以通过<code>set_driving_cell</code>，<code>set_drive</code>，<code>set_input_transition</code>来对驱动强度进行设置。</p><h4 id="线负载模型"><a href="#线负载模型" class="headerlink" title="线负载模型"></a>线负载模型</h4><p>在DC综合的过程中，net延时是通过设置线负载模型（wire load model）确定的。线负载模型基于net的扇出，对net的电阻电容等寄生参数进行计算。线负载模型的计算函数也是由晶圆厂提供的，晶圆厂则是对使用该工艺流片的芯片的net延时进行统计，从而得到该经验值。<br>设置线负载模型可以通过“set_wire_load_model”命令完成，也可以让DC自动根据综合出来的模块面积大小选择负载模型。默认情况下是DC自动选择。<br>上面说的是模块内的线负载模型，对于模块间的线负载模型，存在一些跨模块的net，它们的wire_load_mode有以下三种决定方式：<br><img src="https://raw.githubusercontent.com/XduDavid/Blog_Img/main/%E7%BA%BF%E8%B4%9F%E8%BD%BD%E6%A8%A1%E5%9E%8B.png" alt="线负载模型"></p></li><li><p>顶层（top）：所有submodule的线负载模型都用顶层模块的线负载模型代替；</p></li><li>围绕（enclosed）：net的负载模型用<strong>完全包含该net的模块</strong>的线负载模型代替；</li><li>分段（segment）：根据net所在的模块，分段对其使用线负载模型进行估计；</li></ul><h4 id="输出负载"><a href="#输出负载" class="headerlink" title="输出负载"></a>输出负载</h4><p>为了更准确的估计模块输出的时序，除了要知道输出延时之外，还需要知道输出的负载大小。如果输出负载会影响电路的transition time，进而影响时序特性。如果DC默认输出负载为0，即相当于不接负载的情况，这样综合出来的电路时序显然过于乐观，不能反映实际工作情况。<br>我们可以使用set_load设定load值，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_load 30 [get_ports OUT1]</span><br></pre></td></tr></table></figure><p>其中“30”的单位可以用<code>report_lib</code>命令进行查看，即Capacitive Load Unit对应的单位。</p><h3 id="DC输出结果"><a href="#DC输出结果" class="headerlink" title="DC输出结果"></a>DC输出结果</h3><ul><li>整个工程以ddc格式保存下来以供后续查看和修改；</li><li>网表netlist，用于布局布线和仿真；</li><li>sdf文件，标注了用到的标准单元的延迟值，后仿真也需要用到；</li><li>面积报告，包含时序电路、组合电路和总电路面积；</li><li>约束报告，给出了综合过程中没有满足要求的约束；</li><li>时序报告，包含建立时间和保持时间；</li><li>svf文件，包含了DFT和Formality所需的信息，供后续使用；</li></ul>]]></content>
    
    
    <summary type="html">DC工具扫盲</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="EDA" scheme="http://david-luge.cn/categories/IC/EDA/"/>
    
    
    <category term="EDA" scheme="http://david-luge.cn/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>HLS入门简述</title>
    <link href="http://david-luge.cn/2023/03/29/FPGA/HLS%E5%85%A5%E9%97%A8%E7%AE%80%E8%BF%B0/"/>
    <id>http://david-luge.cn/2023/03/29/FPGA/HLS%E5%85%A5%E9%97%A8%E7%AE%80%E8%BF%B0/</id>
    <published>2023-03-29T02:54:39.000Z</published>
    <updated>2023-03-29T02:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What‘s-HLS？"><a href="#What‘s-HLS？" class="headerlink" title="What‘s HLS？"></a>What‘s HLS？</h2><p>HLS（High-Level Synthesis）高层次综合。何谓高层次？意味着我们可以使用高层次的语言来对设计进行描述，如C，C++，System C等；那何谓综合呢？HLS在其中起了重要的<strong>转换</strong>作用，将高层次的抽象语言转换为寄存器传输级语言（register transfer level，RTL），这样我们可以将其映射到FPGA的器件中，进行硬件实现，此谓综合。</p><p>简单来说，我们通过HLS工具，可以将C，C++等高级语言描述的算法转换为可以进行硬件部署的代码，缩短我们的开发时间。那有同学就兴奋了：“硬件开发真简单，把算法思路拿C语言验证一下，再用HLS工具转换一下代码就ok了，我上我也行。”这种说法对，也不对。开发的流程是对的，先用高级语言对算法进行验证，再进行硬件实现，不对的地方在于没那么简单（手动狗头），或者说想要高效的硬件实现没那么简单。</p><h2 id="Why-HLS？"><a href="#Why-HLS？" class="headerlink" title="Why HLS？"></a>Why HLS？</h2><p>讲完What就该讲Why了，说到Why其实就是说说HLS有哪些优势值得我们选择呢？在这里我搬运一下Xilinx官方文档里面“自夸”的部分：</p><blockquote><p>High-level synthesis bridges hardware and software domains, providing the following primary benefits:</p><p>Improved productivity for hardware designers：Hardware designers can work at a higher level of abstraction while creating high-performance hardware.</p><p>Improved system performance for software designers：Software developers can accelerate the computationally intensive parts of their algorithms on a new compilation target, the FPGA.</p><p>Using a high-level synthesis design methodology allows you to:</p><p>Develop algorithms at the C-level：Work at a level that is abstract from the implementation details, which consume development time.</p><p>Verify at the C-level：Validate the functional correctness of the design more quickly than with traditional hardware description languages.</p><p>Control the C synthesis process through optimization directives：Create specific high-performance hardware  implementations.</p><p>Create multiple implementations from the C source code using optimization directives：Explore the design space, which increases the likelihood of finding an optimal implementation.</p><p>Create readable and portable C source code：Retarget the C source into different devices as well as incorporate the C source into new projects.</p></blockquote><p>我来给大家省流一下，HLS工具对硬件开发者的抽象程度更高，对于软件开发者而言，更方便把算法放FPGA上进行加速了。也就是硬件开发软件化，降低了软件工作者使用FPGA平台进行算法加速的门槛。</p><p>那HLS的设计方法有哪些过人之处呢？1、设计的层次更高，不用过多关注设计细节；2、在C-Level就可以进行设计的验证工作；3、使用一些HLS的优化约束语句就可以控制综合结果的性能；4、基于同一套C Code，使用不同组合的优化约束可以生成性能不同的综合结果，来探索设计空间；5、同一套C Code可以映射到不同的硬件平台中，重塑性强。</p><p>说了那么多，那HLS用起来方便不，又是C代码，又是约束的。我们看一下官方文档里对HLS输入输出的说明：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303250915611.png" alt="1"></p><p>输入主要包括：用C、C++、SystemC编写的函数；设计约束，包括时钟频率、时钟不确定度、目标平台等信息；优化指示，来引导HLS工具做综合方面的优化，如面积优先or速度优先；C语言的testbench以及相关的测试文件；</p><p>输出主要包括：使用HDL描述的设计；报告文件；</p><p>其实各方向的知识基本都符合二八定律，即掌握20%的知识就可以解决80%的问题，其余80%的知识主要用来fix各种corner的情况，本文希望能把20%最重要的东西讲明白，让大家能对HLS有个初步印象，那我们开始吧。</p><h2 id="Optimizing-the-Design"><a href="#Optimizing-the-Design" class="headerlink" title="Optimizing the Design"></a>Optimizing the Design</h2><p>本章主要介绍一些优化技巧，来指导HLS进行综合。通过了解如何对设计进行优化，来提升大家对HLS工具的兴趣。</p><blockquote><p>NOTE：后续所述知识需要同学具有如下基础：了解FPGA基本组成结构，了解 BRAM 资源特性，了解 真双口/伪双口 RAM 的区别，有一定的 C 语言基础，了解指针等基础概念。</p></blockquote><h3 id="时钟、复位和RTL输出"><a href="#时钟、复位和RTL输出" class="headerlink" title="时钟、复位和RTL输出"></a>时钟、复位和RTL输出</h3><h4 id="指定时钟频率"><a href="#指定时钟频率" class="headerlink" title="指定时钟频率"></a>指定时钟频率</h4><p><u>对于 C 和 C++ 设计，仅支持单一时钟。</u>对设计中的所有函数将应用同一个时钟。</p><p>对于 SystemC 语言设计，每个 SC_MODULE 都必须使用不同时钟来指定。要在 SystemC 语言设计中指定多个时钟，需要使用 create_clock 命令的 -name 选项来创建多个指定时钟，并使用 CLOCK 指令或编译指示来指定哪个函数包含将以指定时钟进行综合的 SC_MODULE。</p><p>时钟周期（以 ns 为单位）在“Solutions” → “Solutions Setting”中设置。Vivado HLS 使用时钟不确定性概念来提供用户定义的时序裕度。通过使用时钟频率和器件目标信息，Vivado HLS 可估算设计中的操作时序，但无法确定最终组件布局和信号线布线：这些操作由输出 RTL 的逻辑综合来执行。</p><p>为计算用于综合的时钟周期，Vivado HLS 会从时钟周期减去时钟不确定性，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251114447.png" alt="image-20230325111459414"></p><p>这样可为用户提供指定裕度以确保下游进程（例如，逻辑综合与布局布线）具有足够的时序裕度来完成其操作。如果FPGA 器件利用率过高，那么单元的布局以及用于连接单元的信号线的布线可能无法达成理想状态，并且可能导致设计的时序延迟大于期望值。对于此类情况，增加时序裕度可避免 Vivado HLS 所创建的设计在每个时钟周期内综合过多的逻辑运算，并在布局布线选项不太理想的情况下使 RTL 综合仍能满足时序。默认时钟不确定性为周期时间的 12.5%，设计者可以在时钟周期设置的旁边显式指定该值。</p><blockquote><p>NOTE：综合后复查约束的报告至关重要：实际上虽然 Vivado HLS 可生成输出设计，但并不能保证设计满足所有性能约束。请复查设计报告的“性能估算 (Performance Estimates)”部分。</p></blockquote><h4 id="指定复位"><a href="#指定复位" class="headerlink" title="指定复位"></a>指定复位</h4><p>通常 RTL 配置中最重要的操作即选择复位行为。对于复位行为，重要的是理解初始化与复位之间的差异。</p><p>初始化行为，指在 C 中，以静态限定符定义的变量，以及全局作用域中定义的变量默认都初始化为 0。对于这些变量，可赋予特定初始值。对于这两种类型的变量，C 语言代码中的初始值在编译时（时序为 0 时）进行赋值，并且不再进行赋值。上述两种情况下，在 RTL 中实现的初始值相同。</p><ul><li>在 RTL 仿真期间，为这些变量设置的初始值与 C 语言代码中相同。</li><li>在用于对 FPGA 进行编程的比特流中同样会对这些变量进行初始化。当器件上电时，变量将以其初始状态启动。</li></ul><p>变量启动时的初始状态与 C 语言代码中相同，<u>但无法强制返回此初始状态</u>。要返回初始状态，必须通过复位来实现。</p><p>那么我们如何控制复位行为呢？复位端口在 FPGA 中用于在应用复位信号时，立即将连接到复位端口的寄存器和 BRAM 还原为初始值。config_rtl 配置可用于控制 RTL 复位端口是否存在及其行为，如下图所示。要访问此配置，请选择“Solution” → “Solution Settings” → “General” → “Add” → “config_rtl”。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251121143.png" alt="image-20230325112128090"></p><p>复位设置包含设置复位极性以及使用同步复位还是异步复位的功能，但更重要的是，它可通过“reset”选项来控制应用复位信号时要复位的寄存器。“reset”选项包含 4 项设置：</p><ul><li>“none”：不向设计添加任何复位。</li><li>“control”：这是默认设置，用于确保将所有控制寄存器复位。控制寄存器即状态机中使用的寄存器，用于生成 I/O 协议信号。此设置可确保设计可立即启动其操作状态。</li><li>“state”：该选项可为控制寄存器添加复位（与“control”设置相同），并且还可为衍生自 C 语言代码中的静态变量和全局变量的任意寄存器或memory添加复位。此设置可确保应用复位后，C 语言代码中初始化的<strong>静态变量和全局变量</strong>均复位为其初始值。</li><li>“all”：为设计中的所有寄存器和memory添加复位。</li></ul><p>通过 RESET 指令可提供更精细的复位控制。对于静态变量或全局变量，RESET 指令可用于为其显式添加复位，或者可将该变量从使用 RESET 指令的 off 选项复位的变量中移除。当设计中存在静态数组或全局数组时，该选项非常实用。</p><blockquote><p>NOTE：当在设计上使用 AXI4 接口时，复位极性会自动更改为低电平有效，而与 config_rtl 配置中的设置无关。这与 AXI4 标准的要求有关。</p></blockquote><p>对数组而言，其通常定义为静态变量，这表明所有元素都将初始化为 0，且数组通常使用 BRAM 来实现。使用复位选项 state 或 all 时，会强制将用 BRAM 实现的所有数组在复位后都返回初始化状态。这可能导致 RTL 设计中出现不好的现象：</p><ul><li>不同于上电初始化，显式复位要求 RTL 设计对 BRAM 中的每个地址进行迭代以设置值：如果 N 较大，这可能导致复位所需的时钟周期数量显著增加，并增加资源占用。</li><li>设计中的每个数组中都有复位信号。</li></ul><p>为防止在此类 BRAM 上都放置复位逻辑，并避免因复位 BRAM 中的所有元素而产生的周期开销，建议执行以下操作：</p><ul><li>使用默认 control 复位模式，并使用 RESET 指令来指定要复位的每个静态变量或全局变量。</li><li>或者，使用 state 复位模式，并使用 RESET 指令的 off 选项从特定静态变量或全局变量中移除复位。</li></ul><h4 id="RTL输出"><a href="#RTL输出" class="headerlink" title="RTL输出"></a>RTL输出</h4><p>可使用 config_rtl 配置来控制 Vivado HLS 的各种 RTL 输出特性：</p><ul><li>指定 RTL 状态机中使用的 FSM 编码类型。</li><li>使用 -header 选项可向所有 RTL 文件添加任意注释字符串（例如，版权声明）。</li><li>使用 prefix 选项可指定要添加到所有 RTL 输出文件名的唯一名称。</li><li>强制 RTL 端口使用小写名称。</li></ul><p>默认 FSM 编码样式为 onehot。其它可用选项包括 auto、binary 和 gray。如果选择 auto，Vivado HLS 可使用onehot 默认设置来实现编码样式，但 Vivado Design Suite 可在逻辑综合期间提取并重新实现 FSM 样式。</p><h3 id="最优化设计的吞吐量"><a href="#最优化设计的吞吐量" class="headerlink" title="最优化设计的吞吐量"></a>最优化设计的吞吐量</h3><p>使用以下约束来提高吞吐量，或降低函数的启动时间间隔。首先对于函数和循环，可以进行流水线设计，提高数据的吞吐率；其次对于内存读写端口受限的场景，设计者通过对数组进行合适的分区，来将其分布到不同的 BRAM 中，解决读写端口受限的问题；然后对于数据依赖的问题，要仔细分析是否为假性的数据依赖；最后对循环进行适当的展开以改善流水线性能，并在任务级别进行并行化处理。</p><h4 id="函数与循环流水线化"><a href="#函数与循环流水线化" class="headerlink" title="函数与循环流水线化"></a>函数与循环流水线化</h4><p>流水线化允许并行执行操作：每个执行步骤无需等待完成所有操作后再开始下一项操作。流水线化适用于函数和循环。下图显示了通过函数流水线化实现的吞吐量提升。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251131428.png" alt="image-20230325113130389"></p><p>如果不使用流水线化，上述示例中的函数将每隔 3 个时钟周期读取一次输入，并在 2 个时钟周期后输出值。该函数启动时间间隔 (Initiation Interval，II) 为 3，时延为 3。使用流水线化后，对于此示例，每个周期都会读取 1 次新输入 (II=1)，且不更改输出时延。</p><p>循环流水线化支持以重叠方式来实现循环中的操作。在下图中，(A) 显示了默认顺序操作，每次输入读操作间存在 3 个时钟周期 (II=3)，需要经过 8 个时钟周期才会执行最后一次输出写操作。</p><p>在 (B) 所示的循环的流水线版本中，每个周期都会读取一次新输入样本 (II=1)，仅需 4 个时钟周期后即可写入最终输出，在使用相同硬件资源的前提下显著改善 II 和时延。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251133878.png" alt="image-20230325113338843"></p><p>函数或循环使用 PIPELINE 指令来实现流水线化。该指令需要在函数或循环主体区域中进行指定。启动时间间隔如果不指定，则默认为 1，但也可设置为其它值。</p><p>流水线化仅应用于指定区域，而不应用于下层层级。但<strong>下层层级内所有循环都会自动展开</strong>。指定函数的下层层级内的所有子函数都必须单独流水线化。如果将子函数流水线化，其上层的已流水线化的函数即可充分发挥流水线性能。反之，<u>已流水线化的顶层函数下层的任意子函数如果不采用流水线化，则可能限制流水线性能。</u></p><p>已流水线化的函数与已流水线化的循环之间行为存在差异。对于函数，流水线将永久运行，永不终止。对于循环，流水线将持续执行直至循环的所有迭代完成为止。在下图中总结了行为差异。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251136380.png" alt="image-20230325113606339"></p><p>行为差异会影响流水线输入和输出的处理方式。如上图所示，已流水线化的函数将持续读取新输入和写入新输出。相比之下，由于循环必须首先完成循环中的所有操作，然后才能启动下一次循环，已流水线化的循环会导致数据流传输中出现“气泡”；即，当循环完成最终迭代后不读取任何输入数据的时间点，以及当开始新循环迭代时没有输出数据的时间点。</p><h5 id="Rewind已流水线化的循环以保障性能"><a href="#Rewind已流水线化的循环以保障性能" class="headerlink" title="Rewind已流水线化的循环以保障性能"></a>Rewind已流水线化的循环以保障性能</h5><p>为避免前图中所示的问题，PIPELINE 编译指示具有可选 rewind 命令。此命令支持将后续调用的迭代进行重叠执行，前提是此循环为数据流进程顶层函数的最外层的构造（并且多次调用数据流区域）。</p><p>下图显示了对循环进行流水线化时使用 rewind 选项的操作。循环迭代计数结束时，循环将开始重新执行。虽然一般情况下它立即重新执行，但也可能出现延迟。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251139601.png" alt="image-20230325113921563"></p><blockquote><p>NOTE：如果在 DATAFLOW 区域周围使用循环，Vivado HLS 会自动将其实现以允许后续迭代进行重叠。</p></blockquote><h5 id="自动循环流水线化"><a href="#自动循环流水线化" class="headerlink" title="自动循环流水线化"></a>自动循环流水线化</h5><p>config_compile 配置支持根据迭代计数对循环进行自动流水线化。此配置可通过菜单“Solution” → “Solution Setting” → “General” → “Add” → “config_compile”访问。</p><p>pipeline_loops 选项可用于设置循环边界的限制。低于此限制的单一迭代计数内的所有循环都将自动流水线化。默认值为0：不执行自动循环流水线化。</p><p>给定以下示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">480</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">640</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">// do something 5 times</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 pipeline_loops 选项设置为 6，那么以上代码片段中最内层的 for 循环将自动流水线化。这等同于以下代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">480</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">640</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS PIPELINE II=1</span></span><br><span class="line"><span class="comment">// do something 5 times</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设计中有部分无需使用自动流水线化的循环，请对此类循环应用含 off 选项的 PIPELINE 指令。off 选项可阻止自动循环流水线化。</p><blockquote><p>NOTE：Vivado HLS 会在执行所有用户指定的指令后应用 config_compile pipeline_loops 选项。例如，如果 Vivado HLS 向循环应用用户指定的 UNROLL 指令，那么将首先展开该循环，但无法应用自动循环流水线化。</p></blockquote><h5 id="流水线化失败的问题"><a href="#流水线化失败的问题" class="headerlink" title="流水线化失败的问题"></a>流水线化失败的问题</h5><p>将函数流水线化时，下层层级内所有循环都会自动展开。这是继续执行流水线化的前提。如果循环的边界是一个变量，则无法展开。这将导致无法对函数进行流水线化。</p><p>其次是数据依赖的问题，静态变量用于在循环迭代间保留数据，这通常在导致最终实现时生成寄存器。如果在用流水线实现的函数中遇到此变量，vivado_hls 可能无法对设计进行充分最优化，这可能导致启动时间间隔超过所需的时间。下面给出代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function_foo()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> change = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (condition_xyz)&#123;</span><br><span class="line">change = x; <span class="comment">// store</span></span><br><span class="line">&#125;</span><br><span class="line">y = change; <span class="comment">// load</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vivado_hls 无法最优化此代码，则存储操作需要 1 个周期，加载操作也需要 1 个周期。如果此函数包含在流水线中，那么流水线必须以最小启动时间间隔 2 来实现，因为数据间存在依赖关系。</p><p>用户可通过重写代码来避免此问题，如下例所示。它可确保在循环的每次迭代中仅存在读操作或写操作，这样即可以II=1 来调度设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function_readstream()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> change = <span class="number">0</span></span><br><span class="line">    <span class="type">bool</span> change_temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (condition_xyz)</span><br><span class="line">    &#123;</span><br><span class="line">        change = x; <span class="comment">// store</span></span><br><span class="line">        change_temp = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    change_temp = change; <span class="comment">// load</span></span><br><span class="line">    &#125;</span><br><span class="line">    y = change_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过数组分区来改善流水线化"><a href="#通过数组分区来改善流水线化" class="headerlink" title="通过数组分区来改善流水线化"></a>通过数组分区来改善流水线化</h4><p>以下消息显示了对函数进行流水线化时常见的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INFO: [SCHED <span class="number">204</span><span class="number">-61</span>] Pipelining loop <span class="string">&#x27;SUM_LOOP&#x27;</span>.</span><br><span class="line">WARNING: [SCHED <span class="number">204</span><span class="number">-69</span>] Unable to schedule <span class="string">&#x27;load&#x27;</span> operation (<span class="string">&#x27;mem_load_2&#x27;</span>,bottleneck.c:<span class="number">62</span>) on <span class="built_in">array</span> <span class="string">&#x27;mem&#x27;</span> due to limited memory ports.</span><br><span class="line">WARNING: [SCHED <span class="number">204</span><span class="number">-69</span>] The resource limit of core:RAM:mem:p0 is <span class="number">1</span>, current assignments:</span><br><span class="line">WARNING: [SCHED <span class="number">204</span><span class="number">-69</span>] <span class="string">&#x27;load&#x27;</span> operation (<span class="string">&#x27;mem_load&#x27;</span>, bottleneck.c:<span class="number">62</span>) on <span class="built_in">array</span> <span class="string">&#x27;mem&#x27;</span>,</span><br><span class="line">WARNING: [SCHED <span class="number">204</span><span class="number">-69</span>] The resource limit of core:RAM:mem:p1 is <span class="number">1</span>, current assignments:</span><br><span class="line">WARNING: [SCHED <span class="number">204</span><span class="number">-69</span>] <span class="string">&#x27;load&#x27;</span> operation (<span class="string">&#x27;mem_load_1&#x27;</span>, bottleneck.c:<span class="number">62</span>) on <span class="built_in">array</span> <span class="string">&#x27;mem&#x27;</span>,</span><br><span class="line">INFO: [SCHED <span class="number">204</span><span class="number">-61</span>] Pipelining result: Target II: <span class="number">1</span>, Final II: <span class="number">2</span>, Depth: <span class="number">3.</span></span><br></pre></td></tr></table></figure><p>在此示例中，Vivado HLS 声明它无法达成指定的初始时间间隔 (II) 值 1，因为<u>它受内存端口所限</u>，无法在内存上调度 load（读取）操作 (mem_load_2)。以上消息指出了第 62 行上的 mem_load 操作所使用的“core:RAM:mem:p0 is 1”的资源限制。BRAM 的第 2 个端口同样仅含 1 项资源，该资源同样供 mem_load_1 操作使用。由于存在此内存端口争用，Vivado HLS 报告的最终 II 为 2，而不是所期望的值 1。</p><p>此问题通常是由数组所导致的。数组作为最多只含有 2 个数据端口的 BRAM 来实现。这可能限制读写（或加载/存储）密集型算法的吞吐量。通过将该数组（单一 BRAM 资源）拆分为多个更小的数组（多个 BRAM）从而有效增加端口数量，即可改善带宽。</p><p>数组可使用 ARRAY_PARTITION 指令来进行分区。Vivado HLS 可提供 3 种类型的数组分区，如下图所示。这 3 种分区样式分别是：</p><ul><li>block：原始数组分割为原始数组的连续元素块（大小相同）。</li><li>cyclic：原始数组分割多个大小相同的块，这些块交织成原始数组的元素。</li><li>complete：默认操作是将数组按其独立元素进行拆分。这对应于将内存解析为寄存器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281438234.png" alt="image-20230328143809185"></p><p>对于 block 和 cyclic 分区，factor 选项可指定要创建的数组数量。在前图中，使用因子 2，即将数组分割为 2 个更小的数字。如果数组的元素数量并非该因子的整数倍，那么最后一个数组所含元素数量较少。</p><p>对多维数组进行分区时，dimension 选项可用于指定对哪个维度进行分区。下图显示了使用 dimension 选项对以下代码示例进行分区的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_array[<span class="number">10</span>][<span class="number">6</span>][<span class="number">4</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此图中的示例演示了如何通过对 dimension 3 进行分区来生成 4 个独立数组，以及如何对 dimension 1 进行分组以生成 10 个独立分区。如果针对 dimension 指定 0，则将对所有维度进行分区。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281440335.png" alt="image-20230328144017300"></p><h5 id="自动数组分区"><a href="#自动数组分区" class="headerlink" title="自动数组分区"></a>自动数组分区</h5><p>config_array_partition 配置可根据元素数量判定数组的自动分区方式。此配置可通过菜单“Solution” →“Solution Settings” → “General” → “Add” → “config_array_partition”访问。</p><p>通过 throughput_driven 选项可对分区阈值进行调整，并且可完全实现自动分区。选中 throughput_driven 选项时，<u>Vivado HLS 会自动对数组进行分区以实现指定的吞吐量。</u></p><h4 id="与Vivado-HLS之间的依赖关系"><a href="#与Vivado-HLS之间的依赖关系" class="headerlink" title="与Vivado HLS之间的依赖关系"></a>与Vivado HLS之间的依赖关系</h4><p>Vivado HLS 会构造对应于 C 语言源代码的硬件数据路径。</p><p>如果没有流水线指令，将按顺序执行，并且不考虑任何依赖关系。但对设计进行流水线时，该工具仍需对 Vivado HLS生成的硬件的处理器架构中发现的依赖关系进行处理。</p><p>数据依赖关系或内存依赖关系的典型用例是在完成上一次读操作或写操作后再次发生读操作或写操作。</p><ul><li><p>先写后读 (RAW) 操作也称为真性依赖关系，它表示指令（及其读取/使用的数据）从属于前一次操作的结果。</p><ul><li>I1: t = a * b;</li><li>I2: c = t + 1;</li></ul><p>语句 I2 中的读操作取决于语句 I1 中的 t 的写操作。如果对指令进行重新排序，它会使用 t 的前一个值，导致结果错误。</p></li><li><p>先读后写 (WAR) 操作也称为反依赖关系，它表示当前一条指令完成数据读取后，下一条指令才能更新寄存器或内存（通过写操作）。</p><ul><li>I1: b = t + a;</li><li>I2: t = 3;</li></ul><p>语句 I2 中的写操作无法在语句 I1 之前执行，否则 b 的结果无效。</p></li><li><p>先写后写 (WAW) 依赖关系表示必须按特定顺序写入寄存器或内存，否则可能破坏其它指令。</p><ul><li>I1: t = a * b;</li><li>I2: c = t + 1;</li><li>I3: t = 1;</li></ul><p>语句 I3 中的写操作必须晚于语句 I1 中的写操作。否则，语句 I2 结果将出错。</p></li><li><p>先读后读不含任何依赖关系，因为只要变量未声明为volatile，即可随意对指令进行重新排序。如果变量声明为volatile，则必须保留指令顺序不变。</p></li></ul><p>例如，生成流水线时，工具需确保后续阶段读取的寄存器或内存位置没有被之前的写操作修改。这属于真性依赖关系或先写后读 (RAW) 依赖关系。具体示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t,c;</span><br><span class="line">    I1: t = a * b;</span><br><span class="line">    I2: c = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在语句 I1 完成前，无法对语句 I2 求值，因为与 t 变量之间存在依赖关系。在硬件中，如果乘法需耗时 3 个时钟周期，那么 I2 将发生等同于此时间量的延迟。如果对以上函数进行流水线化，那么 HLS 会将其检测为真性依赖关系，并对操作进行相应调度，因此函数可按 II =1 来运行，但Latency无法进行优化。</p><p>当此示例应用于数组而不仅是变量时，就会出现内存依赖关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">1</span>,rnext,m,i,out;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mem[<span class="number">256</span>];</span><br><span class="line">    L1: <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">254</span>;i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS PIPELINE II=1</span></span><br><span class="line">        I1: m = r * a; mem[i+<span class="number">1</span>] = m; <span class="comment">// line 7</span></span><br><span class="line">        I2: rnext = mem[i]; r = rnext; <span class="comment">// line 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上示例中，L1 循环的调度导致出现调度警告消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: [SCHED 204-68] Unable to enforce a carried dependency constraint (II = 1, distance = 1) between &#x27;store&#x27; operation (top.cpp:7) of variable &#x27;m&#x27;, top.cpp:7 on array &#x27;mem&#x27; and &#x27;load&#x27; operation (&#x27;rnext&#x27;, top.cpp:8) on array &#x27;mem&#x27;.</span><br><span class="line">INFO: [SCHED 204-61] Pipelining result: Target II: 1, Final II: 2, Depth: 3.</span><br></pre></td></tr></table></figure><p>只要写入的索引不同于读取的索引，那么循环的同一次迭代内就不会发生任何问题。而 2 条指令可同时并行执行。但请观测多次迭代中的读写操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iteration for i=0</span></span><br><span class="line">I1: m = r * a; mem[<span class="number">1</span>] = m; <span class="comment">// line 7</span></span><br><span class="line">I2: rnext = mem[<span class="number">0</span>]; r = rnext; <span class="comment">// line 8</span></span><br><span class="line"><span class="comment">// Iteration for i=1</span></span><br><span class="line">I1: m = r * a; mem[<span class="number">2</span>] = m; <span class="comment">// line 7</span></span><br><span class="line">I2: rnext = mem[<span class="number">1</span>]; r = rnext; <span class="comment">// line 8</span></span><br><span class="line"><span class="comment">// Iteration for i=2</span></span><br><span class="line">I1: m = r * a; mem[<span class="number">3</span>] = m; <span class="comment">// line 7</span></span><br><span class="line">I2: rnext = mem[<span class="number">2</span>]; r = rnext; <span class="comment">// line 8</span></span><br></pre></td></tr></table></figure><p>当考虑到 2 次连续迭代时，来自 I1 语句的乘法结果 m（时延 = 2）将写入某一位置，而循环的下一次迭代的 I2 语句将把位于该位置的结果读取到 rnext 中。在此情况下，存在 RAW 依赖关系，因为上一次计算的写操作完成后，下一次循环迭代才能开始读取 mem[i]。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281459662.png" alt="image-20230328145952611"></p><p>请注意，如果增大时钟频率，那么乘法器将需要更多流水线阶段，从而导致时延增加。这也将迫使 II 增大。</p><p>请注意以下代码，其中操作已发生交换，导致功能发生更改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r,m,i;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mem[<span class="number">256</span>];</span><br><span class="line">    L1: <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">254</span>;i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS PIPELINE II=1</span></span><br><span class="line">        I1: r = mem[i]; <span class="comment">// line 7</span></span><br><span class="line">        I2: m = r * a , mem[i+<span class="number">1</span>]=m; <span class="comment">// line 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调度警告为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO: [SCHED <span class="number">204</span><span class="number">-61</span>] Pipelining loop <span class="string">&#x27;L1&#x27;</span>.</span><br><span class="line">WARNING: [SCHED <span class="number">204</span><span class="number">-68</span>] Unable to enforce a carried dependency <span class="title function_">constraint</span> <span class="params">(II = <span class="number">1</span>, distance = <span class="number">1</span>)</span> between &#x27;store&#x27; <span class="title function_">operation</span> <span class="params">(top.cpp:<span class="number">8</span>)</span> of variable &#x27;m&#x27;, top.cpp:8 on <span class="built_in">array</span> &#x27;mem&#x27; and &#x27;load&#x27; <span class="title function_">operation</span> <span class="params">(<span class="string">&#x27;r&#x27;</span>, top.cpp:<span class="number">7</span>)</span> on <span class="built_in">array</span> &#x27;mem&#x27;.</span><br><span class="line">WARNING: [SCHED 204-68] Unable to enforce a carried dependency <span class="title function_">constraint</span> <span class="params">(II = <span class="number">2</span>, distance = <span class="number">1</span>)</span> between &#x27;store&#x27; <span class="title function_">operation</span> <span class="params">(top.cpp:<span class="number">8</span>)</span> of variable &#x27;m&#x27;, top.cpp:8 on <span class="built_in">array</span> &#x27;mem&#x27; and &#x27;load&#x27; <span class="title function_">operation</span> <span class="params">(<span class="string">&#x27;r&#x27;</span>, top.cpp:<span class="number">7</span>)</span> on <span class="built_in">array</span> &#x27;mem&#x27;.</span><br><span class="line">WARNING: [SCHED 204-68] Unable to enforce a carried dependency <span class="title function_">constraint</span> <span class="params">(II = <span class="number">3</span>, distance = <span class="number">1</span>)</span> between &#x27;store&#x27; <span class="title function_">operation</span> <span class="params">(top.cpp:<span class="number">8</span>)</span> of variable &#x27;m&#x27;, top.cpp:8 on <span class="built_in">array</span> &#x27;mem&#x27; and &#x27;load&#x27; <span class="title function_">operation</span> <span class="params">(<span class="string">&#x27;r&#x27;</span>, top.cpp:<span class="number">7</span>)</span> on <span class="built_in">array</span> &#x27;mem&#x27;.</span><br><span class="line">INFO: [SCHED 204-61] Pipelining result: Target II: 1, Final II: 4, Depth: 4.</span><br></pre></td></tr></table></figure><p>请观测多次迭代中的连续读写操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iteration with i=<span class="number">0</span></span><br><span class="line">I1: r = mem[<span class="number">0</span>]; <span class="comment">// line 7</span></span><br><span class="line">I2: m = r * a , mem[<span class="number">1</span>]=m; <span class="comment">// line 8</span></span><br><span class="line">Iteration with i=<span class="number">1</span></span><br><span class="line">I1: r = mem[<span class="number">1</span>]; <span class="comment">// line 7</span></span><br><span class="line">I2: m = r * a , mem[<span class="number">2</span>]=m; <span class="comment">// line 8</span></span><br><span class="line">Iteration with i=<span class="number">2</span></span><br><span class="line">I1: r = mem[<span class="number">2</span>]; <span class="comment">// line 7</span></span><br><span class="line">I2: m = r * a , mem[<span class="number">3</span>]=m; <span class="comment">// line 8</span></span><br></pre></td></tr></table></figure><p>所需 II 延长，因为存在如下 RAW 依赖关系，从 mem[i] 读取 r、执行乘法并写入 mem[i+1]。</p><h4 id="移除假性依赖关系以改善循环流水线化"><a href="#移除假性依赖关系以改善循环流水线化" class="headerlink" title="移除假性依赖关系以改善循环流水线化"></a>移除假性依赖关系以改善循环流水线化</h4><p>假性依赖关系，即编译器过于保守时出现的依赖关系。这些依赖关系在真实代码中并不存在，但无法由编译器来判定。这些依赖关系可能阻碍循环流水线化。</p><p>假性依赖关系如下示例所示。在此示例中，针对相同循环迭代内的 2 个不同地址执行读写访问。这 2 个地址均依赖于输入数据，可指向 hist 数组中的任一元素。有鉴于此，Vivado HLS 假定这 2 个地址可访问同一个位置。因此，它安排按交替周期对数组执行读写操作，导致循环 II 为 2。<u>但代码显示 hist[old] 和 hist[val] 永远无法访问相同地址，因为这两者包含在 if(old == val) 条件的 else 分支中。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">histogram</span><span class="params">(<span class="type">int</span> in[INPUT SIZE], <span class="type">int</span> hist[VALUE SIZE])</span> f</span><br><span class="line">    <span class="type">int</span> acc = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i, val;</span><br><span class="line">    <span class="type">int</span> old = in[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; INPUT SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> HLS PIPELINE II=1</span></span><br><span class="line">        val = in[i];</span><br><span class="line">        <span class="keyword">if</span>(old == val)</span><br><span class="line">        &#123;</span><br><span class="line">        acc = acc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hist[old] = acc;</span><br><span class="line">            acc = hist[val] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = val;</span><br><span class="line">    &#125;</span><br><span class="line">    hist[old] = acc;</span><br></pre></td></tr></table></figure><p>为克服这一缺陷，我们可以使用 DEPENDENCE 指令，为 Vivado HLS 提供这些依赖关系的附加信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">histogram</span><span class="params">(<span class="type">int</span> in[INPUT SIZE], <span class="type">int</span> hist[VALUE SIZE])</span> &#123;</span><br><span class="line">    <span class="type">int</span> acc = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i, val;</span><br><span class="line">    <span class="type">int</span> old = in[<span class="number">0</span>];</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS DEPENDENCE variable=hist intra RAW false</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; INPUT SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> HLS PIPELINE II=1</span></span><br><span class="line">        val = in[i];</span><br><span class="line">        <span class="keyword">if</span>(old == val)</span><br><span class="line">        &#123;</span><br><span class="line">        acc = acc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hist[old] = acc;</span><br><span class="line">            acc = hist[val] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = val;</span><br><span class="line">    &#125;</span><br><span class="line">    hist[old] = acc;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE：在实际上依赖关系并非 FALSE 的情况下指定 FALSE 依赖关系可能导致硬件错误。指定依赖关系前，请确认它是否正确（TRUE 或 FALSE）。</p></blockquote><p>指定依赖关系时，有 2 种主要类型：</p><ul><li><p>Inter：指定相同循环的不同迭代之间的依赖关系。</p><p>如指定为 FALSE，则当循环已流水线化、已展开或已部分展开时，允许 Vivado HLS 并行执行运算，指定为 TRUE 时则阻止此类并行运算。</p></li><li><p>Intra：指定循环的相同迭代内的依赖关系，例如，在相同迭代开始和结束时访问的数组。</p><p>当 intra 依赖关系指定为 FALSE 时，Vivado HLS 可在循环内自由移动运算、提升运算移动性，从而可能改善性能或面积。当此依赖关系指定为 TRUE 时，必须按指定顺序执行运算。</p></li></ul><h4 id="标量依赖关系"><a href="#标量依赖关系" class="headerlink" title="标量依赖关系"></a>标量依赖关系</h4><p>部分标量依赖关系较难以解析，且通常需要更改源代码。标量数据依赖关系如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) a -= b;</span><br><span class="line">    <span class="keyword">else</span> b -= a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此循环的当前迭代完成 a 和 b 的更新值计算后才能启动下一次迭代，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281509897.png" alt="image-20230328150950867"></p><p>如果必须得到上一次循环迭代结果后才能开始当前迭代，则无法进行循环流水线化。如果 Vivado HLS 无法以指定的启动时间间隔进行流水线化，那么它会增加启动时间间隔。如果完全无法流水线化，则它会停止流水线化并继续输出非流水线化设计。</p><h4 id="最优化循环展开以改善流水线"><a href="#最优化循环展开以改善流水线" class="headerlink" title="最优化循环展开以改善流水线"></a>最优化循环展开以改善流水线</h4><p>默认情况下，在 Vivado HLS 中循环保持处于收起状态。这些收起的循环会生成硬件资源，供循环的每次迭代使用。虽然这样可以节省硬件资源，但有时可能导致性能瓶颈。</p><p>Vivado HLS 可提供使用 UNROLL 指令来展开或部分展开 for 循环的功能。</p><p>下图显示了循环展开的优势以及展开循环时必须考量的影响。此示例假定 a[i]、b[i] 和 c[i] 数组已映射到 BRAM 。此示例显示只需直接应用UNROLL约束即可同时创建大批不同的实现方式。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281515036.png" alt="image-20230328151501979"></p><ul><li>循环未展开：当循环未展开时，每次迭代都在单独的时钟周期内执行。此实现需耗时 4 个时钟周期，只需 1 个乘法器并且每个 BRAM 均可为单端口 BRAM。</li><li>循环部分展开：在此示例中，循环已按因子 2 进行展开。此实现需 2 个乘法器和双端口 RAM ，以支持在同一个时钟周期内读取或写入每个 RAM。但此实现只需 2 个时钟周期即可完成：相比于循环未展开的版本，启动时间间隔和时延均减半。</li><li>循环全部展开：在完全展开的版本中，可在单一时钟周期内执行所有循环操作。但此实现需 4 个乘法器。更重要的是，此实现需在同一个时钟周期内执行 4 次读操作和 4 次写操作的功能。由于 BRAM 最多仅有 2 个端口，因此该实现方式需对数组进行分区。</li></ul><p>要执行循环展开，可向设计中的每个循环应用 UNROLL 指令。或者，可向函数应用 UNROLL 指令，以展开函数作用域内的所有循环。</p><p>如果循环已完全展开，那么只要数据依赖关系和资源允许，即可并行执行所有操作。<u>如果某一循环迭代中的操作需要上一次循环的结果，则这两次迭代无法并行执行，但一旦数据可用即可立即执行。</u></p><p>以下示例演示了如何使用循环展开来创建最优化的设计。在此示例中，数据作为交织式通道存储在数组中。如果按 II=1 来对循环进行流水线化，则每经过 8 个时钟周期才会对<u>每个通道</u>执行依次读取和写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array Order : 0 1 2 3 4 5 6 7 8 9 10 etc. 16</span></span><br><span class="line">etc...</span><br><span class="line"><span class="comment">// Sample Order: A0 B0 C0 D0 E0 F0 G0 H0 A1 B1 C1 etc. A2</span></span><br><span class="line">etc...</span><br><span class="line"><span class="comment">// Output Order: A0 B0 C0 D0 E0 F0 G0 H0 A0+A1 B0+B1 C0+C1 etc. A0+A1+A2</span></span><br><span class="line">etc...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHANNELS 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAMPLES 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N CHANNELS * SAMPLES</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(<span class="type">dout_t</span> d_out[N], <span class="type">din_t</span> d_in[N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, rem;</span><br><span class="line">    <span class="comment">// Store accumulated data</span></span><br><span class="line">    <span class="type">static</span> <span class="type">dacc_t</span> acc[CHANNELS];</span><br><span class="line">    <span class="comment">// Accumulate each channel</span></span><br><span class="line">    For_Loop: <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        rem=i%CHANNELS;</span><br><span class="line">        acc[rem] = acc[rem] + d_in[i];</span><br><span class="line">        d_out[i] = acc[rem];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 factor 为 8 来对循环进行部分展开将允许并行处理每个通道（每 8 个样本为一组），前提是输入数组和输出数组同样按 cyclic 方式进行分区，以便在每个时钟周期内进行多次访问。如果此循环同时采用 rewind 选项来进行流水线化，<u>那么此设计将持续并行处理全部 8 个通道</u>，前提是要以流水线方式（即在顶层或者在数据流区域中）调用这些通道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(<span class="type">dout_t</span> d_out[N], <span class="type">din_t</span> d_in[N])</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_PARTITION variable=d_i cyclic factor=8 dim=1 partition</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_PARTITION variable=d_o cyclic factor=8 dim=1 partition</span></span><br><span class="line"><span class="type">int</span> i, rem;</span><br><span class="line">    <span class="comment">// Store accumulated data</span></span><br><span class="line">    <span class="type">static</span> <span class="type">dacc_t</span> acc[CHANNELS];</span><br><span class="line">    <span class="comment">// Accumulate each channel</span></span><br><span class="line">    For_Loop: <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> HLS PIPELINE rewind</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> HLS UNROLL factor=8</span></span><br><span class="line">        rem=i%CHANNELS;</span><br><span class="line">        acc[rem] = acc[rem] + d_in[i];</span><br><span class="line">        d_out[i] = acc[rem];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分循环展开不要求展开因子为最大迭代计数的整数倍。Vivado HLS 会添加出口检查以确保部分展开的循环的功能与原始循环相同。例如，给定以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] = b[i] + c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按因子 2 展开的循环可将代码有效变换为如下示例所示形式，其中 break 构造器用于确保功能保持不变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">    a[i] = b[i] + c[i];</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span> &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">    a[i+<span class="number">1</span>] = b[i+<span class="number">1</span>] + c[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 N 为变量，Vivado HLS 可能无法判定其最大值（它可能受输入端口驱动）。<u>如果展开因子（在此例中为 2）是最大迭代计数 N 的整数因子，那么 skip_exit_check 选项会移除出口检查和关联的逻辑。</u>展开的效果现在可表示为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">    a[i] = b[i] + c[i];</span><br><span class="line">    a[i+<span class="number">1</span>] = b[i+<span class="number">1</span>] + c[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有助于最大限度降低面积并简化控制逻辑。</p><h4 id="利用任务级别并行化：数据流最优化"><a href="#利用任务级别并行化：数据流最优化" class="headerlink" title="利用任务级别并行化：数据流最优化"></a>利用任务级别并行化：数据流最优化</h4><p>数据流最优化对于一系列顺序任务（例如，函数或循环）很实用，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281531566.png" alt="image-20230328153113527"></p><p>上图显示了连续 3 个任务的特定情况，但通信结构比所示情况可能更复杂。</p><p>通过使用这一系列顺序任务，数据流最优化可以创建并发进程架构，如下所示。数据流最优化是可用于改进设计吞吐量和时延的强大方法。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281531888.png" alt="image-20230328153145851"></p><p>下图显示了数据流最优化允许重叠执行任务的方式，由此可提升总体设计吞吐量并降低时延。</p><p>在以下图示和示例中，(A) 表示无数据流最优化的情况。实现需经历 8 个周期后，func_A 才能处理新输入，还需要 8 个周期后 func_C 才能写入输出。</p><p>对于同样的示例，(B) 表示应用数据流最优化的情况。func_A 每隔 3 个时钟周期即可开始处理新输入（启动时间间隔更低），只需 5 个时钟即可输出最终值（时延更短）。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281532126.png" alt="image-20230328153243077"></p><p>这种类型的并行化势必伴随着硬件开销。将某个特定区域（例如，函数主体或循环主体）识别为要应用数据流最优化的区域时，Vivado HLS 会分析此函数主体或循环主体，并创建独立通道以对数据流进行建模，用于将每项任务的结果存储在数据流区域中。这些通道对于标量变量而言可能只是简单的 FIFO，而对于数组之类非标量变量，则可能是乒乓缓存。其中每个通道还都包含用于指示 FIFO 或乒乓缓存已满或已空的信号。这些信号表示完全数据驱动的握手接口。通过采用独立 FIFO 和/或乒乓缓存，Vivado HLS 可使每项任务按其自己的步调执行，吞吐量仅受输入和输出缓存的可用性限制。由此实现的任务执行交织比正常流水线化实现更好，但导致增加 FIFO 或 BRAM 寄存器（用于乒乓缓存）成本。前图所示的数据流区域实现的结构与下图中相同示例所示结构相同。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281535923.png" alt="image-20230328153521883"></p><p>数据流最优化的性能可能比静态流水线化解决方案的性能更好。它将严格集中控制的流水线停滞理念替换为更灵活的分布式握手架构，后者使用 FIFO 或乒乓缓存。</p><h3 id="时延最优化"><a href="#时延最优化" class="headerlink" title="时延最优化"></a>时延最优化</h3><p>主要思路如下：首先使用时延约束指明HLS工具的优化方向，然后针对循环进行优化，是否可以对循环进行合并以减少时延，是否可以将嵌套的循环扁平化，避免进出循环的时延。</p><h4 id="使用时延约束"><a href="#使用时延约束" class="headerlink" title="使用时延约束"></a>使用时延约束</h4><p>Vivado HLS 支持对任意作用域使用时延约束。时延约束是使用 LATENCY 指令来指定的。</p><p>对作用域施加最大和/或最小 LATENCY 约束时，Vivado HLS 会尝试确保函数内的所有运算都在指定的时钟周期范围内完成。</p><p>应用于循环的时延指令可指定单次循环迭代所需的时延：它指定循环主体的时延，如以下示例所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loop_A: <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS latency max=10</span></span><br><span class="line">    ..Loop Body...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要限制所有循环迭代的总时延，应将时延指令应用于包含整个循环的区域，如以下示例所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Region_All_Loop_A: &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS latency max=10</span></span><br><span class="line">    Loop_A: <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ..Loop Body...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此情况下，即使展开循环，时延指令仍会对所有循环操作设置最大限制。</p><p>如果 Vivado HLS 无法满足最大时延约束，它会放宽时延约束，并尝试尽可能实现最佳结果。</p><p>如果设置最小时延约束，并且 Vivado HLS 生成的设计时延低于所需的最小值，它会插入虚拟时钟周期以满足最小时延（笔者理解这边就是强行打拍）。</p><h4 id="合并顺序循环以减少时延"><a href="#合并顺序循环以减少时延" class="headerlink" title="合并顺序循环以减少时延"></a>合并顺序循环以减少时延</h4><p>所有收起的循环都在设计 FSM 中指明并创建至少一种状态。当存在多个顺序循环时，它可能会创建其它不必要的时钟周期，并阻止进一步的最优化。</p><p>下图显示了一个简单的示例，其中看似直观的编码样式对 RTL 设计的性能产生了负面影响。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281542447.png" alt="image-20230328154214397"></p><p>在上图中，(A) 显示了默认情况下设计中的每个收起的循环如何在 FSM 中创建至少一种状态。在这些状态之间移动需耗费多个时钟周期：假设每个循环迭代需要 1 个时钟周期，则执行两个循环总共需要 11 个周期：</p><ul><li>需要 1 个时钟周期进入 ADD 循环。</li><li>需要 4 个时钟周期执行加法循环。</li><li>需要 1 个时钟周期退出 ADD 并进入 SUB。</li><li>需要 4 个时钟周期执行 SUB 循环。</li><li>需要 1 个时钟周期退出 SUB 循环。</li><li>总共 11 个时钟周期。</li></ul><p>在这个简单的示例中，很明显，ADD 循环中的 else 分支也可以解决该问题，但是在更复杂的示例中，它可能不那么明显，更直观的编码方式可能具有更大的优势。</p><p>LOOP_MERGE 最优化指令用于自动合并循环。LOOP_MERGE 指令将尝试合并应用范围内的所有循环。在上面的示例中，合并循环将创建类似于上图 (B) 所示的控制结构，完成它只需要 6 个时钟周期。</p><p>合并循环允许将循环内的逻辑组合在一起进行最优化。在上面的示例中，使用真双口 BRAM 可以并行执行加减运算。</p><p>当前在 Vivado HLS 中合并循环具有以下限制：</p><ul><li>如果循环边界都是变量，则它们必须具有相同的值。</li><li>如果循环边界为常量，那么最大常量值用作为合并循环的边界。</li><li>具有变量边界和常量边界的循环无法合并。</li><li>要合并的循环之间的代码不得产生不同结果：多次执行此代码应生成相同的结果（允许使用 a = b，不允许使用 a = a + 1）。</li><li>包含 FIFO 访问的循环无法合并：合并将更改 FIFO 上的读写顺序：这些循环必须始终按顺序进行。</li></ul><h4 id="将嵌套循环扁平化以改善时延"><a href="#将嵌套循环扁平化以改善时延" class="headerlink" title="将嵌套循环扁平化以改善时延"></a>将嵌套循环扁平化以改善时延</h4><p>已展开的嵌套循环之间的移动需要额外的时钟周期，这与前述章节中所述的连续循环间移动方式相似。从外层循环移至内层循环需要一个时钟周期，从内层循环移至外层循环同样如此。</p><p>在此处所示小型示例中，这暗示执行 Outer 循环需 200 个额外时钟周期。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> foo_top &#123; a, b, c, d&#125; &#123;</span><br><span class="line">    ...</span><br><span class="line">    Outer: <span class="keyword">while</span>(j&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        Inner: <span class="keyword">while</span>(i&lt;<span class="number">6</span>)&#123; <span class="comment">// 1 cycle to enter inner</span></span><br><span class="line">            ...</span><br><span class="line">            LOOP_BODY</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="comment">// 1 cycle to exit inner</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vivado HLS 提供的 set_directive_loop_flatten 命令允许将已标记为完美和半完美的嵌套循环扁平化，这样就无需重新编码来提升硬件性能，并且还可减少执行循环中的运算所需的周期数。</p><ul><li>完美循环嵌套：仅限最内层的循环才有循环主体内容，逻辑语句之间未指定任何逻辑，所有循环边界均为常量。</li><li>半完美循环嵌套：仅限最内层的循环才有循环主体内容，逻辑语句之间未指定任何逻辑，<u>除最外层循环外</u>所有循环边界均为常量。</li></ul><p>对于非完美循环嵌套，即内层循环具有变量边界或者循环主体未完全包含在内层循环内，设计人员应尝试重构代码或者将循环主体中的循环展开以创建完美循环嵌套。</p><p>将该指令应用于一组嵌套循环时，应将其应用于最内层循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_directive_loop_flatten top/Inner</span><br></pre></td></tr></table></figure><p>循环扁平化还可使用 GUI 中的“Vivado HLS Directive Editor”选项执行，可将其单独应用于各循环，或者通过在函数级别应用该指令来将其应用于函数中的所有循环。</p><h3 id="面积最优化"><a href="#面积最优化" class="headerlink" title="面积最优化"></a>面积最优化</h3><p>主要可以从下面几个角度考虑：更精准地对数据的类型和位宽进行设置，避免资源的浪费；通过函数的内联来复用模块；通过对函数进行精准的例化来减少函数的通用性，降低资源占用；对于数组而言，首先考虑数据的存取需求，在满足吞吐率的情况下考虑是否可以对数据进行合并，节省存储的 BRAM 资源；此外，对一些复杂运算而言，通过显式制定硬件核可以节省较多的片上逻辑资源，并改善性能。</p><h4 id="数据类型和位宽"><a href="#数据类型和位宽" class="headerlink" title="数据类型和位宽"></a>数据类型和位宽</h4><p>C 语言函数中的变量位宽会直接影响 RTL 实现中使用的存储元素和运算符。如果变量只需 12 位但指定为整数类型（32 位），这会导致HLS使用更大且运算更慢的 32 位运算符，从而减少一个时钟周期内可执行的运算数量，并可能增大启动时间间隔和时延。为此请特别注意如下几点：</p><ul><li>使用适合数据类型的相应精度。</li><li>确认要使用 RAM 还是寄存器来实现数组。任何过大的元素都会影响面积，从而导致硬件资源浪费。</li><li>请特别注意乘法、除法、取模或其它复杂算术运算。如果这些变量过大，则会对面积和性能都产生负面影响。</li></ul><h4 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h4><p>函数内联会移除函数层级。函数可使用 INLINE 指令进行内联。内联函数可以支持函数中的逻辑共享，以更高效的方式调用函数中的逻辑，从而改善面积。Vivado HLS 也会自动执行此类型的函数内联。小型函数可自动内联。</p><p>内联支持对函数共享进行更有效的控制。对于要共享的函数，必须在相同层级内使用。在此代码示例中，foo_top 函数会对 foo 进行 2 次调用，并调用 foo_sub 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo_sub (p, q) &#123;</span><br><span class="line">    <span class="type">int</span> q1 = q + <span class="number">10</span>;</span><br><span class="line">    foo(p1,q); <span class="comment">// foo_3</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> foo_top &#123; a, b, c, d&#125; &#123;</span><br><span class="line">    ...</span><br><span class="line">    foo(a,b); <span class="comment">//foo_1</span></span><br><span class="line">    foo(a,c); <span class="comment">//foo_2</span></span><br><span class="line">    foo_sub(a,d);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数 foo_sub 内联并使用 ALLOCATION 指令指定仅使用 foo 函数的 1 个实例，这样生成的设计仅含 1 个 foo 函数的实例：面积为以上示例的三分之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">foo_sub (p, q) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS INLINE</span></span><br><span class="line">    <span class="type">int</span> q1 = q + <span class="number">10</span>;</span><br><span class="line">    foo(p1,q); <span class="comment">// foo_3</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> foo_top &#123; a, b, c, d&#125; &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS ALLOCATION instances=foo limit=1 function</span></span><br><span class="line">    ...</span><br><span class="line">    foo(a,b); <span class="comment">//foo_1</span></span><br><span class="line">    foo(a,c); <span class="comment">//foo_2</span></span><br><span class="line">    foo_sub(a,d);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>INLINE 指令可选择使用 recursive 选项来<u>允许位于指定函数下层的所有函数以递归方式进行内联</u>。如果对顶层函数使用 recursive 选项，那么将移除设计中的所有函数层级。</p><p>可选择对函数应用 INLINE off 选项以阻止对这些函数进行内联。该选项可用于阻止 Vivado HLS 自动进行函数内联。</p><p>INLINE 指令是大幅修改代码结构而不对源代码执行任何实际修改的强大方法，并可提供强大的架构探索方法。</p><h4 id="将大量数组映射到单一大型数组"><a href="#将大量数组映射到单一大型数组" class="headerlink" title="将大量数组映射到单一大型数组"></a>将大量数组映射到单一大型数组</h4><p>当 C 语言代码中存在大量小型数组时，将其映射到单一大型数组通常可减少所需的 BRAM 数量。</p><p>受器件支持的前提下，每个数组都映射到 1 个块 RAM 或 UltraRAM。任一 FPGA 中提供的基本块 RAM 单元为 18K。如有大量小型数组且占用资源不足 18K，那么为了更有效地利用 BRAM 资源，可将大量小型数组映射到单一大型数组。如果 BRAM 大于 18K，则会自动将其映射到多个 18K 单元。在综合报告中，请复查“Utilization Report” →“Details” → “Memory”，以便详细了解设计中 BRAM 的使用情况。</p><p>ARRAY_MAP 指令支持通过 2 种方式将多个小型数组映射到单一大型数组：</p><ul><li>水平映射：从数组的深度方向进行合并，通过并置原始数组来创建新阵列。实际上，这作为含更多元素的单一数组来实现。</li><li>垂直映射：从数组的位宽方向进行合并，通过并置数组中的字词来创建新阵列。实际上，这作为含较大位宽的单一数组来实现。</li></ul><h5 id="水平数组映射"><a href="#水平数组映射" class="headerlink" title="水平数组映射"></a>水平数组映射</h5><p>以下代码示例包含 2 个数组，这些数组将生成 2 个 RAM 组件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(...)</span> &#123;</span><br><span class="line">    int8 array1[M];</span><br><span class="line">    int12 array2[N];</span><br><span class="line">    ...</span><br><span class="line">    loop_1: <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) &#123;</span><br><span class="line">        array1[i] = ...;</span><br><span class="line">        array2[i] = ...;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组 array1 和 array2 可组合为单一数组，在以下示例中指定为 array3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(...)</span> &#123;</span><br><span class="line">    int8 array1[M];</span><br><span class="line">    int12 array2[N];</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_MAP variable=array1 instance=array3 horizontal</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_MAP variable=array2 instance=array3 horizontal</span></span><br><span class="line">    ...</span><br><span class="line">    loop_1: <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) &#123;</span><br><span class="line">        array1[i] = ...;</span><br><span class="line">        array2[i] = ...;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，ARRAY_MAP 指令按下图所示方式对数组进行变换。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281609395.png" alt="image-20230328160927354"></p><p>使用水平映射时，多个较小的数组将映射到单一较大的数组。映射从较大的数组中的位置 0 开始，并遵循指定命令的顺序执行映射。</p><p>使用下图所示的水平映射时，BRAM 中的实现如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281610573.png" alt="image-20230328161038533"></p><p>ARRAY_MAP 指令的 offset 选项用于指定使用 horizontal 选项时后续数组添加到的位置。重复先前示例，但反转命令顺序（先指定 array2，然后指定 array1）并添加 offset，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(...)</span> &#123;</span><br><span class="line">    int8 array1[M];</span><br><span class="line">    int12 array2[N];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_MAP variable=array2 instance=array3 horizontal</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_MAP variable=array1 instance=array3 horizontal offset=2</span></span><br><span class="line">...</span><br><span class="line">loop_1: <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) &#123;</span><br><span class="line">    array1[i] = ...;</span><br><span class="line">    array2[i] = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将导致如下图所示的变换。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281613028.png" alt="image-20230328161332982"></p><p>映射后，新构成的数组（即以上示例中的 array3）可通过向映射到新实例的任意变量应用 RESOURCE 指令来定向到特定 BRAM 或 UltraRAM。</p><p>虽然水平映射可能导致使用的块 RAM 组件数量减少从而改善面积，但<u>它确实会影响吞吐量和性能</u>，因为当前 BRAM端口数量有所减少。为克服此限制，Vivado HLS 还提供了垂直映射。</p><h5 id="映射垂直数组"><a href="#映射垂直数组" class="headerlink" title="映射垂直数组"></a>映射垂直数组</h5><p>在垂直映射中，通过并置多个数组来生成位宽更高的单个数组。下图显示了应用垂直映射模式时，前述示例所发生的变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(...)</span> &#123;</span><br><span class="line">    int8 array1[M];</span><br><span class="line">    int12 array2[N];</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_MAP variable=array2 instance=array3 vertical</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_MAP variable=array1 instance=array3 vertical</span></span><br><span class="line">    ...</span><br><span class="line">    loop_1: <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) &#123;</span><br><span class="line">        array1[i] = ...;</span><br><span class="line">        array2[i] = ...;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281615357.png" alt="image-20230328161554312"></p><p>在垂直映射中，按命令指定顺序并置各数组，指定的数组排序顺序为从 LSB 开始到 MSB 结束。完成垂直映射后，新组成的数组将在单一BRAM 组件内实现，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281616450.png" alt="image-20230328161631412"></p><h4 id="数组映射以及注意事项"><a href="#数组映射以及注意事项" class="headerlink" title="数组映射以及注意事项"></a>数组映射以及注意事项</h4><blockquote><p>NOTE：数组变换的优化指令在代码中放置的位置必须先于其它任何与数组相关的优化指令。</p></blockquote><p>要将元素从已分区的数组映射到含 horizontal 映射的单一数组中，必须在 ARRAY_MAP 指令中指定数组的每个要分区的元素。例如，以下 Tcl 命令用于对 accum 数组进行分区，并将生成的元素重新映射到一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS array_partition variable=m_accum cyclic factor=2 dim=1</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS array_partition variable=v_accum cyclic factor=2 dim=1</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS array_map variable=m_accum[0] instance=mv_accum horizontal</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS array_map variable=v_accum[0] instance=mv_accum horizontal</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS array_map variable=m_accum[1] instance=mv_accum_1 horizontal</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS array_map variable=v_accum[1] instance=mv_accum_1 horizontal</span></span><br></pre></td></tr></table></figure><p>可对全局数组进行映射。但生成的数组实例为全局实例，映射到该数组实例的任何局部数组都会变为全局数组。当不同函数的局部数组映射到同一目标数组时，目标数组实例就会变为全局实例。</p><h4 id="数组重塑"><a href="#数组重塑" class="headerlink" title="数组重塑"></a>数组重塑</h4><p>ARRAY_RESHAPE 指令将 ARRAY_PARTITIONING 与 ARRAY_MAP 的垂直模式相结合，用于减少 BRAM 数量，同时仍支持分区的有利特性：并行访问数据。</p><p>给定以下示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> array1[N];</span><br><span class="line">    <span class="type">int</span> array2[N];</span><br><span class="line">    <span class="type">int</span> array3[N];</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_RESHAPE variable=array1 block factor=2 dim=1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_RESHAPE variable=array2 cycle factor=2 dim=1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS ARRAY_RESHAPE variable=array3 complete dim=1</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARRAY_RESHAPE 指令可将数组转换为下图所示形式。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281624025.png" alt="image-20230328162456971"></p><p>ARRAY_RESHAPE 指令支持在单一时钟周期内访问更多数据。只要能在单一时钟周期内访问更多数据，Vivado HLS 即可自动展开使用此数据的所有循环，前提是这样有助于提升吞吐量。循环可全部或部分展开以提高数据的吞吐率。此功能可使用 config_unroll 命令和 tripcount_threshold 选项来加以控制。在以下示例中，循环次数小于 16 的任何循环都将自动展开（前提是可提高吞吐量）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_unroll -tripcount_threshold <span class="number">16</span></span><br></pre></td></tr></table></figure><h4 id="函数例化"><a href="#函数例化" class="headerlink" title="函数例化"></a>函数例化</h4><p>函数例化是一种最优化技巧，不仅具有维持函数层级的面积优势，还可提供另一个强大的选项：在函数的特定实例上执行针对性局部最优化。这样可以简化围绕函数调用的控制逻辑，也可能改进时延和吞吐量。</p><p>鉴于调用函数时部分函数输入可能是常量，FUNCTION_INSTANTIATE 指令可借此简化周围控制结构，并生成进一步优化的、更小的函数块。这可通过示例来细化解释。</p><p>给定如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo_sub</span><span class="params">(<span class="type">bool</span> mode)</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS FUNCTION_INSTANTIATE variable=mode</span></span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line">    <span class="comment">// code segment 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code segment 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> foo()&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS FUNCTION_INSTANTIATE variable=select</span></span><br><span class="line">    foo_sub(<span class="literal">true</span>);</span><br><span class="line">    foo_sub(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，函数 foo_sub 的功能为执行单一重复性运算（根据 mode 是否为 true）。函数 foo_sub 的每个实例均以相同方式实现：这非常适合函数复用和面积最优化，但也意味着函数内部的控制逻辑必须更加复杂。</p><p>FUNCTION_INSTANTIATE 最优化允许对每个实例进行独立最优化，从而减少功能和面积。完成FUNCTION_INSTANTIATE 最优化后，以上代码可有效转换为 2 个独立函数，每个函数都针对模式的不同可能值来完成最优化，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo_sub1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// code segment 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_sub2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// code segment 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">    foo_sub1();</span><br><span class="line">    foo_sub2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不进行大幅内联或代码修改的情况下，在不同层级使用该函数会导致函数难以共享，那么函数例化约束可提供改进面积的最佳方法：大量小型局部最优化的函数副本比大量无法共享的大型函数副本更有效。</p><h4 id="控制硬件资源"><a href="#控制硬件资源" class="headerlink" title="控制硬件资源"></a>控制硬件资源</h4><p>综合期间，Vivado HLS 会执行以下基本任务：</p><ul><li><p>首先，将 C、C++ 或 SystemC 语言源代码细化为包含运算符的内部数据库。</p><p>运算符表示 C 语言代码中的运算，如加法、乘法、数组读取和写入等。</p></li><li><p>然后，将运算符映射到实现硬件操作的核上。</p></li></ul><p>​        核为用于创建设计的特定硬件组件（例如，加法器、乘法器、流水线化的乘法器和 BRAM）。</p><p>作为设计者，我们可以控制其中每个步骤，从而对硬件实现进行精细化的控制。</p><h5 id="限制运算符数量"><a href="#限制运算符数量" class="headerlink" title="限制运算符数量"></a>限制运算符数量</h5><p>显式限制运算符的数量以减小某些情况下所需的面积：Vivado HLS 的默认操作是首先最大限度提升性能。限制设计中的运算符数量是一项减小面积的实用技巧：<u>它通过强制共享运算来减小面积。</u></p><p>ALLOCATION 指令允许设计者限制设计中使用的运算符、核或函数数量。例如，名为 foo 的设计包含 317 次乘法，但FPGA 仅有 256 项乘法器资源 (DSP48)。以下所示 ALLOCATION 指令可指示 Vivado HLS 创建含最多 256 个乘法 (mul) 运算符的设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dout_t</span> <span class="title function_">array_arith</span> <span class="params">(<span class="type">dio_t</span> d[<span class="number">317</span>])</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> acc;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS ALLOCATION instances=mul limit=256 operation</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">317</span>;i++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS UNROLL</span></span><br><span class="line">        acc += acc * d[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE：如果指定的 ALLOCATION 限制超出所需数量，Vivado HLS 会尝试使用此项限制指定的资源数量，导致减少共享量。</p></blockquote><p>设计者可使用 type 选项来指定 ALLOCATION 指令是否限制运算、核和函数数量。下表列出了可使用 ALLOCATION 指令控制的所有运算。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281638870.png" alt="image-20230328163850809"></p><h5 id="全局最大限度减少运算符"><a href="#全局最大限度减少运算符" class="headerlink" title="全局最大限度减少运算符"></a>全局最大限度减少运算符</h5><p>ALLOCATION 指令与所有其它指令一样，都是在某一作用域内指定的：函数、循环或区域。config_bind 配置允许在整个设计中最大限度减少运算符。</p><p>在设计中要最大限度减少运算符，可执行 config_bind 配置中的 min_op 选项。前表中列出的任意运算符均可按此方式加以限制。</p><p>应用配置后，它将应用于解决方案中执行的所有综合操作：如果关闭再重新打开解决方案，那么指定的配置仍适用于所有新综合运算。</p><p>随 config_bind 配置一起应用的任意配置均可使用 reset 选项来移除，或者使用 open_solution -reset 以打开解决方案。</p><h5 id="控制硬件核"><a href="#控制硬件核" class="headerlink" title="控制硬件核"></a>控制硬件核</h5><p>执行综合时，Vivado HLS 会使用由时钟指定的时序约束、由目标器件指定的延迟以及由您指定的任意指令来判定使用哪个核来实现运算符。例如，要实现乘法运算，Vivado HLS 可使用组合乘法器核或使用流水线乘法器核。</p><p>综合期间映射到运算符的核可采用与运算符相同的方式来加以限制。您无需限制乘法运算总数，而可改为选择限制组合乘法器核的数量以强制使用流水线化乘法器来执行所有剩余乘法（或反之亦然）。这是通过将 ALLOCATION 指令 type 选项指定为 core 来实现的。</p><p>RESOURCE 指令用于显式指定要用于特定操作的核。在以下示例中指定使用 2 阶流水线化乘法器以实现变量的乘法运算。以下命令会告知 Vivado HLS 针对变量 c 使用 2 阶流水线化乘法器。由 Vivado HLS 判定用于变量 d 的核。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c, d;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> HLS RESOURCE variable=c latency=2</span></span><br><span class="line">    c = a*b;</span><br><span class="line">    d = a*c;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以下示例中，RESOURCE 指令指定变量 temp 的加法运算，并使用 AddSub_DSP 核来实现。这样可确保在最终设计中使用 DSP48 原语来实现此运算 - 默认情况下加法运算是使用 LUT 来实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">apint_arith</span><span class="params">(dinA_t inA, dinB_t inB, <span class="type">dout1_t</span> *out1)</span> &#123;</span><br><span class="line">    <span class="type">dout2_t</span> temp;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS RESOURCE variable=temp core=AddSub_DSP</span></span><br><span class="line">    temp = inB + inA;</span><br><span class="line">    *out1 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list_core 命令用于获取有关库中可用的核的详细信息。list_core 只能在 Tcl 命令界面中使用，并且必须使用set_part 命令指定器件。如果未选中器件，此命令将无效。list_core 命令的 -operation 选项列出了库中可通过指定运算实现的所有核。下表列出了用于实现标准 RTL 逻辑运算（例如，加法、乘法和比较）的核。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281643899.png" alt="image-20230328164345838"></p><p>除标准核外，当运算使用浮点类型时还可使用以下浮点核。请参阅每个器件的文档以判定在器件中是否支持浮点核。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281645137.png" alt="image-20230328164551072"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281646688.png" alt="image-20230328164610631"></p><p>下表列出了用于实现存储元素的核。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281646677.png" alt="image-20230328164649608"></p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281647149.png" alt="image-20230328164703103"></p><p>RESOURCE 指令使用已赋值的变量作为资源目标。给定代码的情况下，RESOURCE 指令可指定 out1 的乘法使用 3 阶流水线化乘法器来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(...)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS RESOURCE variable=out1 latency=3</span></span><br><span class="line">    <span class="comment">// Basic arithmetic operations</span></span><br><span class="line">    *out1 = inA * inB;</span><br><span class="line">    *out2 = inB + inA;</span><br><span class="line">    *out3 = inC / inA;</span><br><span class="line">    *out4 = inD % inA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果赋值指定多个相同的运算符，则必须修改此代码以<u>确保针对要控制的每个运算符都存在单一变量</u>。例如，此示例中，如果仅使用流水线化乘法器来实现首个乘法 (inA * inB)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*out1 = inA * inB * inC;</span><br></pre></td></tr></table></figure><p>那么应使用 Result_tmp 变量上指定的指令来将代码更改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> HLS RESOURCE variable=Result_tmp latency=3</span></span><br><span class="line">Result_tmp = inA * inB;</span><br><span class="line">*out1 = Result_tmp * inC;</span><br></pre></td></tr></table></figure><h5 id="全局最优化硬件核"><a href="#全局最优化硬件核" class="headerlink" title="全局最优化硬件核"></a>全局最优化硬件核</h5><p>config_bind 配置项使开发者能改变将核与运算符绑定时所需的工作量。默认情况下，Vivado HLS 会选择能在时序与面积间实现最佳平衡的核。config_bind 能影响所使用的运算符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_bind -effort [low | medium | high] -min_op &lt;<span class="built_in">list</span>&gt;</span><br></pre></td></tr></table></figure><p>config_bind 命令只能在处于活动状态的解决方案内发出。绑定运算的默认运行策略是 medium。</p><ul><li>low 工作量：减少共享时间，运行时间更短，但最终 RTL 占用的资源可能更大。适用案例为设计人员已知几乎不可能存在运算共享或者几乎没有符合期望的运算共享，并且不希望将 CPU 周期浪费在探寻运算共享可能性上。</li><li>medium 工作量：默认设置，Vivado HLS 会尝试共享运算，但尽力在合理时间内完成运算。</li><li>high 工作量：尝试最大限度共享运算，不限制运行时间。Vivado HLS 不断尝试直至完成所有可能的运算共享组合为止。</li></ul><h3 id="最优化逻辑"><a href="#最优化逻辑" class="headerlink" title="最优化逻辑"></a>最优化逻辑</h3><p>主要考虑运算符的流水线以及是否可以进行表达式平衡的工作。</p><h4 id="控制运算符流水线化"><a href="#控制运算符流水线化" class="headerlink" title="控制运算符流水线化"></a>控制运算符流水线化</h4><p>Vivado HLS 会自动判定用于内部运算的流水线化级别。设计者可将 RESOURCE 指令与 -latency 选项配合使用，以显式指定流水线阶段的数量，并覆盖由 Vivado HLS 判定的数量。</p><p>RTL 综合可使用多个额外流水线寄存器来帮助改善布局布线后可能导致的时序问题。在模块的输出信号中添加寄存器通常有助于改善输出数据路径中的时序。在模块的输入信号中添加寄存器通常有助于改善输入数据路径和来自 FSM 的控制逻辑中的时序。</p><p>添加这些额外的流水线阶段的规则是：</p><ul><li>如果指定的时延比由 Vivado HLS 判定的时延多 1 个周期，Vivado HLS 会向运算输出添加新的输出寄存器。</li><li>如果指定的时延比由 Vivado HLS 判定的时延多 2 个周期，Vivado HLS 会向运算输出以及运算的输入侧添加寄存器。</li><li>如果指定的时延比由 Vivado HLS 判定的时延多 3 个或 3 个以上周期，Vivado HLS 会向运算的输出以及运算的输入侧添加寄存器。Vivado HLS 会自动判定任何附加的寄存器的位置。</li></ul><p>您可使用 config_core 配置对设计中特定核的具有相同流水线深度的所有实例进行流水线化。要设置此配置，请执行以下操作：</p><ol><li><p>选择“Solutions” → “Solution Settings”。</p></li><li><p>在“解决方案设置 (Solution Settings)”对话框中，选择“General”类别，然后单击“Add”。</p></li><li><p>在“添加命令 (Add Command)”对话框中，选择 config_core 命令，并指定参数。</p><p>例如，以下配置指定使用 DSP48 核实现的所有运算均采用流水线化，且时延设置为 3，这是该核允许的最大时延：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_core DSP48 -latency <span class="number">3</span></span><br></pre></td></tr></table></figure><p>以下配置指定随 RAM_1P_BRAM 核实现的所有 BRAM 均采用流水线化，且时延设置为 3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_core RAM_1P_BRAM -latency <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>NOTE：Vivado HLS 仅将此核配置应用于含显式 RESOURCE 指令的 BRAM，该指令可指定用于实现数组的核。如果使用默认核来实现数组，那么核配置不影响 BRAM。</p></blockquote></li></ol><h4 id="最优化逻辑表达式"><a href="#最优化逻辑表达式" class="headerlink" title="最优化逻辑表达式"></a>最优化逻辑表达式</h4><p>在综合期间会执行多次最优化（例如，强度折减和位宽最小化）。在自动最优化列表中也包括表达式平衡。</p><blockquote><p>NOTE：强度折减个人理解是用简单的算子来实现复杂的算子。下面把维基百科的解释搬运一下：</p><p>In compiler construction, <strong>strength reduction</strong> is a compiler optimization where expensive operations are replaced with equivalent but less expensive operations. The classic example of strength reduction converts “strong” multiplications inside a loop into “weaker” additions – something that frequently occurs in array addressing. </p><p>Examples of strength reduction include:</p><ul><li>replacing a multiplication within a loop with an addition</li><li>replacing an exponentiation within a loop with a multiplication</li></ul></blockquote><p>表达式平衡会重新排列运算符以构造平衡的树结构并降低时延。</p><ul><li>对于整数运算，默认情况下表达式平衡处于开启状态，但可将其禁用。</li><li>对于浮点运算，默认情况下表达式平衡处于关闭状态，但可将其启用。</li></ul><p>对于使用如下示例所示的 += 和 *= 之类的赋值运算符的高度循序代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">data_t</span> <span class="title function_">foo_top</span> <span class="params">(<span class="type">data_t</span> a, <span class="type">data_t</span> b, <span class="type">data_t</span> c, <span class="type">data_t</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">data_t</span> sum;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    sum += a;</span><br><span class="line">    sum += b;</span><br><span class="line">    sum += c;</span><br><span class="line">    sum += d;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用表达式平衡并且假定每个加法都需要 1 个时钟周期，那么完整计算 sum 需要 4 个时钟周期，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281706060.png" alt="image-20230328170612023"></p><p>但加法 a+b 和 c+d 可并行执行以缩减时延。经过平衡后，计算可在 2 个时钟周期内完成，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281706887.png" alt="image-20230328170642852"></p><p>对于整数，您可使用 EXPRESSION_BALANCE 最优化指令配合 off 选项来禁用表达式平衡。默认情况下，Vivado HLS 对于 float 类型或 double 类型的运算不执行 EXPRESSION_BALANCE 最优化。对 float 和 double 类型进行综合时，Vivado HLS 会保留 C 语言代码中执行的运算顺序，以确保结果与 C 语言仿真相同。例如，在以下代码示例中，所有变量类型均为 float 或 double。O1 和 O2 即使看似执行相同的基本操作，其值也并不同。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281708041.png" alt="image-20230328170804005"></p><p>该行为是 C 语言标准中执行 float 或 double 类型的运算时饱和和舍入所导致的结果。因此，存在类型为 float 或 double 的函数时，Vivado HLS 始终保留运算顺序不变，并且默认不执行表达式平衡。</p><p>您可使用 config_compile 配置选项对 float 和 double 类型启用表达式平衡，如下所示：</p><ol><li>选择“Solution” → “Solution Settings”。</li><li>在“解决方案设置 (Solution Settings)”对话框中，单击“General”类别，然后单击“Add”。</li><li>在“添加命令 (Add Command)”对话框中，选择“config_compile”，并启用“unsafe_math_operations”。</li></ol><p>启用此设置后，Vivado HLS 即可更改运算顺序，以生成更优化的设计。但 C/RTL 协同仿真的结果可能与 C 语言仿真不同。</p><p>unsafe_math_operations 功能还支持 no_signed_zeros 最优化。no_signed_zeros 最优化可确保以下表达式配合浮点类型和双精度类型使用时结果完全相同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x - <span class="number">0.0</span> = x;</span><br><span class="line">x + <span class="number">0.0</span> = x;</span><br><span class="line"><span class="number">0.0</span> - x = -x;</span><br><span class="line">x - x = <span class="number">0.0</span>;</span><br><span class="line">x*<span class="number">0.0</span> = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>如果不使用 no_signed_zeros 最优化，由于舍入，以上表达式结果将不同。通过在 config_compile 配置中仅选中该选项，即可选择在不使用表达式平衡的情况下执行此最优化。</p><blockquote><p>NOTE：使用 unsafe_math_operations 和 no_signed_zero 最优化时，RTL 实现结果将不同于 C 语言仿真。测试激励文件应可忽略结果中的轻微差异：检查范围，不执行精确比对。</p></blockquote><h2 id="Managing-Interfaces"><a href="#Managing-Interfaces" class="headerlink" title="Managing Interfaces"></a>Managing Interfaces</h2><p>在基于 C 语言的设计中，通过函数实参即可立即执行所有输入和输出操作。在 RTL 设计中，同样这些输入和输出操作必须通过设计接口中的端口来执行，并且通常使用特定 I/O（输入/输出）协议来进行操作。</p><p>Vivado HLS 支持使用以下解决方案来指定要使用的 I/O 协议类型：</p><ul><li>接口综合，其中端口接口基于高效的业界标准接口来创建。</li></ul><h3 id="接口综合"><a href="#接口综合" class="headerlink" title="接口综合"></a>接口综合</h3><p>对顶层函数进行综合时，函数的实参（或参数）将综合到 RTL 端口中。此流程称为“接口综合 (interface synthesis)”。</p><h4 id="接口综合概述"><a href="#接口综合概述" class="headerlink" title="接口综合概述"></a>接口综合概述</h4><p>以下代码提供了接口综合的完整概述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum_io.h&quot;</span></span></span><br><span class="line"><span class="type">dout_t</span> <span class="title function_">sum_io</span><span class="params">(<span class="type">din_t</span> in1, <span class="type">din_t</span> in2, <span class="type">dio_t</span> *sum)</span> &#123;</span><br><span class="line">    <span class="type">dout_t</span> temp;</span><br><span class="line">    *sum = in1 + in2 + *sum;</span><br><span class="line">    temp = in1 + in2;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码示例包括：</p><ul><li>2 个输入：in1 和 in2。</li><li>可供读取和写入的指针 sum。</li><li>return 函数，值为 temp。</li></ul><p>通过默认接口综合设置，设计将综合到含端口的 RTL 块中，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281739415.png" alt="image-20230328173920377"></p><p>Vivado HLS 会在 RTL 设计上创建 3 种类型的端口：</p><ul><li>时钟和复位端口：ap_clk 和 ap_rst。</li><li>块级接口协议。在前图中已显示并展开这些端口：ap_start、ap_done、ap_ready 和 ap_idle。</li><li>端口级接口协议。这些端口是针对顶层函数和函数返回（如果函数有返回值）中的每个实参创建的。在此示例中，这些端口包括：in1、in2、sum_i、sum_o、sum_o_ap_vld 和 ap_return。</li></ul><p><strong>时钟和复位端口</strong></p><p>如果设计耗时超过 1 个周期才能完成操作，则会引入时钟与复位端口。</p><p>（可选）可使用“Solution” → “Solution Settings” → “General”和 config_interface 配置将芯片使能端口添加到整个块中。</p><p>复位操作由 config_rtl 配置控制。</p><p><strong>块级接口协议</strong></p><p>默认情况下，块级接口协议会添加到设计中。这些信号用于控制模块，与任意端口级 I/O 协议无关。这些端口用于控制模块开始处理数据的时间 (ap_start)、指示它是否已准备好开始接受新输入 (ap_ready) 以及指示设计是处于空闲状态(ap_idle) 还是已完成操作 (ap_done)。</p><p><strong>端口级接口协议</strong></p><p>最后一组信号是数据端口。创建的 I/O 协议取决于 C 语言实参的类型和默认值。使用块级协议启动块操作后，端口级 I/O 协议用于对进出模块的数据进行排序。</p><p>默认情况下，输入按值传递 (pass-by-value) 实参和指针作为简单的线型端口来实现，无需关联的握手信号。因此在以上示例中，实现的输入端口不含 I/O 协议，仅为数据端口。如果此端口不含默认或按设计指定的 I/O 协议，那么输入数据必须保持稳定直至读取为止。</p><p>默认输出指针实现时含关联的输出有效信号，用于指示何时输出数据有效。在上述示例中，输出端口实现时含关联的输出有效端口 (sum_o_ap_vld) 以指示何时端口上的数据有效并且可供读取。如果不存在与输出端口关联的 I/O 协议，那么将难以确定何时读取数据。最好始终在输出上使用 I/O 协议。</p><p>同时支持读取和写入的函数实参将拆分为独立的输入端口和输出端口。在以上示例中，sum 作为输出端口 sum_i 和输出端口 sum_o 来实现，并具有关联的 I/O 协议端口 sum_o_ap_vld。</p><p>如果函数具有返回值，则实现输出端口 ap_return 以提供返回值。当设计完成 1 项传输事务时（等同于执行 1 次 C 语言函数），块级协议会以 ap_done 信号来表明函数已完成。这也表示 ap_return 端口上的数据有效且可读。</p><!--返回顶层函数的值不能为指针。--><p>对于所示的示例代码，时序行为如下图所示（假定目标技术和时钟频率允许每个时钟周期执行一次加法）。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281743233.png" alt="image-20230328174332182"></p><ul><li>当 ap_start 断言为 High 时，即模块开始工作。</li><li>ap_idle 信号断言为 Low 以表示设计正在运行。</li><li>输入数据可在首个周期后的任意时钟内读取。Vivado HLS 会调度读取发生的时间。读取所有输入后，ap_ready信号即断言为高位有效 (high)。</li><li>计算输出 sum 时，关联的输出握手 (sum_o_ap_vld) 表示数据有效。</li><li>当函数完成时，即断言 ap_done 有效。这也表示 ap_return 上的数据有效。</li><li>端口 ap_idle 断言为 High 以表示设计正在等待再次启动。</li></ul><h4 id="接口综合I-O协议"><a href="#接口综合I-O协议" class="headerlink" title="接口综合I/O协议"></a>接口综合I/O协议</h4><p>由接口综合所创建的接口类型取决于 C 语言实参的类型、默认接口模式以及 INTERFACE 最优化指令。下图显示了设计者可在每一种 C 语言实参类型上指定的接口协议模式。此图使用以下首字母缩略词：</p><ul><li><p>D：每一种类型的默认接口模式。</p><!--如果指定非法接口，Vivado HLS 会发出 1 条消息，并实现默认接口模式。--></li><li><p>I：输入实参（只读）。</p></li><li>O：输出实参（只写）。</li><li>I/O：输入/输出实参（可读写）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281749345.png" alt="image-20230328174916295"></p><p>在接口综合参考章节中包含有关接口协议的完整信息（包括波形图），下面提供每个接口模式的概述。</p><h5 id="块级接口协议"><a href="#块级接口协议" class="headerlink" title="块级接口协议"></a>块级接口协议</h5><p>块级接口协议包括 ap_ctrl_none、ap_ctrl_hs 和 ap_ctrl_chain。这些协议只能在函数或函数返回值处指定。在 GUI 中指定该指令时，会将这些协议应用于函数返回值。即使函数没有返回值，也可在函数返回值处指定块级协议。</p><p>前述示例中所述的 ap_ctrl_hs 模式是默认协议。ap_ctrl_chain 协议类似于 ap_ctrl_hs，但具有额外的输入端口 ap_continue 以提供数据回压功能。如果函数完成时 ap_continue 端口为逻辑 0，此模块将停止操作，并且不会继续执行下一项传输事务。仅当 ap_continue 断言为逻辑 1 时，才会继续执行下一项传输事务。</p><p>ap_ctrl_none 模式用于实现不含任何块级 I/O 协议的设计。</p><p>如果函数返回值同时指定为 AXI4-Lite 接口 (s_axilite)，<u>那么块级接口中的所有端口都将分组到此 AXI4-Lite 接口中。</u>我们在使用其它器件（如 CPU）来配置和控制模块的开始和停止操作时间时，常用此方法。</p><h5 id="端口级接口协议：AXI4协议"><a href="#端口级接口协议：AXI4协议" class="headerlink" title="端口级接口协议：AXI4协议"></a>端口级接口协议：AXI4协议</h5><p>Vivado HLS 支持的 AXI4 接口包括 AXI4-Stream 接口 (axis)、AXI4-Lite 从接口 (s_axilite) 和 AXI4 主接口 (m_axi)，这些接口可按以下方式指定：</p><ul><li>AXI4-Stream 接口：仅在input实参或output实参上指定，而不在inout实参上指定。</li><li>AXI4-Lite 接口，在任何类型的实参上指定，但是array类型除外。设计者可以将多个实参分组到同一 AXI4-Lite 接口中。</li><li>AXI4 主接口：仅在数组和指针（以及 C++ 中的引用）上指定。设计者可以将多个实参分组到同一 AXI4 接口中。</li></ul><h5 id="端口级接口协议：无I-O协议"><a href="#端口级接口协议：无I-O协议" class="headerlink" title="端口级接口协议：无I/O协议"></a>端口级接口协议：无I/O协议</h5><p>ap_none 和 ap_stable 模式可指定不向端口添加任何 I/O 协议。指定这些模式时，实参作为不含任何其它关联信号的数据端口来实现。ap_none 模式是标量输入的默认模式。<u>ap_stable 模式用于仅当器件处于复位模式时才可更改的配置输入。</u></p><h5 id="端口级接口协议：握手协议"><a href="#端口级接口协议：握手协议" class="headerlink" title="端口级接口协议：握手协议"></a>端口级接口协议：握手协议</h5><p>接口模式 ap_hs 包含与数据端口的双向握手信号。此握手属于业界标准的有效和确认握手。ap_vld 模式同样如此，但仅含有效端口，ap_ack 仅含确认端口。</p><p>ap_ovld 模式用于inout参数。将inout数据类型拆分为独立输入端口和输出端口时，ap_none 模式适用于其中的输入端口，ap_vld 适用于其中的输出端口。这是支持读写的指针实参的默认类型。</p><p>ap_hs 模式<u>可应用于按顺序读写的数组。</u>如果 Vivado HLS 可判定读访问或写访问为无序访问，它将停止综合并报错。如果无法判定访问顺序，Vivado HLS 将发出警告。</p><h5 id="端口级接口协议：内存接口"><a href="#端口级接口协议：内存接口" class="headerlink" title="端口级接口协议：内存接口"></a>端口级接口协议：内存接口</h5><p>默认情况下，数组实参作为 ap_memory 接口来实现。这是含数据、地址、芯片使能和写使能端口的标准 BRAM 接口。</p><p>ap_memory 接口可作为单端口接口或双端口接口来实现。如果 Vivado HLS 可判定使用双端口接口可以缩短启动时间间隔，那么它将自动实现双端口接口。RESOURCE 指令用于指定内存资源，如果在含单端口 BRAM 的数组上指定该指令，那么将实现单端口接口。相反，如果使用 RESOURCE 指令指定双端口接口，并且 Vivado HLS 判定此接口并无益处，那么它将自动实现单端口接口。</p><p>bram 接口模式的运作方式与 ap_memory 接口相同。唯一差异是在 Vivado IP integrator 中使用设计时，端口的实现方式。</p><ul><li>ap_memory 接口显示为多个独立端口。</li><li>bram 接口显示为单个组合端口，可使用单一点对点连接来连接到赛灵思 BRAM。</li></ul><p>如果按顺序访问数组，可使用 ap_fifo 接口。就像 ap_hs 接口一样，如果 Vivado HLS 判定未按顺序进行数据访问，那么它将停止；如果无法判定是否采用顺序访问，则将发出警告；如果判定已采用顺序方式访问，则不发出任何消息。ap_fifo 接口只能用于读取或写入，不能用于同时读写。</p><p>ap_bus 接口可与总线网桥进行通信。此接口不遵循任何特定总线标准，但鉴于其泛用性，可配合总线网桥一起使用，从而与系统总线进行仲裁。<u>总线网桥必须能够将所有突发写操作进行缓存。</u></p><h4 id="接口综合和多次访问指针"><a href="#接口综合和多次访问指针" class="headerlink" title="接口综合和多次访问指针"></a>接口综合和多次访问指针</h4><p>使用多次访问的指针可能会在综合后引发意外行为。在以下示例中，对指针 d_i 执行了 4 次读取，对指针 d_o 执行了 2 次写入：指针执行了多次访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pointer_stream_bad.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pointer_stream_bad</span> <span class="params">( <span class="type">dout_t</span> *d_o, <span class="type">din_t</span> *d_i)</span> &#123;</span><br><span class="line"><span class="type">din_t</span> acc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    acc += *d_i;</span><br><span class="line">    acc += *d_i;</span><br><span class="line">    *d_o = acc;</span><br><span class="line">    acc += *d_i;</span><br><span class="line">    acc += *d_i;</span><br><span class="line">    *d_o = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合后，此代码产生的 RTL 设计将读取 1 次输入端口，写入 1 次输出端口。与任何标准 C 语言编译器一样，Vivado HLS 将优化掉多余的指针访问。要按“预期”实现上述代码，即对 d_i 读取 4 次，对 d_o 写入 2 次，必须将指针指定为 volatile，如以下示例所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pointer_stream_better.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pointer_stream_better</span> <span class="params">( <span class="keyword">volatile</span> <span class="type">dout_t</span> *d_o, <span class="keyword">volatile</span> <span class="type">din_t</span> *d_i)</span> &#123;</span><br><span class="line"><span class="type">din_t</span> acc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    acc += *d_i;</span><br><span class="line">    acc += *d_i;</span><br><span class="line">    *d_o = acc;</span><br><span class="line">    acc += *d_i;</span><br><span class="line">    acc += *d_i;</span><br><span class="line">    *d_o = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使此段 C 语言代码也有问题。实际上，在测试激励文件上，除了为 d_i 提供一个值之外，无法执行任何其它操作，或者除了最终写入之外，也不能验证任何对 d_o 的写入。尽管支持多次访问指针，但Xilinx官方还是强烈建议使用 hls::stream 类实现所需的行为。</p><h4 id="指定接口"><a href="#指定接口" class="headerlink" title="指定接口"></a>指定接口</h4><p>接口综合可通过 INTERFACE 指令或使用配置设置来加以控制。要在端口上指定接口模式，请在 GUI 的“Directives”选项卡中选择端口，右键单击并选择“Insert Directive”以打开“Vivado HLS Directive Editor”，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303291045565.png" alt="image-20230329104527503"></p><p>在“Vivado HLS Directives Editor”中，设置以下选项：</p><ul><li><p>“mode”</p><p>从下拉菜单中选择接口模式。</p></li><li><p>“register”</p><p>如果选择该选项，对输入数据会使用register进行暂存，对于输出端口，“register”选项可保证对输出进行寄存。设计者可将“register”选项应用于设计中的任意函数。对于内存、FIFO 和 AXI4 接口，“register”选项无效。</p></li><li><p>“depth”</p><p>该选项用于指定测试激励文件向设计提供的样本数量以及测试激励文件必须存储的输出值数量。以更大的数值为准。（与综合无关）</p><!--：对于在单一传输事务内多次读取或写入的指针，需选中 “depth” 选项才能执行 C/RTL 协同仿真。对于数组而言或者使用 hls::stream 构造时，“depth”选项并不是必需的。 仅当在接口上使用指针时，才需选中该选项。--><p>如果“depth”选项设置过小，那么 C/RTL 协同仿真可能出现死锁，如下所示：</p><ol><li>读取输入数据的操作可能停滞并等待数据，而测试激励文件无法提供这些数据。</li><li>在尝试写出输出数据时可能停滞，因为存储空间已满。</li></ol></li><li><p>“port”</p><p>该选项为必需，指明约束的目标。默认情况下，Vivado HLS 不对端口进行寄存。</p><!--要指定块级 I/O 协议，请在 Vivado HLS GUI 中选择顶层函数，并指定函数返回的端口。--></li><li><p>“offset”</p><p>该选项适用于 AXI4 接口，指明地址偏移量。</p></li></ul><p>要设置接口配置，请选择“Solution” → “Solution Settings” → “General” → “config_interface”。您可使用配置设置来执行如下操作：</p><ul><li>向 RTL 设计添加全局时钟使能。</li><li>移除无关联的端口，例如，由设计中不使用的元素所创建的端口。</li><li>为任意全局变量创建 RTL 端口。</li></ul><p>任何 C 语言函数均可使用全局变量：即定义的作用域超出任意函数作用域的变量。默认情况下，全局变量不会导致创建 RTL 端口：Vivado HLS 假定全局变量位于最终设计内。config_interface 配置设置 expose_global 会指示Vivado HLS 为全局变量创建端口。</p><h3 id="使用AXI接口"><a href="#使用AXI接口" class="headerlink" title="使用AXI接口"></a>使用AXI接口</h3><p>这边就不展开说了，AMBA AXI可以单独写一篇文章来细说了。需要的同学可以自行去ARM官网查阅AXI的协议，并结合UG902查看各配置项的含义。</p><h2 id="Interface-Synthesis-Reference"><a href="#Interface-Synthesis-Reference" class="headerlink" title="Interface Synthesis Reference"></a>Interface Synthesis Reference</h2><p>此参考部分对每一种 Vivado HLS 接口模式进行了解释。</p><h3 id="块级I-O协议"><a href="#块级I-O协议" class="headerlink" title="块级I/O协议"></a>块级I/O协议</h3><p>Vivado HLS 使用接口类型 ap_ctrl_none、ap_ctrl_hs 和 ap_ctrl_chain 来指定是否使用块级握手信号实现RTL。块级握手信号可指定：</p><ul><li>设计何时开始执行操作</li><li>操作何时终止</li><li>设计何时处于空闲状态以及何时准备好处理新输入</li></ul><p>设计者可在函数上或函数返回时指定块级 I/O 协议。如果 C 语言代码不返回值，您仍可在函数返回时指定块级 I/O 协议。如果 C 语言代码使用函数返回，那么 Vivado HLS 会为返回值创建 ap_return 输出端口。</p><p>在块级 I/O 协议中 ap_ctrl_hs (handshake) 为默认协议。下图显示了 Vivado HLS 对函数实现 ap_ctrl_hs 时生成的 RTL 端口和行为。在此示例中，函数使用 return 语句返回值，Vivado HLS 在 RTL 设计中创建 ap_return 输出端口。如果在 C 语言代码中不包含函数 return 语句，则不会创建此端口。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281759879.png" alt="image-20230328175917838"></p><p>ap_ctrl_chain 接口模式类似于 ap_ctrl_hs，但可提供额外的 ap_continue 输入信号以应用反压。赛灵思建议使用 ap_ctrl_chain 块级 I/O 协议将 Vivado HLS IP链接在一起。</p><h4 id="ap-ctrl-none"><a href="#ap-ctrl-none" class="headerlink" title="ap_ctrl_none"></a>ap_ctrl_none</h4><p>如果指定 ap_ctrl_none 块级 I/O 协议，则不创建块级 I/O 协议中所示的握手信号端口（ap_start、ap_idle、ap_ready 和 ap_done）。如果在设计上不指定块级 I/O 协议，那么使用 C/RTL 协同仿真来验证 RTL 设计时，必须遵守接口综合要求中所述条件。</p><h4 id="ap-ctrl-hs"><a href="#ap-ctrl-hs" class="headerlink" title="ap_ctrl_hs"></a>ap_ctrl_hs</h4><p>下图显示了由 ap_ctrl_hs I/O 协议为非流水线化设计创建的块级握手信号的行为。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281801678.png" alt="image-20230328180122623"></p><p>复位后，将执行以下操作：</p><ol><li><p>此模块会等待 ap_start 达到高电平，然后再开始操作。</p></li><li><p>ap_idle 输出会立即变为低电平，以指示设计不再处于空闲状态。</p></li><li><p>ap_start 信号必须保持处于高电平状态，直至 ap_ready 达到高电平状态。当 ap_ready 达到高电平状态后：</p><ul><li>如果 ap_start 保持高电平，设计将启动下一项传输事务。</li><li>如果 ap_start 变为低电平，设计将完成当前传输事务，然后停止操作。</li></ul></li><li><p>可读取输入端口上的数据。</p><!--输入端口可使用独立于此块级 I/O 协议的端口级 I/O 协议。--></li><li><p>可将数据写入输出端口。</p><!--输出端口可使用独立于此块级 I/O 协议的端口级 I/O 协议。--></li><li><p>当模块完成操作后，ap_done 输出会变为高电平状态。</p><!--如果存在 ap_return 端口，那么当 ap_done 处于高电平状态时，此端口上的数据将变为有效。因此，ap_done 信号还用于指示 ap_return 输出上的数据有效。--></li><li><p>当模块准备好接受新输入后，ap_ready 信号会变为高电平状态。以下是有关 ap_ready 信号的其它信息：</p><ul><li>ap_ready 信号处于不活动状态，直至模块开始操作为止。</li><li>在非流水线化设计中，ap_ready 信号与 ap_done 同时断言有效。</li><li>在流水线化设计中，当 ap_start 采样结果为高电平后，ap_ready 信号可能在任意周期变为高电平状态。这取决于设计流水线化的启动间隔。</li><li>如果 ap_start 信号为低电平状态，而 ap_ready 为高电平状态，那么设计将持续执行操作，直至 ap_done变为高电平状态后停止操作。</li><li>如果 ap_start 信号为高电平状态，且 ap_ready 为高电平状态，那么下一项传输事务将立即启动，且模块将继续操作。</li></ul></li><li><p>ap_idle 信号可用于指示设计何时处于空闲且不执行操作状态。以下是有关 ap_idle 信号的其它信息：</p><ul><li>如果 ap_start 信号为低电平状态，而 ap_ready 为高电平状态，那么设计将停止操作，而 ap_idle 信号将在达成 ap_done 后，再经过 1 个周期后变为高电平状态。</li><li>如果 ap_start 信号为高电平状态，且 ap_ready 为高电平状态，那么设计将继续操作，且 ap_idle 信号保持处于低电平状态。</li></ul></li></ol><h4 id="ap-ctrl-chain"><a href="#ap-ctrl-chain" class="headerlink" title="ap_ctrl_chain"></a>ap_ctrl_chain</h4><p>下面介绍 ap_ctrl_chain 的接口协议。该块级 I/O 协议类似于 ap_ctrl_hs 协议，<u>但可提供 1 个额外输入端口</u>，名为 ap_continue。处于高电平有效状态的 ap_continue 信号，可指示使用输出数据的下游块已准备好处理新的数据输入。如果下游块无法使用新数据输入，那么 ap_continue 信号处于低电平状态，这将阻止上游块生成更多数据。</p><p>下游块的 ap_ready 端口可直接驱动 ap_continue 端口。以下是有关 ap_continue 端口的其它信息：</p><ul><li>如果 ap_continue 信号为高电平状态，且 ap_done 为高电平状态，那么设计将继续操作。其它块级 I/O 信号的行为与 ap_ctrl_hs 块级 I/O 协议中描述的行为相同。</li><li>如果 ap_continue 信号为低电平状态，而 ap_done 为高电平状态，那么设计将停止操作，ap_done 信号将保持高电平状态，并且如果存在 ap_return 端口，那么 ap_return 端口上的数据将保持有效。</li></ul><p>在下图中，第 1 项传输事务已完成，第 2 项传输事务立即启动，因为 ap_continue 为高电平状态，且 ap_done 为高电平状态。但设计在第 2 项传输事务结束后将暂停，直至 ap_continue 断言为高电平有效为止。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282210604.png" alt="image-20230328221037464"></p><h3 id="端口级I-O协议"><a href="#端口级I-O协议" class="headerlink" title="端口级I/O协议"></a>端口级I/O协议</h3><h4 id="ap-none"><a href="#ap-none" class="headerlink" title="ap_none"></a>ap_none</h4><p>ap_none 端口级 I/O 协议是最简单的接口类型，没有与之关联的其它信号。输入和输出数据信号都没有关联的控制端口以指示何时读取或写入数据。RTL 设计中仅有的端口是源代码中指定的端口。</p><p>ap_none 接口无需额外硬件开销。但是，ap_none 接口需满足以下条件：</p><ul><li>生产者模块执行以下操作之一：<ul><li>在正确的时间向输入端口提供数据</li><li>在执行传输事务期间保留数据，直到设计完成</li></ul></li><li>使用者模块在正确的时间读取输出端口</li></ul><!--ap_none 接口不能与数组实参一起使用。--><h4 id="ap-stable"><a href="#ap-stable" class="headerlink" title="ap_stable"></a>ap_stable</h4><p>与 ap_none 一样，ap_stable 端口级 I/O 协议不会向设计添加任何接口控制端口。<u>ap_stable 类型通常用于可更改但在正常操作期间保持稳定的数据</u>，例如提供配置数据的端口。ap_stable 类型向 Vivado HLS 发送下列通知：</p><ul><li>应用于端口的数据在正常操作期间应保持稳定，但不是可以被优化掉的常量值。</li><li>此端口的扇出无需寄存。</li></ul><!--ap_stable 类型只能应用于输入端口。当应用于输入输出 (inout) 端口时，仅端口的输入被视为稳定。--><h4 id="ap-hs（ap-ack、ap-vld和ap-ovld）"><a href="#ap-hs（ap-ack、ap-vld和ap-ovld）" class="headerlink" title="ap_hs（ap_ack、ap_vld和ap_ovld）"></a>ap_hs（ap_ack、ap_vld和ap_ovld）</h4><p>ap_hs 端口级 I/O 协议在开发过程中提供了最大的灵活性，允许采用自下而上和自上而下的设计流程。双向握手可安全执行所有模块间通信，无需人为干预或假设即可正确执行。ap_hs 端口级 I/O 协议提供以下信号：</p><ul><li>数据端口</li><li>用于指示何时使用数据的确认信号</li><li>用于指示何时读取数据的 valid 信号</li></ul><p>下图显示了 ap_hs 接口对应输入和输出端口的行为。在此示例中，输入端口名为 in，输出端口名为 out。</p><!--控制信号名称基于原始端口名称。例如，用于数据输入 in 的 valid 端口名为 in_vld。--><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282220319.png" alt="image-20230328222020173"></p><p>对于输入，将执行以下操作：</p><ul><li><p>应用 start 后，该模块开始正常操作。</p></li><li><p>如果设计已准备好输入数据，但输入 valid 处于低电平状态，则设计将停滞并等待断言输入 valid 有效以指示存在新的输入值。</p><!--上图显示了此行为。在此示例中，设计已准备好在时钟周期 4 上读取数据输入 in、停滞并等待输入valid，然后再读取数据。--></li><li><p>当输入 valid 断言为高电平有效 (High) 时，in_ack 将断言为高电平有效 (High)，表明已读取数据。</p></li></ul><p>对于输出，将执行以下操作：</p><ul><li>应用 start 后，该模块开始正常操作。</li><li>写入输出端口时，将同时断言其关联的输出 valid 信号有效，以指示端口上存在 valid 数据。</li><li>如果关联的 out_ack 为低电平，则设计将停滞并等待断言 out_ack 有效。</li><li>当 out_ack 确认有效后，将在下一个时钟沿断言 out_valid 无效。</li></ul><h4 id="ap-ack"><a href="#ap-ack" class="headerlink" title="ap_ack"></a>ap_ack</h4><p>ap_ack 端口级 I/O 协议是 ap_hs 接口类型的<strong>子集</strong>。ap_ack 端口级 I/O 协议提供以下信号：</p><ul><li><p>数据端口</p></li><li><p>用于指示何时使用数据的ack信号（删去了ap_hs中的in_vld和out_vld信号，仅保留input和output端口的ack信号）</p><ul><li><p>对于输入实参，设计会在读取输入的周期中生成高电平ack信号进行确认。</p></li><li><p>对于输出实参，Vivado HLS 会实现ack端口来确认已读取输出。</p><!--写入操作之后，设计将停滞并等待，直到输入确认断言为高电平有效为止，这表明使用者块已读取输出。但是，不存在可用于指示何时可以使用数据的关联输出端口。--></li></ul></li></ul><h4 id="ap-vld"><a href="#ap-vld" class="headerlink" title="ap_vld"></a>ap_vld</h4><p>ap_vld 是 ap_hs 接口类型的子集。ap_vld 端口级 I/O 协议提供以下信号：</p><ul><li>数据端口</li><li>用于指示何时读取数据的 valid 信号（删去了ap_hs中的ack信号，仅保留vld信号）<ul><li>对于输入实参，模块在 valid 端口有效后立即读取数据端口。即使模块尚未准备好读取新数据，也会对数据端口进行采样并在内部保留数据，直到需要时为止。</li><li>对于输出实参，Vivado HLS 会实现输出 valid 端口以指示输出端口上的数据何时为 valid。</li></ul></li></ul><h4 id="ap-ovld"><a href="#ap-ovld" class="headerlink" title="ap_ovld"></a>ap_ovld</h4><p>ap_ovld 是 ap_hs 接口类型的子集。ap_ovld 端口级 I/O 协议提供以下信号：</p><ul><li>数据端口</li><li>用于指示何时读取数据的 valid 信号<ul><li>对于输入实参和inout类型参数中的输入部分，设计默认为 ap_none 类型。</li><li>对于输出实参和inout类型参数中的输出部分，设计实现 ap_vld 类型。</li></ul></li></ul><h4 id="ap-memory-bram"><a href="#ap-memory-bram" class="headerlink" title="ap_memory, bram"></a>ap_memory, bram</h4><p>ap_memory 和 bram 接口端口级 I/O 协议用于<u>实现数组实参</u>。当实现要求随机访问内存地址位置时，这种类型的端口级 I/O 协议可以与内存元件（例如，RAM 和 ROM）通信。</p><!--如果只需顺序访问内存元件，请改用 ap_fifo 接口。ap_fifo 接口可以减少硬件开销，因为不执行地址生成。--><p>ap_memory 和 bram 接口端口级 I/O 协议相同。唯一的区别是 Vivado IP integrator 显示模块的方式：</p><ul><li>ap_memory 接口显示为离散端口。</li><li>bram 接口显示为单一端口（已组合）。在 IP integrator 中，可使用单一连接来创建到所有端口的连接。</li></ul><p>使用 ap_memory 接口时，请使用 RESOURCE 指令指定数组目标。如果没有为数组指定目标，则 Vivado HLS 会决定是使用单端口还是双端口 RAM 接口。</p><!--运行综合前，请使用 RESOURCE 指令确保将数组实参定向到正确的内存类型。使用更正后的内存进行重新综合可能会导致生成的 RTL 不同。--><p>下图显示了一个名为 d 的数组，该数组指定为单端口 BRAM。端口名称基于 C 语言函数实参。例如，如果 C 语言实参为 d，则根据 BRAM 的 output/q 端口，芯片使能为 d_ce，输入数据为 d_q0。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282305814.png" alt="image-20230328230531655"></p><p>复位后，将执行以下操作：</p><ul><li><p>断言 ap_start 后，该模块开始正常操作。</p></li><li><p>通过在断言输出信号 d_ce 有效的同时在输出地址端口上应用地址来执行读取。</p><!--对于默认的 BRAM，设计期望在下一个时钟周期中，输入数据 d_q0 可用。您可以使用 RESOURCE 指令来指示 RAM 具有更长的读取时延。--></li><li><p>通过断言输出端口 d_ce 和 d_we 有效并同时应用地址和输出数据 d_d0 来执行写操作。</p></li></ul><h4 id="ap-fifo"><a href="#ap-fifo" class="headerlink" title="ap_fifo"></a>ap_fifo</h4><p>写入输出端口时，当设计需要访问内存元件<u>并且访问始终以顺序方式执行时</u>，即不需要随机访问，则ap_fifo接口是最节省资源的方法。ap_fifo 端口级 I/O 协议支持以下操作：</p><ul><li>允许端口连接到 FIFO</li><li>启用完整的双向 empty-full 通信</li><li>适用于数组、指针和按引用传递实参类型</li></ul><p>在下图示例中，in1 是一个指针，该指针访问当前地址，然后访问当前地址上面的两个地址，最后访问下面的一个地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>* in1, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> data1, data2, data3;</span><br><span class="line">    ...</span><br><span class="line">    data1= *in1;</span><br><span class="line">    data2= *(in1+<span class="number">2</span>);</span><br><span class="line">    data3= *(in1<span class="number">-1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 in1 指定为 ap_fifo 接口，则 Vivado HLS 会检查访问、判定访问并非按顺序进行，随即发出错误消息并中止。要从非顺序地址读取，请使用 ap_memory 或 bram 接口。</p><p><u>不能在同时支持读取和写入的实参上指定 ap_fifo 接口</u>。您只能在输入或输出实参上指定 ap_fifo 接口。含输入实参 in 和输出实参 out（指定为 ap_fifo 接口）的设计的行为如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282311023.png" alt="image-20230328231130875"></p><p>对于输入，将执行以下操作：</p><ul><li>断言 ap_start 后，该模块开始正常操作。</li><li>如果输入端口已准备好读取，但输入端口 in_empty_n 处于低电平状态，指示 FIFO 为空，则设计将停滞并等待数据可用。</li><li>当输入端口 in_empty_n 处于高电平状态，指示 FIFO 包含数据时，将断言输出确认 in_read 为高电平有效以指示当前周期中已读取数据。</li></ul><p>对于输出，将执行以下操作：</p><ul><li>断言 ap_start 后，该模块开始正常操作。</li><li>如果输出端口已准备好写入，但 out_full_n 处于低电平状态，指示 FIFO 已满，则数据将置于输出端口上，但设计将停滞并等待 FIFO 中的空间可用。</li><li><p>当 out_full_n 处于高电平状态，指示 FIFO 中有可用空间时，将断言输出确认信号 out_write 有效以指示输出数据为 valid。</p></li><li><p>如果顶层函数或顶层循环已使用 -rewind 选项进行流水线化，则 Vivado HLS 将创建另一个后缀为 lwr 的输出端口。当最后一次写入 FIFO 接口完成时，lwr 端口将变为高电平有效。</p></li></ul><h4 id="ap-bus"><a href="#ap-bus" class="headerlink" title="ap_bus"></a>ap_bus</h4><p>ap_bus 接口可以与总线桥通信。由于 ap_bus 接口未遵循特定的总线标准，因此可将此接口用于与系统总线进行通信的总线桥。<u>总线桥必须能够对所有突发写入进行高速缓存。</u></p><p>设计者可以通过以下方式使用 ap_bus 接口：</p><ul><li><p>标准模式：此模式执行单独的读操作和写操作，并为每项操作指定地址。</p></li><li><p>突发模式：如果在 C 语言源代码中使用了 C 语言函数 memcpy，则此模式将执行数据传输。在突发模式下，该接口指示基址和传输大小。然后以连续的周期传输数据样本。</p><!--memcpy 函数访问的数组不能partitioned到寄存器中。--></li></ul><p>以下示例显示了将 ap_bus 接口应用于实参 d 时，标准模式下的读写操作的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span> <span class="params">(<span class="type">int</span> *d)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> acc = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">        acc += d[i+<span class="number">1</span>];</span><br><span class="line">        d[i] = acc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下示例显示了使用 C memcpy 函数和突发模式时的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bus</span> <span class="params">(<span class="type">int</span> *d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> buf1[<span class="number">4</span>], buf2[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">memcpy</span>(buf1,d,<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">    buf2[i] += buf1[<span class="number">1</span>+i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">memcpy</span>(d,buf2,<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ap_bus标准读取和写入的时序图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282323381.png" alt="image-20230328232306226"></p><p>对于ap_bus的标准读过程，在复位后将执行下列操作：</p><ul><li><p>断言 ap_start 后，该模块开始正常操作。</p></li><li><p>如果执行读取时 d_rsp_empty_n 为低电平，指示总线桥 FIFO 中没有数据，则会执行以下操作：</p><ul><li>断言输出端口 d_write_req 有效，并断言端口 r_req_in 无效，以指示读取操作。</li><li>输出地址。</li><li>设计停滞并等待数据可用。</li></ul></li><li><p>当数据可用于读取输出信号时，立即断言 d_rsp_read 有效并在下一个时钟沿读取数据。</p></li><li><p>如果执行读取时 d_rsp_empty_n 为高电平，指示总线桥 FIFO 中有可用数据，则会执行以下操作：</p><ul><li><p>断言输出端口 d_write_req 有效，并断言端口 r_req_in 无效，以指示读取操作。</p></li><li><p>输出地址。</p></li><li><p>在下一个时钟周期断言输出信号 d_rsp_read 有效，并在下一个时钟沿读取数据。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282323936.png" alt="image-20230328232317782"></p></li></ul></li></ul><p>对于ap_bus的标准写过程，在复位后将执行下列操作：</p><ul><li>断言 ap_start 后，该模块开始正常操作。</li><li>如果执行写入时 d_req_full_n 为低电平，指示总线桥 FIFO 中没有空间可用，则会执行以下操作：<ul><li>输出地址和数据。</li><li>设计停滞并等待空间可用。</li></ul></li><li>当有空间可用于写入时，将执行以下操作：<ul><li>断言输出端口 req_write 和 d_req_din 有效，以指示写操作。</li><li>立即断言输出信号 d_req_din 有效以指示该数据在下一个时钟沿有效。</li></ul></li><li>如果执行写入时d_req_full_n 为高电平，指示总线桥 FIFO 中有可用空间，则会执行以下操作：<ul><li>断言输出端口 req_write 和 d_req_din 有效，以指示写操作。</li><li>输出地址和数据。</li><li>断言输出信号 d_req_din 有效以指示该数据在下一时钟沿有效。</li></ul></li></ul><p>ap_bus突发读取和写入的时序图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282333994.png" alt="image-20230328233347839"></p><p>对于ap_bus的突发读过程，在复位后将执行下列操作：</p><ul><li>断言 ap_start 后，该模块开始正常操作。</li><li>如果执行读取时 d_rsp_empty_n 为低电平，指示总线桥 FIFO 中没有数据，则会执行以下操作：<ul><li>断言输出端口 d_req_write 有效，并断言端口 d_req_din 无效，以指示读取操作。</li><li>输出传输的基地址和传输长度。</li><li>设计停滞并等待数据可用。</li></ul></li><li>当数据可用于读取输出信号时，立即断言 d_rsp_read 有效，并在接下来的 N 个时钟沿读取数据，其中 N 是d_size的值。</li><li>如果总线桥 FIFO 的值已清空，数据传输将立即停止，并等待数据可用后再继续。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282337164.png" alt="image-20230328233703018"></p><p>对于ap_bus的突发写过程，在复位后将执行下列操作：</p><ul><li>断言 ap_start 后，该模块开始正常操作。</li><li>如果执行写入时d_req_full_n 为低电平，指示总线桥 FIFO 中没有空间可用，则会执行以下操作：<ul><li>输出基址、传输大小和数据。</li><li>设计停滞并等待空间可用。</li></ul></li><li>当有空间可用于写入时，将执行以下操作：<ul><li>断言输出端口 d_req_write 和 d_req_din 有效，以指示写操作。</li><li>立即断言输出信号 d_req_din 有效以指示该数据在下一个时钟沿有效。</li><li>如果 FIFO 已满，则会立即断言输出信号 d_req_din 无效，并在空间可用时重新断言。</li><li>传输于完成 N 个数据值后停止，其中 N 是d_size的值。</li></ul></li><li>如果执行写入时 d_rsp_full_n 为高电平，指示总线桥 FIFO 中有可用空间，则传输开始，设计停滞并等待直到 FIFO 已满。</li></ul><h4 id="axi-s"><a href="#axi-s" class="headerlink" title="axi_s"></a>axi_s</h4><p>axis 模式指定 AXI4-Stream I/O 协议。</p><h4 id="s-axilite"><a href="#s-axilite" class="headerlink" title="s_axilite"></a>s_axilite</h4><p>s_axilite 模式指定 AXI4-Lite <strong>从接口</strong> I/O 协议。</p><h4 id="m-axi"><a href="#m-axi" class="headerlink" title="m_axi"></a>m_axi</h4><p>m_axi 模式指定 AXI4 <strong>主接口</strong> I/O 协议。</p><h2 id="How-to-use-HLS"><a href="#How-to-use-HLS" class="headerlink" title="How to use HLS?"></a>How to use HLS?</h2><p>这边本文不展开说了，本文主要目的是带大家熟悉HLS中基本的约束情况。工具的详细使用教程请大家参考官方例程文档<a href="https://docs.xilinx.com/v/u/en-US/ug871-vivado-high-level-synthesis-tutorial">UG871</a>，跟着教程做完实验基本就可以熟悉HLS的设计、验证以及后续导出RTL设计的流程了，其中与结果分析相关的实验需要好好学习，在后续实际使用中遇到问题时才有调试的思路。</p><h2 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more?"></a>What’s more?</h2><p>虽然我们思考问题尽量要从源头出发，但解决问题时如果有一些前人的成果可以参考的话那就再好不过了，本章简要介绍一下HLS中自带的各种算法库，其中有些笔者使用过，有些并没有用过。只能对着官方文档”省流”一波，更多细节的内容大家可以去UG902自行查阅。</p><p>1、Arbitrary Precision Data Types Library：顾名思义，扩展了数据的类型。Then，Why？原生的基于C的数据类型都是字节对齐的，如8,16,32,64bits。但RTL的数据类型是支持任意宽度的，所以HLS需要设计一种机制来满足任意位宽的数据的声明，而不能像C语言一样有Byte对齐的要求。假设如果没有该库，我们需要用HLS实现一个17bit的乘法器，那么HLS会将其强制实现为32bit的乘法器。总而言之，该库可以让我们更高效地利用硬件资源，以bit为单位给数据设置位宽。</p><p>2、HLS Stream Library：Stream是一种数据类型，Stream中的数据都是依序采样后发送，没有地址的概念，可以借助FIFO的概念来辅助理解。在C语言中对Stream类型的数据进行建模比较困难，C中一般是基于指针对数据进行存取，因此使用HLS Stream Lib对构建Stream数据类型的设计与仿真贡献较大。</p><p>3、HLS Math Library：顾名思义，可以实现一些高效的数学运算，如指数、对数、三角、幂函数、取整、乘除、比较等等函数。</p><p>4、其余的笔者目前没怎么用到过，还有HLS Video Library，HLS IP Libraries，HLS Linear Algebra Library，HLS DSP Library等，大家需要的话可以自行查阅原文档。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="https://docs.xilinx.com/v/u/en-US/ug902-vivado-high-level-synthesis">UG902-Vivado Design Suite User Guide: High-Level Synthesis</a></p><p><a href="https://docs.xilinx.com/v/u/en-US/ug871-vivado-high-level-synthesis-tutorial">UG871-Vivado Design Suite Tutorial: High-Level Synthesis</a></p><p><a href="https://www.xilinx.com/content/dam/xilinx/support/documents/sw_manuals/ug1197-vivado-high-level-productivity.pdf">UG1197-UltraFast Vivado HLS Methodology Guide</a></p></blockquote>]]></content>
    
    
    <summary type="html">简要介绍了HLS工具及其使用方法</summary>
    
    
    
    <category term="FPGA" scheme="http://david-luge.cn/categories/FPGA/"/>
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/categories/FPGA/FPGA-Tools/"/>
    
    
    <category term="FPGA_Tools" scheme="http://david-luge.cn/tags/FPGA-Tools/"/>
    
  </entry>
  
  <entry>
    <title>低功耗设计简述</title>
    <link href="http://david-luge.cn/2023/03/24/IC/Basic/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/"/>
    <id>http://david-luge.cn/2023/03/24/IC/Basic/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-03-24T07:38:39.000Z</published>
    <updated>2023-03-24T07:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h1><p>芯片的整体功耗从根本上可以分为静态功耗和动态功耗；</p><p>静态功耗，又称漏电流功耗，是器件特性，和晶体管的阈值电压及其自身特性有关；</p><p>动态功耗，主要是芯片中的寄生RC电路的充放电引起的。换言之，当芯片中的电路出现任何信号翻转，都会产生动态功耗，其中所占最大比例的是时钟信号的翻转。</p><p>动态功耗还可以分为翻转功耗和短路功耗。翻转功耗和电压、翻转率和负载电容有关，所以降翻转功耗的措施就是降压、降翻转率和减负载电容；</p><p>短路功耗是指在晶体管翻转时，nMOS和pMOS会存在同时导通的情况，这时候产生的功耗称为短路功耗。</p><p>现代SoC的功耗主要集中在：时钟树功耗(40%)、CPU、GPU、存储器等；<br>功耗的整体计算公式为：</p><script type="math/tex; mode=display">P=(C{\times}V^2{\times}f)+(t{\times}V{\times}I{\times}f)</script><p>前面的部分是翻转功耗，后面的部分是短路功耗；</p><h2 id="静态低功耗技术"><a href="#静态低功耗技术" class="headerlink" title="静态低功耗技术"></a>静态低功耗技术</h2><p><strong>电源门控</strong>是直接切断电源来减少漏电流；</p><p>而<strong>多阈值工艺</strong>和<strong>体偏置</strong>则是通过改变CMOS管的阈值电压来减少静态功耗；</p><h3 id="电源门控"><a href="#电源门控" class="headerlink" title="电源门控"></a>电源门控</h3><p>指直接关掉某一不用模块的电源，这样可以直接关闭动态和静态功耗；</p><p>局限：会引入额外的开销；模块的唤醒需要时间，功耗达到最终的power gating功耗(即使power gating仍然会有少量的漏电流)也需要时间。如果芯片一直在工作，则power gating的收益就有些小。总结而言就是需要考虑唤醒开销和power gating节省的功耗哪个大。</p><p>实际做法：<br>1、两个电源域，每个电源域引出单独的物理管脚，直接物理关断；适合长时间的关断；<br>2、内部关断：在片上实现一个电源控制器，类似于一个开关，进行电压切换；</p><p>为了关断power，我们可以把Vdd换成Vss，也可以将Vss换成Vdd。但一般情况下最好把Vdd换成Vss，因为多电源域一般共地，但Vdd各不相同。<br>(注，Vdd中d=device，指器件的工作电压；Vss中s=series表示公共连接的意思，也就是公共接地端)</p><p>需添加专用的隔离单元(isolation cell)，如特殊处理的与门(输出与隔离信号相与，输出低电平)，隔离单元处于源模块，但电源一般不关；或者需要给出主电源和备用电源，保证在power down的时候隔离单元还能继续工作；</p><p>典型的门控电源的过程：<br>1、关闭时钟；<br>2、打开隔离信号；<br>3、发出save脉冲，提示保存好相关寄存器；<br>4、拉低rst_n；<br>5、关闭电源；<br>6、打开该电源域时，在复位信号拉高后发出恢复信号脉冲；</p><p>对于门控电源，具体的实现是在后端，对于架构来讲需要分清楚有几个电压域，有几种低功耗模式；对于前端来讲，要搞清楚接口信号，同时需要实现一个控制器来断电和唤醒电源域，且加上隔离模块；</p><h3 id="多阈值工艺"><a href="#多阈值工艺" class="headerlink" title="多阈值工艺"></a>多阈值工艺</h3><p>为了满足工作频率越来越高的要求，厂商逐渐降低晶体管的阈值电压Vt，使得晶体管能高速翻转；但是如果阈值电压Vt太低，则晶体管不能完全关断，这将产生很大的静态功耗；</p><p>相关名词：<br>HVT(High V threshold) 高电压阈值<br>LVT (Low V threshold)  低电压阈值<br>SVT(Standard V threshold) 标准电压阈值</p><p>阈值电压与器件速度和泄露功率的关系：<br>阈值电压↓ =&gt; 器件速度↑ 泄露功率↑<br>阈值电压↑ =&gt; 器件速度↓ 泄露功率↓</p><p>总结：在设计中可以在关键路径上使用低阈值的标准逻辑单元来优化时序；在非关键路径上使用高阈值标准逻辑单元来优化漏电流；</p><p>优点：<br>大大减少系统的静态功耗；<br>没有任何面积开销，工艺库设计是将两种阈值库中的相应单元的面积设计成一样的，这样可以方便替换；</p><h3 id="体偏置"><a href="#体偏置" class="headerlink" title="体偏置"></a>体偏置</h3><p>对同一晶体管而言，阈值电压也会发生变化。晶体管的阈值电压随着CMOS管衬底的偏置电压变化而变化，而阈值电压影响我们的静态功耗，所以我们可以通过改变偏置电压来改变阈值电压。<br>在工作模式下，MOS管的体偏置为0，MOS管处于低阈值状态，翻转速度快；<br>在等待模式下，MOS管的体偏置为反向偏置，处于高阈值状态，漏电流小；</p><p>注意：MOS管的体偏置需要时间，电路由等待模式转为工作模式的时间较长；</p><h2 id="动态低功耗技术"><a href="#动态低功耗技术" class="headerlink" title="动态低功耗技术"></a>动态低功耗技术</h2><h3 id="多电压域"><a href="#多电压域" class="headerlink" title="多电压域"></a>多电压域</h3><p>动态功耗的主要组成部分—翻转功耗，是Vdd的平方，静态功耗中的主要组成部分漏电流和Vdd成正比，所以降功耗最有效的方法就是降电压。<br>但降电压会增加延时，降低门单元的性能，所以很多低功耗技术就是在满足芯片性能要求的前提下，尽可能地降低芯片的工作电压Vdd。<br>如果不同电压域之间的驱动信号与接收信号距离很远，则需插入特殊的驱动单元(Repenter)来增强信号的驱动能力；如果不同的电压域可以单独断电，则需要考虑添加保持寄存器和电压隔离单元；</p><p>代价：<br>需要变压器；因为你拿0.7v的电压域信号去驱动1.0v的电压域很容易导致1.0v的晶体管时时刻刻在漏电，且变压器会造成延时；<br>时序分析不好做；<br>布局时电源网络更加复杂；<br>上电断电顺序可能是有要求的；<br>对于架构设计者而言，主要就是搞清楚电压是影响时序的，确保不会因为多电源域影响系统功能就好；</p><p>多电压域技术可以分为四种：<br>静态多电压技术(MSV)，对不同的模块固定为不同的电压；<br>动态电压频率缩放技术(DVFS)，对于该模块可以选择几种不同的电压配置，同时电压调整一般会同时调整频率，所以就称为动态电压频率缩放技术；<br>自适应电压频率缩放技术(AVFS)，DVFS需要软件根据不同的应用场景选择不同的电压频率配置，如果更进一步，对改模块的电压频率能够自适应地调整，那么就是自适应电压频率缩放技术；<br>电压关断技术(PSO)，如果某个模块在有些情况下不使用了，我们可以关掉这个模块的电压，需要的时候再打开，又称为电源门控，本质上是一种电压调节的特例；</p><h3 id="门控时钟"><a href="#门控时钟" class="headerlink" title="门控时钟"></a>门控时钟</h3><p>直接停掉时钟，这样可以减少动态功耗。实际上在数字芯片中时钟网络占用了很大功耗，可能超过50%。</p><p>举例说明门控时钟的概念：比如寄存器，当EN信号有效的时候才进行寄存，不如用EN信号将时钟信号进行屏蔽。<br>注意！门控时钟虽然是很直接的办法，但一般来说不用自己RTL层面写门控时钟，工具会自动优化，自己写的门控时钟有可能产生毛刺影响性能；</p><p>如果仅将时钟信号和时钟使能信号相与之后的输出作为模块的时钟输入，则可能存在毛刺；避免毛刺的方式有两种：<br>采用锁存门控；若锁存器和与门相差很远，则延迟差别较大，仍可能存在毛刺；若时钟使能信号距离锁存器关断信号很近，可能会不满足锁存器的建立时间从而出现亚稳态；<br>采用寄存门控；用寄存器来寄存EN信号再与上时钟信号得到门控时钟信号；此时需要寄存EN信号的寄存器满足建立时间要求；</p><p>实际中看起来寄存结构的门控时钟问题要少，但在实际的SoC中，使用最多的还是锁存结构的门控时钟；<br>最主要的原因是节省面积！一个DFF由两个锁存器组成，当大量的门控时钟插入到SoC芯片中时，这个节省的面积就相当可观了。<br>当然，这里说的是SoC芯片中使用的标准库单元。如果是FPGA或者用RTL实现，个人认为还是使用寄存器门控+setup约束来实现比较稳妥；</p><p>那在SoC中锁存门控的问题如何解决呢？在实际的SoC芯片中，要使用大量的门控时钟单元，所以通常会把门控时钟做成一个标准单元，由工艺厂商来提供。所以锁存器结构中线延时带来的问题就不存在了，因为是做成一个单元，线延时是可控和不变的，而且还可以通过挑选锁存器和增加延时，总是能满足锁存器的建立时间。这样通过工艺厂预先把门控时钟做成标准单元，这些问题都解决了。</p><p>做门控时钟的时候需要注意以下两点：<br>通常在位宽较大的寄存器上加时钟门控，因为加门控时钟本身也会增加面积和功耗，所以要综合考虑；<br>加了门控时钟之后要保证原本的电路功能不变；</p><p>Tips：<br>RTL编码中，将不用的数据设置成0并不能减少功耗，保持数据不变才能减少翻转，降低功耗。</p><h2 id="RTL级低功耗技术"><a href="#RTL级低功耗技术" class="headerlink" title="RTL级低功耗技术"></a>RTL级低功耗技术</h2><p>对于前端RTL设计而言，<strong>降低功耗无非两点</strong>：<br>对于寄存器，不工作的时候关闭时钟；<br>对于组合逻辑，减少无效的跳变；</p><p>设计中可以考虑的点：</p><ol><li><strong>状态机的编解码</strong>：在各种状态机的编码中，格雷码是最适合低功耗设计的。因为它在状态转换过程中每次只有一个触发器变化，同时，格雷码编码的状态机也消除了依赖于状态组合等式中存在毛刺的风险；</li><li><strong>门控时钟</strong>：编码方式   if（~rst_n） else if（en_load）；</li><li><strong>独热码多路器</strong>：将多输入MUX采用独热码编码方式，可以综合为与门和或门，降低功耗；</li><li><strong>操作数隔离</strong>，操作数隔离就是增加一些选择器件，如果这个操作数不需要的话就不选择它以及不进行这个操作数所需要的相应计算。在sel信号之前通过将sel和数据信号相与可以降低mux前端信号的翻转率；</li><li><strong>资源共享</strong>，将相同的处理使用组合逻辑预先产生，在调用的时候直接调用，不需要把相同的操作复制；</li><li><strong>总线翻转编码</strong>，在当前数据和下一个数据之间的汉明距离（汉明距离指的是两个数中不相同位的数量）大于N/2的时，将下一个数据取反后再传输，以减少总线上出现转换的位数量，即总线反转编码；该技术的缺点是需要传输一个额外的控制位，用以表征总线数据是否进行了翻转编码，消耗了系统总线的带宽；</li></ol><p>当模块在某段时间完全不工作的时候，你可以：1、在这段时间里关掉这个模块的时钟；2、检查这个模块的输入，对于还在跳变的输入，将其全部固定为恒定值，这样才能根除这个模块的动态功耗；</p><h2 id="门级优化技术"><a href="#门级优化技术" class="headerlink" title="门级优化技术"></a>门级优化技术</h2><p>个人感觉节省的功耗比较鸡肋，仅做了解即可；</p><h3 id="毛刺的消除"><a href="#毛刺的消除" class="headerlink" title="毛刺的消除"></a>毛刺的消除</h3><p>毛刺指由于电路中信号的传输延迟引起的不必要的翻转；通过插入缓冲器改变信号的传输延迟从而消除信号的毛刺；</p><h3 id="逻辑级优化"><a href="#逻辑级优化" class="headerlink" title="逻辑级优化"></a>逻辑级优化</h3><p>引脚的重分配：对同一个门而言，有可能各Pin的功耗不一致，我们将变化率低的信号连接到低功耗的Pin上就有好处。用负载电容低的引脚去连接快速翻转的信号，降低系统的动态功耗；<br>重排序操作：通过对门级电路的重排序，使得其驱动的门数量降低，从而降低系统的动态功耗；</p><h3 id="物理级优化"><a href="#物理级优化" class="headerlink" title="物理级优化"></a>物理级优化</h3><p>使用低功耗的库；<br>使用低功耗的布局规划；<br>通过布局布线来减少毛刺；<br>在优化布局的时候调整缓冲器和连线的大小；<br>调整晶体管的大小减少负载电容；</p><h3 id="控制输入向量"><a href="#控制输入向量" class="headerlink" title="控制输入向量"></a>控制输入向量</h3><p>系统在睡眠状态下，控制输入向量可以明显减少系统的漏电流。（选择最小漏电流的向量作为组合逻辑的输入）</p><h1 id="以反相器为例解释静态-动态功耗"><a href="#以反相器为例解释静态-动态功耗" class="headerlink" title="以反相器为例解释静态/动态功耗"></a>以反相器为例解释静态/动态功耗</h1><p>反相器的结构如下图所示，由一个PMOS和一个NMOS串联而成，负载电容记为$C_L$。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241657743.png" alt="1"></p><h2 id="动态功耗"><a href="#动态功耗" class="headerlink" title="动态功耗"></a>动态功耗</h2><h3 id="电容充放电引起的动态功耗"><a href="#电容充放电引起的动态功耗" class="headerlink" title="电容充放电引起的动态功耗"></a>电容充放电引起的动态功耗</h3><p>当$C<em>L$通过PMOS充电时，$V</em>{C<em>L}$从0V上升至$V</em>{DD}$，电路从电源$V<em>{DD}$上抽取一定的能量，一部分消耗在PMOS上，另一部分被电容$C_L$存储。$V</em>{out}$由高至低进行电平翻转时，$C_L$通过NMOS放电，之前存储在$C_L$中的能量被NMOS消耗。</p><p>下面计算$V<em>{out}$由低至高电平翻转的过程从电源上抽走的能量，假设$V</em>{in}$的电平上升和下降时间为零，即NMOS和PMOS不可能同时导通，此时CMOS反相器可以等效为下图所示的电路。</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241704535.png" alt="2"></p><p>$i<em>{VDD}$和$V</em>{out}$是随时间变化的，可以看做是时间的函数，在0—dt时间范围内从电源上抽取的能量微元为：</p><script type="math/tex; mode=display">dE_{VDD}=i_{VDD}V_{DD}dt</script><p>理论上$C<em>L$充电至$V</em>{DD}$所用的时间为无穷大，因此$C_L$充电过程中从电源上抽取的总能量为：</p><script type="math/tex; mode=display">E_{VDD}=\int_{0}^{\infty}i_{VDD}(t)V_{DD}\,dt=V_{DD}\int_{0}^{\infty}C_L\frac{d_{V_{out}(t)}}{dt}\,dt=C_LV_{DD}\int_{0}^{\infty}\,dV_{out}=C_LV_{DD}^2</script><p>电容$C_L$在0—dt时间范围内存储的能量微元为：</p><script type="math/tex; mode=display">d_{E_C}=i_{VDD}(t)V_{out}(t)dt</script><p>电容$C<em>L$充电至$V</em>{DD}$存储的能量为：</p><script type="math/tex; mode=display">E_C=\int_{0}^{\infty}i_{VDD}(t)V_{out}(t)\,dt=\int_{0}^{\infty}V_{out}(t)C_L\frac{dV_{out}}{dt}\,dt=C_L\int_{0}^{V_{DD}}V_{out}\,dV_{out}=\frac{1}{2}C_LV_{DD}^2</script><p>由$E<em>{VDD}$和$E</em>{C}$可以看出，电容$C<em>L$充电期间从电源抽取的能量只有一半存储到$C_L$中了，另一半被PMOS消耗，而存储到电容$C_L$中的这一半能量将在电容放电期间被NMOS消耗掉，也就是说CMOS反相器每经过一次开关周期（“0”→“1”→“0”）所消耗的能量为$C_LV</em>{DD}^2$，如果一个反相器每秒开关f次，则功耗为：</p><script type="math/tex; mode=display">P_{dyn}=\frac{E_{VDD}}{T}=C_LV_{DD}^2f</script><p>其中，T为开关周期，f为开关频率。</p><h3 id="NMOS和PMOS同时导通（过渡区）引起的功耗"><a href="#NMOS和PMOS同时导通（过渡区）引起的功耗" class="headerlink" title="NMOS和PMOS同时导通（过渡区）引起的功耗"></a>NMOS和PMOS同时导通（过渡区）引起的功耗</h3><p>前面假假设了输入波形的上升、下降时间为零，这是个理想状态，实际上$V_{in}$的上升、下降时间不可能为零，当CMOS反相器处于两个管子同时导通的过渡区时，电源对地有一条直流通路，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241728158.png" alt="3"></p><p>当直流脉冲可近似看做三角形以及输入电平上升与下降时间相等时，每经过一个开关周期（“0” →“1” →“0”）所消耗的能量为：</p><script type="math/tex; mode=display">E_{dp}=E_{dpr}+E_{dpf}</script><p>$E<em>{dpr}$即$V</em>{in}$电平上升期间的直流通路能耗，通过上图(b)可以发现，$0{\sim}{\frac{t<em>{sc}}{2}}$这段时间的瞬时电流$i(t)=2\frac{I</em>{peak}}{t<em>{sc}}t$，在$\frac{t</em>{sc}}{2}{\sim}t<em>{sc}$的这段时间瞬时电流$i(t)=-2\frac{I</em>{peak}}{t<em>{sc}}t$，$V</em>{in}$从低至高电平转换期间的能耗为：</p><script type="math/tex; mode=display">E_{dpr}=\int_{0}^{t_{sc}}i(t)V_{DD}\,dt=2\int_{0}^{\frac{t_{sc}}{2}}i(t)V_{DD}\,dt=4V_{DD}\frac{I_{peak}}{t_{sc}}\int_{0}^{\frac{t_{sc}}{2}}t\,dt=\frac{1}{2}V_{DD}I_{peak}t_{sc}</script><p>同理可得$V_{in}$从高至低电平转换期间的能耗为：</p><script type="math/tex; mode=display">E_{dpf}=\frac{1}{2}V_{DD}I_{peak}t_{sc}</script><p>由此可知电路在过渡区的总能耗为：</p><script type="math/tex; mode=display">E_{dp}=E_{dpr}+E_{dpf}=V_{DD}I_{peak}t_{sc}</script><p>所以$V_{in}$一个周期内的平均功耗为：</p><script type="math/tex; mode=display">P_{dp}=\frac{E_{dp}}{T}=E_{dp}f=V_{DD}I_{peak}t_{sc}f=C_{sc}V_{DD}^2f</script><p>从平均功耗的表达式可以看出过渡区的动态功耗是一个类电容功耗，$C<em>{sc}$为过渡区的等效电容，$t</em>{sc}$为过渡区时长，f为$V_{in}$的电平跳变频率。</p><h2 id="静态功耗"><a href="#静态功耗" class="headerlink" title="静态功耗"></a>静态功耗</h2><p>理想情况下，CMOS反相器在稳态工作时PMOS与NMOS不会同时导通，这就意味着稳态时电源与地之间没有通路，不会形成通路电流，静态功耗为零，可实际电路里总有一些微弱的泄漏电流$I_{stat}$流过源或漏与衬底之间的反偏二极管，如下图所示，此时的静态功耗为：</p><script type="math/tex; mode=display">P_{stat}=V_{DD}I_{stat}</script><p><img src="https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303242223033.png" alt="4"></p><h2 id="总功耗"><a href="#总功耗" class="headerlink" title="总功耗"></a>总功耗</h2><p>显然，CMOS反相器的总功耗可以表示成三个部分的和，即:</p><script type="math/tex; mode=display">P_{total}=P_{dyn}+P_{dp}+P_{stat}=(C_LV_{DD}^2+V_{DD}I_{peak}t_{sc})f+V_{DD}I_{stat}</script><p>最主要的功耗是等效电容的充放电造成的$P<em>{dyn}$，过渡区的功耗$P</em>{dp}$可以通过调整过渡区宽度控制在限定范围内，静态功耗目前可忽略。</p><blockquote><p>Reference</p><p>Jan M. Rabaey, Anantha Chandrakasan, Borivoje Nikolic, 2004. Digital Integrated Circuits :A Design Perspective ,Second Edition.</p></blockquote>]]></content>
    
    
    <summary type="html">简述芯片的低功耗设计</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>FPGA与ASIC的区别</title>
    <link href="http://david-luge.cn/2023/03/24/IC/Basic/FPGA%E4%B8%8EASIC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://david-luge.cn/2023/03/24/IC/Basic/FPGA%E4%B8%8EASIC%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-03-24T03:39:39.000Z</published>
    <updated>2023-03-24T03:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPGA与ASIC的区别"><a href="#FPGA与ASIC的区别" class="headerlink" title="FPGA与ASIC的区别"></a>FPGA与ASIC的区别</h1><ul><li><p><strong>测试逻辑</strong>：ASIC要考虑SCAN测试和BIST的问题；（DFT：Design For Test）</p></li><li><p><strong>存储资源</strong>：一般而言，ASIC设计中使用的memory是SRAM与Flop/Latch Array，前端工程师可以根据不同的存储规模选择合适的类型；而FPGA中memory的种类较多且资源受限，一般有Distributed RAM/Block RAM/Ultra RAM等，FPGA设计者一般会在微架构设计中根据存储规模更细致地考虑好各memory使用的资源类型；</p></li><li><p><strong>计算资源</strong>：ASIC设计的计算资源主要采用<strong>synopsys designware</strong>、其他vendor或者自主设计的IP；而FPGA设计则主要使用片上的<strong>DSP单元</strong>，DSP单元在FPGA上是hardwired，时序比较好，但功能相对也比较固定，所以FPGA设计者一般会充分DSP单元中固定位宽的乘法器与加法器。在ASIC设计中，累加一般采用加法树设计，而FPGA中则更倾向于使用级联设计，这样可以利用DSP单元间专用的进位布线资源，提高设计的时序；</p></li><li><p><strong>逻辑资源</strong>：ASIC设计中的逻辑资源是标准单元库中的logic cell，而FPGA设计中的逻辑资源是CLB中的LUT（4/5/6输入LUT，具体看FPGA型号）与MUX。<strong>这里就体现了ASIC和FPGA一个最大区别</strong>：估算逻辑深度的方法不同：FPGA没有逻辑深度，就是一个查找表，查找表的深度仅和输入信号的数目有关；而ASIC是有逻辑深度的，在RTL Coding的时候，需要预估逻辑综合出来的级数，哪怕输入信号不多，但逻辑复杂度大的话，也需要拆成2拍；</p></li><li><p><strong>低功耗设计</strong>：ASIC的低功耗设计可以采用clock gating与power gating，但FPGA无法做到power gating，clock信号在FPGA中有专用的布线资源，因此也不建议使用clock gating的方式，但可以用clock enable的方式替代；</p></li><li><p><strong>时钟复位</strong>：clock信号在FPGA中有专用的布线资源，而ASIC内的时钟为了更小的skew会专门进行CTS；ASIC设计中一般使用异步复位，由后端负责处理复位树，FPGA设计中则建议使用同步复位；</p></li></ul><h2 id="FPGA与ASIC在代码层面的区别"><a href="#FPGA与ASIC在代码层面的区别" class="headerlink" title="FPGA与ASIC在代码层面的区别"></a>FPGA与ASIC在代码层面的区别</h2><ul><li><p>ASIC更趋于保守，对逻辑的任何改动都要三思，并要做备选的选择，以防改错，RTL的任何修改几乎都是增量修改；</p></li><li><p>ASIC对coding style的要求更高，所有模块的coding风格要求一致，这样有利于后端以及后续的check；</p></li><li><p>ASIC要考虑SCAN测试和BIST的问题，所以设计的时候需要为SRAM做BIST插入，需要为SCAN预留接口；虽然大部分都是工具干的，但是RTL作者也需要手动做一些顶层工作，比如SCAN时钟的来源等逻辑；</p></li><li><p>ASIC时序预见性更好，可调整度高，所以可以写很大的逻辑；</p><p><strong>关键词：保守改动、代码风格、测试逻辑、逻辑级数</strong></p></li></ul>]]></content>
    
    
    <summary type="html">简述芯片与FPGA的区别</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>芯片设计流程简述</title>
    <link href="http://david-luge.cn/2023/03/24/IC/Basic/%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
    <id>http://david-luge.cn/2023/03/24/IC/Basic/%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</id>
    <published>2023-03-24T03:38:39.000Z</published>
    <updated>2023-03-24T03:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="芯片设计流程简述"><a href="#芯片设计流程简述" class="headerlink" title="芯片设计流程简述"></a>芯片设计流程简述</h1><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>分析用户或市场的需求，并将其翻译成对芯片产品的技术要求；</p><h3 id="2、算法-架构设计"><a href="#2、算法-架构设计" class="headerlink" title="2、算法/架构设计"></a>2、算法/架构设计</h3><ul><li>算法设计：设计和优化芯片中所使用的算法；这一阶段一般使用高级编程语言(如C、C++)，利用算法级建模和仿真工具(如MATLAB)进行浮点和定点的仿真，进而对算法进行评估和优化；</li><li>架构设计：根据设计的功能需求和算法分析的结果，设计芯片的架构，并对不同的方案进行比较，选择性能价格最优的方案。这一阶段可以用SystemC语言对芯片架构进行模拟和分析；</li></ul><h3 id="3、RTL设计"><a href="#3、RTL设计" class="headerlink" title="3、RTL设计"></a>3、RTL设计</h3><p>使用HDL语言(Verilog、VHDL)完成对设计实体的RTL级描述。</p><h3 id="4、RTL验证-功能仿真-前仿"><a href="#4、RTL验证-功能仿真-前仿" class="headerlink" title="4、RTL验证(功能仿真/前仿)"></a>4、RTL验证(功能仿真/前仿)</h3><p>使用仿真工具或者其他RTL代码分析工具，验证RTL代码的质量和性能；</p><h3 id="5、综合"><a href="#5、综合" class="headerlink" title="5、综合"></a>5、综合</h3><p>从RTL代码生成描述实际电路的门级网表文件；</p><h3 id="6、门级验证-后仿"><a href="#6、门级验证-后仿" class="headerlink" title="6、门级验证(后仿)"></a>6、门级验证(后仿)</h3><p>对综合产生的门级网表进行验证，这一阶段通常会使用仿真、静态时序分析和形式验证等工具；</p><h3 id="7、布局布线"><a href="#7、布局布线" class="headerlink" title="7、布局布线"></a>7、布局布线</h3><p>后端对综合产生的门级网表进行布局规划(FloorPlanning)、布局(Placement)、布线(Routing)，生成生产用的版图；</p><h3 id="8、电路参数提取"><a href="#8、电路参数提取" class="headerlink" title="8、电路参数提取"></a>8、电路参数提取</h3><p>确定芯片中互连线的寄生参数，从而获得门级的延时信息；用于更准确地后仿以及静态时序分析；</p><h3 id="9、版图后验证"><a href="#9、版图后验证" class="headerlink" title="9、版图后验证"></a>9、版图后验证</h3><p>根据后端设计后取得的新的延时信息，再次验证设计能否可以实现所有的功能、是否达到所有的性能指标；</p><h3 id="10、芯片生产"><a href="#10、芯片生产" class="headerlink" title="10、芯片生产"></a>10、芯片生产</h3><p>在特定的芯片工艺线上制造出芯片；</p><h3 id="11、芯片测试"><a href="#11、芯片测试" class="headerlink" title="11、芯片测试"></a>11、芯片测试</h3><p>对制造好的芯片进行测试，检测生产中产生的缺陷和问题；</p>]]></content>
    
    
    <summary type="html">简述芯片的设计流程</summary>
    
    
    
    <category term="IC" scheme="http://david-luge.cn/categories/IC/"/>
    
    <category term="Basics" scheme="http://david-luge.cn/categories/IC/Basics/"/>
    
    
    <category term="Basics" scheme="http://david-luge.cn/tags/Basics/"/>
    
  </entry>
  
</feed>
