[{"title":"金刚经说什么","url":"/2025/03/28/Reading/金刚经说什么-阅读笔记/","content":"\n## 悟《金刚经》智慧：空、无所住与人生修行\n\n“一切有为法，如梦幻泡影，如露亦如电，应作如是观。”《金刚经》作为佛教的璀璨明珠，短短五千余言，却蕴含着穿透时空的深邃智慧，引领无数修行者探寻生命的真谛与宇宙的实相。\n\n### 一、“空”与“无所住”：洞悉本质，解脱心灵\n\n#### （一）含义\n\n1. “空”：“空”并非是绝对的虚无，宛如镜花水月，看似存在却无永恒不变的实体。它揭示了世间万物皆为因缘和合而生的本质。就像苏轼笔下“**人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。**”人生的境遇、世间的万事万物，皆是各种条件的短暂聚合。以王朝的兴衰为例，曾经辉煌无比的大秦帝国，凭借着商鞅变法、强大的军事力量等因缘而崛起，统一六国，盛极一时。然而，随着严苛的律法、繁重的劳役等条件的变化，仅仅二世便土崩瓦解，消逝在历史的长河中。这深刻地表明，事物的本质是“空”，其存在依赖于诸多条件，条件一旦改变，事物也随之变迁、消逝 。“空”是对事物本质的深度洞察，它告诫我们，莫要执着于事物的表面繁华与短暂存在，因为一切皆在无常变化之中。\n\n2. “无所住”：“无所住”侧重于心灵的状态，要求心不被任何特定的对象、观念或境界所束缚，恰似行云流水，自在洒脱。古代的颜回，“一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。”他不执着于物质的匮乏，不被外界的艰难困苦所影响，内心始终保持着安宁与自在。当我们面对他人的赞美时，若能不让心沉浸在喜悦与骄傲之中；遭遇困难时，不被恐惧和焦虑所左右，便是在践行“无所住”。“无所住”是修行的方法与境界，唯有不断放下执着，心灵才能达到自在、空灵的境地。\n\n#### （二）关系\n\n“空”与“无所住”相互依存，犹如鸟之双翼、车之两轮。“空”的理念为“无所住”筑牢了理论根基。当我们深刻认识到事物的“空”性，明白一切执着皆无意义，自然会努力追求“无所住”的境界。同时，“无所住”也是践行“空”的有效方式，通过心灵的不执着，我们能更深刻地体悟事物的“空”性。就像禅宗六祖慧能大师听闻《金刚经》中“应无所住而生其心”而开悟，正是在“无所住”的修行中，深刻领悟了“空”的真谛。\n\n#### （三）区别\n\n1. 侧重点不同：“空”从对事物本质的认知出发，向我们揭示了世间万物的虚幻性与无常性，引导我们透过现象看本质。而“无所住”侧重于心灵的修行状态，强调心要挣脱外界事物的羁绊，保持内心的自由与清明。\n\n2. 范畴不同：“空”是一种宏大的哲学概念，涵盖了对整个宇宙万物本质的深刻认知，是对世界实相的根本洞察。“无所住”更多地属于修行实践的范畴，是对修行者心态和行为的具体要求，指导着我们在日常生活中的一举一动、一念一想。\n\n### 二、“善护念”：守护内心，净化灵魂\n\n在《金刚经》中，“善护念”同样是至关重要的概念，即悉心守护自己的念头。从修行的角度而言，“善护念”要求我们时刻觉察内心的起心动念，防止贪、嗔、痴、慢、疑等不善的念头滋生，一旦这些念头出现，要能及时察觉并转化。\n《红楼梦》中的王熙凤，便是被贪念和嗔念所左右。她贪图钱财，弄权铁槛寺，收受贿赂，为达目的不择手段；对待下人严苛凶狠，嗔怒无常。最终机关算尽太聪明，反误了卿卿性命，陷入无尽的痛苦与烦恼之中。相反，弘一法师在修行过程中，时刻关照自己的内心，以慈悲为怀，善护念每一个念头，将贪嗔痴等杂念转化为修行的动力，最终达到了极高的精神境界。通过“善护念”，修行者能够让内心保持清净、平和，逐渐培育出慈悲、智慧等善念，从而在修行之路上稳步前行，领悟佛法的深奥真谛。\n\n### 三、“无我相，无人相，无众生相，无寿者相”：超脱维度，升华境界\n\n“无我相，无人相，无众生相，无寿者相”，这是《金刚经》中又一深邃的智慧。若从理科生的角度形象理解，将自我、他人、众人视为不同的坐标轴，寿者看作时间，当我们能够摆脱这些维度的束缚，超脱空间与时间的限制，便能趋近于佛的境界。这与“无所住”以及心性修炼的理念一脉相承，启迪我们从更为宏观的视角去思索生命与修行，打破固有的认知局限。就像庄子在《逍遥游》中所描述的“至人无己，神人无功，圣人无名”，达到一种超越自我、超越世俗功利的境界，与《金刚经》所传达的超脱与智慧相呼应。\n\n书读到一半读不下去了，如文中所言，作为一个理科生难以理解大师所举的佛法例子，只能说取其精华吧：\n\n- 活在当下，积极应对每一件事，摒弃偏见；\n- 一心向善，不必忧虑前程；\n- “物来顺应，过往不恋，当下不杂，未来不迎”：不沉湎于过去，不被当下的繁杂所扰，不必对于未来的事情过于担忧或期待；\n- 在这无常的世间，以一颗平和、自在、超脱的心，去感悟生命的美好与真谛。","tags":["Reading"],"categories":["Reading"]},{"title":"线性代数16-投影矩阵与最小二乘","url":"/2025/03/28/Linear_Algebra/线性代数-16/","content":"\n# Linear Algebra-投影矩阵与最小二乘-16\n\n## 一、知识概要\n\n本节聚焦于最小二乘法，深入探究上一节提及的投影概念。实际上，最小二乘法本质就是一种投影，其目的是使误差达到最小。同时，本节还涉及矩阵列空间与左零空间的相关知识，向量的投影就是在列空间中寻找距离最近的点，这与最小二乘法紧密相连。此外，还引出了标准正交向量组的概念。\n\n## 二、投影矩阵回顾\n\n上一节介绍了投影矩阵$$P$$，其公式为：\n\n$$\nP = A(A^TA)^{-1}A^T\n$$\n\n在推导该公式时，$$A = [a_1\\ a_2]$$，其中$$a_1$$、$$a_2$$是平面上的两个基，$$A$$的列空间就是整个$$R^2$$空间 。\n\n投影矩阵$$P$$与向量$$b$$的乘积，可以理解为将$$b$$向量投影到它在列空间中的最近一点上。这和上节课将向量$$p$$投影到平面上的过程类似。基于此，有以下两个问题：\n\n1. 若$$b$$在矩阵$$A$$的列空间里，则$$Pb =?$$：此时$$Pb = b$$。因为$$b$$本身就在$$A$$的列空间中，就如同上节课中向量$$b$$就在平面上，投影就是其本身。\n\n   - **证明过程**：\n     - 由于$$b$$在$$A$$的列空间里，所以一定可以写成$$Ax = b$$的形式。\n     - 将其代入投影矩阵可得：$$A(A^TA)^{-1}A^TAx$$，根据矩阵乘法结合律，$$A(A^TA)^{-1}A^TAx = (A(A^TA)^{-1}A^T)Ax$$，而$$A(A^TA)^{-1}A^T = P$$，所以$$A(A^TA)^{-1}A^TAx = PAx$$，又因为$$Ax = b$$，所以$$PAx = Pb = b$$ 。\n2. 若$$b$$垂直于$$A$$的列空间，则$$Pb =?$$：此时$$Pb = 0$$，即没有投影。例如上节课中向量与平面垂直穿过的情况，此时向量$$b$$在平面上没有分量，投影为 $$0$$。\n\n   - **证明过程**：\n     - 因为$$b$$垂直于$$A$$的列空间，所以$$b$$垂直于$$A$$的所有列向量，那么$$b$$在左零空间中。\n     - 代入投影矩阵$$A(A^TA)^{-1}A^Tb$$，由于$$b$$在左零空间，所以$$A^Tb = 0$$，则$$A(A^TA)^{-1}A^Tb = A(A^TA)^{-1}×0 = 0$$ 。\n\n通过这两个问题可知，一个向量$$b$$总有两个分量，一个在$$A$$的列空间中，另一个垂直于$$A$$的列空间。投影矩阵的作用就是保留列空间中的分量，去除垂直于列空间的分量。可以用公式$$b = p + e$$表示这种关系，其中$$p$$是投影矩阵作用于$$b$$上得到的向量，$$e$$是左零空间中的分量。如果用类似投影矩阵表示，有$$p = Pb$$，$$e = b - p = b - Pb = (I - P)b$$，这里可以把$$(I - P)$$也看作一个投影矩阵，它将向量$$b$$投影到左零空间中。\n\n![Linear_Algebra160](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra160.png)\n\n## 三、最小二乘法\n\n### 3.1 最小二乘解题\n\n【例】继续探讨上节课的例子，求解过三个点$$(1,1)$$、$$(2,2)$$、$$(3,2)$$拟合的直线方程。\n\n1. **列出方程**：假设最优直线方程为$$y = C + Dx$$，将三个点代入可得方程组：\n\n$$\n\\begin{cases}C + D = 1 \\\\ C + 2D = 2 \\\\ C + 3D = 2\\end{cases}\n$$\n\n将其转化为矩阵方程$$Ax = b$$的形式为：\n\n$$\n\\begin{bmatrix}1 & 1 \\\\ 1 & 2 \\\\ 1 & 3\\end{bmatrix}\\begin{bmatrix}C \\\\ D\\end{bmatrix}=\\begin{bmatrix}1 \\\\ 2 \\\\ 2\\end{bmatrix}\n$$\n\n很明显，这三个点不共线，该方程无解。\n\n1. **计算误差并拟合**：由于三点不共线，先计算直线与各点之间的误差（偏移量），用$$|Ax - b|$$表示。为便于计算，研究它们的平方和$$|e|^2 = |Ax - b|^2$$ 。从几何意义上讲，这个过程本质是将向量$$b$$投影到$$A$$的列空间中，也就是将三个点投影到满足方程条件的最近的一条直线上。\n\n使用上节课介绍的方程$$A^Tb = A^TA\\hat{x}$$来拟合直线。在这个例子中，$$A=\\begin{bmatrix}1 & 1 \\\\ 1 & 2 \\\\ 1 & 3\\end{bmatrix}$$，$$\\hat{x}=\\begin{bmatrix}\\hat{C} \\\\ \\hat{D}\\end{bmatrix}$$，$$b=\\begin{bmatrix}1 \\\\ 2 \\\\ 2\\end{bmatrix}$$，代入方程求解：\n\n$$\nA^TA=\\begin{bmatrix}1 & 1 & 1 \\\\ 1 & 2 & 3\\end{bmatrix}\\begin{bmatrix}1 & 1 \\\\ 1 & 2 \\\\ 1 & 3\\end{bmatrix}=\\begin{bmatrix}3 & 6 \\\\ 6 & 14\\end{bmatrix}\\\\\nA^Tb=\\begin{bmatrix}1 & 1 & 1 \\\\ 1 & 2 & 3\\end{bmatrix}\\begin{bmatrix}1 \\\\ 2 \\\\ 2\\end{bmatrix}=\\begin{bmatrix}5 \\\\ 11\\end{bmatrix}\n$$\n\n则方程$$A^TA\\hat{x} = A^Tb$$变为$$\\begin{bmatrix}3 & 6 \\\\ 6 & 14\\end{bmatrix}\\begin{bmatrix}\\hat{C} \\\\ \\hat{D}\\end{bmatrix}=\\begin{bmatrix}5 \\\\ 11\\end{bmatrix}$$，求解可得：\n\n$$\n\\hat{C}=\\frac{2}{3}，\\hat{D}=\\frac{1}{2}\n$$\n\n所以得到的直线方程为$$y=\\hat{C}+\\hat{D}x=\\frac{2}{3}+\\frac{1}{2}x$$ 。\n\n1. **检验**：分别将$$(1,1)$$、$$(2,2)$$、$$(3,2)$$三个点的横坐标代入拟合直线方程，可以得到拟合直线上各点对应的位置，即$$p$$的位置。需要注意的是，以上能使用最小二乘法是因为没有误差过大的量。\n\n### 3.2 性质讨论\n\n上述问题也可以通过使误差最小来计算。将误差化为$$\\left|e_{1}\\right|^{2}+\\left|e_{2}\\right|^{2}+\\left|e_{3}\\right|^{2}=(C + D - 1)^{2}+(C + 2D - 2)^{2}+(C + 3D - 2)^{2}$$，从导数的角度，对$$C$$和$$D$$求偏导并求极值，也能求得拟合直线。\n\n![Linear_Algebra161](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra161.png)\n\n将误差向量记为$$e$$，对应的投影向量记为$$p$$（对应拟合直线上的$$y$$值），有$$b = p + e$$（$$b$$为给定的点的实际$$y$$值）。在本题中，$$b=\\begin{bmatrix}1 \\\\ 2 \\\\ 2\\end{bmatrix}$$，$$p=\\begin{bmatrix}\\frac{7}{6} \\\\ \\frac{10}{6} \\\\ \\frac{13}{6}\\end{bmatrix}$$，$$e=\\begin{bmatrix}-\\frac{1}{6} \\\\ \\frac{2}{6} \\\\ -\\frac{1}{6}\\end{bmatrix}$$ 。由此可得到以下性质：\n\n1. 误差向量$$e$$与投影向量$$p$$垂直，即$$e\\cdot p = 0$$。\n2. 误差向量$$e$$不仅垂直于$$p$$，还垂直于列空间中的每一个向量。这些性质进一步验证了前文关于投影的相关介绍。\n\n### 3.3 结论证明\n\n在解方程过程中，用到了“如果矩阵$$A$$各列线性无关，则矩阵$$A^TA$$可逆”这一结论，之前未给出证明，下面进行证明：\n\n1. 写出零空间方程形式$$A^TAx = 0$$，目的是寻找零空间内的向量$$x$$ 。\n2. 引入之前学过的结论：\n\n   - 如果矩阵可逆，那么其对应的零空间仅包含零向量。\n   - 对于列向量$$x$$，$$x^Tx$$表示求$$x$$的长度。\n   - 若$$x^Tx = 0$$，则$$x = 0$$（$$x$$是列向量） 。\n3. 证明过程：\n\n   - 将方程$$A^TAx = 0$$两边同时左乘$$x^T$$，得到$$x^TA^TAx = 0$$。\n   - 根据矩阵乘法的性质$$(AB)^T = B^TA^T$$，则$$x^TA^TAx = (Ax)^TAx = 0$$。\n   - 因为向量的内积$$(Ax)^TAx = 0$$，且向量的内积为 $$0$$ 时，该向量为零向量，所以可推得$$Ax = 0$$。\n   - 又因为已知矩阵$$A$$各列线性无关，根据线性无关的定义，若$$Ax = 0$$，则$$x$$必为零向量。\n   - 综上，证得$$A^TA$$的零空间只有零向量，根据矩阵可逆的判定条件，若矩阵的零空间只有零向量，则该矩阵可逆，所以$$A^TA$$可逆。即证明了如果矩阵$$A$$各列线性无关，则矩阵$$A^TA$$可逆。\n\n## 四、标准正交基\n\n这部分内容主要是为下节课做铺垫，相对较少，简单了解即可。\n\n之前接触过的向量组$$\\begin{bmatrix}1 \\\\ 0 \\\\ 0\\end{bmatrix}$$，$$\\begin{bmatrix}0 \\\\ 0 \\\\ 1\\end{bmatrix}$$，$$\\begin{bmatrix}0 \\\\ 1 \\\\ 0\\end{bmatrix}$$，它们是正交的，并且还有特殊性质——都是单位向量，长度为 $$1$$。基于此，引入“标准正交向量组”的概念，其中“标准”表示向量是单位向量。\n\n同样属于标准正交向量组的还有$$\\begin{bmatrix}\\cos\\theta \\\\ \\sin\\theta\\end{bmatrix}$$，$$\\begin{bmatrix}-\\sin\\theta \\\\ \\cos\\theta\\end{bmatrix}$$。\n\n## 五、学习感悟\n\n本节内容相互关联性强，最小二乘法与投影矩阵之间联系紧密，可以从多种角度进行理解。在学习过程中，记住将向量投影到列空间与左零空间的示意图非常重要，它有助于更牢固地掌握这部分知识。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数15-子空间投影","url":"/2025/03/28/Linear_Algebra/线性代数-15/","content":"\n# Linear Algebra-子空间投影-15\n\n## 一、知识概要\n\n本节重点聚焦于投影相关知识，从向量投影出发，逐步拓展至高维投影，并以矩阵形式呈现投影。上一节介绍的正交概念在本节中有着重要应用，做投影本质上就是向另一个向量作垂线。通过本节学习，能深化对正交概念以及空间投影概念的理解。\n\n## 二、投影\n\n### 2.1 简单的投影\n\n先来看简单投影的情况，如在下图中，向量$$p$$是向量$$b$$在向量$$a$$上的投影，可表示为$$p = xa$$（$$x$$为倍数） ，向量$$b$$与投影$$p$$的差值为$$b-p$$。\n\n![Linear_Algebra150](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra150.png)\n\n由向量$$a$$与$$e = b - p$$的垂直关系，结合上节正交概念，根据向量垂直时其点积为 $$0$$，可得：\n\n$$\na^{T} e = a^{T}(b - p) = a^{T}(b - ax) = 0\n$$\n\n求解上述关于$$x$$的方程：\n\n$$\na^{T}(b - ax) = 0\\xrightarrow{}\na^{T}b - a^{T}ax = 0\\xrightarrow{}\na^{T}ax = a^{T}b\\xrightarrow{}\nx = \\frac{a^{T}b}{a^{T}a}\n$$\n\n将$$x$$代入$$p = xa$$，可得到：\n\n$$\np = a\\frac{a^{T}b}{a^{T}a}\n$$\n\n从$$p$$的表达式可以看出，投影是通过前面的系数（矩阵形式）来实现的，这个系数矩阵被称为投影矩阵，即$$p = Pb$$（$$P$$是投影矩阵，作用于$$b$$向量上）。由此可得投影矩阵$$P = a\\frac{a^{T}}{a^{T}a}$$，该矩阵生成了投影$$p$$。\n\n需要注意的是，当$$a$$是列向量时，$$aa^{T}$$是一个矩阵，$$a^{T}a$$是一个具体数字。在图一这种情况下，矩阵$$P$$的秩为 $$1$$ 且对称。这一结论可以通过具体计算或上一节末尾的相关结论得出。\n\n投影矩阵$$P$$具有两条重要性质：\n\n1. **对称性**：$$P^{T} = P$$。因为$$P = a\\frac{a^{T}}{a^{T}a}$$，分母$$a^{T}a$$是数字，分子$$a a^{T}$$转置后形式不变，所以$$P$$是对称矩阵 。\n2. **幂等性**：$$P^{2} = P$$。从投影意义来看，如果对向量投影两次，其结果与只投影一次是一样的，所以投影矩阵$$P$$满足$$P^{2} = P$$。这两条性质是后续扩展投影概念的重要基础。\n\n### 2.2 平面上的投影\n\n在了解向量之间的投影后，进一步探讨向量与平面之间的投影。在下图中，$$a_1$$，$$a_2$$为构成平面的一组基，向量$$p$$在该平面上，则$$p$$可以表示为$$p=\\widehat{x_{1}} a_{1}+\\widehat{x_{2}} a_{2}$$，也可写为$$p = A\\hat{x}$$，其中$$A = [a_1\\ a_2]$$（$$a_n$$都是列向量），$$\\hat{x} = \\begin{bmatrix}\\widehat{x_{1}}\\\\\\widehat{x_{2}}\\end{bmatrix}$$。\n\n![Linear_Algebra151](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra151.png)\n\n类比向量投影的思路，由于$$a_1$$，$$a_2$$都与$$b - p$$向量垂直，将$$p = Ax$$代入垂直关系可得：\n\n$$\na_{1}^{T}(b - A\\hat{x}) = 0\n$$\n\n$$\na_{2}^{T}(b - A\\hat{x}) = 0\n$$\n\n将上述两个式子合写成矩阵形式为：\n\n$$\\begin{bmatrix}a_{1}^{T}\\\\a_{2}^{T}\\end{bmatrix}(b - A\\hat{x}) = \\begin{bmatrix}0\\\\0\\end{bmatrix}$$，即$$A^{T}(b - A\\hat{x}) = 0$$\n\n可以发现，该式与前面向量投影时得到的式子形式相似，实际上向量投影的式子是$$A$$只有一列时的特殊情况。在$$A^{T}(b - A\\hat{x}) = 0$$这个式子中，$$b - A\\hat{x}$$（即垂直的$$e$$向量）在$$A^{T}$$的零空间里。根据上节课所学，零空间与行空间正交，所以$$e$$向量与$$A^{T}$$的行向量正交，进而与$$A$$的列向量$$a_1$$，$$a_2$$正交，这在图中是显然成立的。\n\n接下来求平面上的投影矩阵$$P$$。由$$A^{T}(b - A\\hat{x}) = 0$$，先化简得到$$A^{T}b = A^{T}A\\hat{x}$$。这里需要注意，因为$$A^{T}$$不一定是方阵，所以不能直接在两边左乘$$(A^{T})^{-1}$$。但由于$$A$$是由两个线性无关的基向量构成的矩阵，根据上节知识可知$$A^{T}A$$是可逆的，因此在两边同时左乘$$(A^{T}A)^{-1}$$来解方程：\n\n$$\nA^{T}A\\hat{x} = A^{T}b\\xrightarrow{}\n\\hat{x} = (A^{T}A)^{-1}A^{T}b\n$$\n\n将$$\\hat{x} = (A^{T}A)^{-1}A^{T}b$$代入$$p = A\\hat{x}$$，可得：\n\n$$\np = A(A^{T}A)^{-1}A^{T}b\n$$\n\n由此得到投影矩阵$$P$$的表达式为：\n\n$$\nP = A(A^{T}A)^{-1}A^{T}\n$$\n\n这是投影矩阵$$P$$的一般情况，而前面计算的$$P = a\\frac{a^{T}}{a^{T}a}$$是投影矩阵的一维特殊情况。同样，$$P = A(A^{T}A)^{-1}A^{T}$$也具有$$P^{T} = P$$和$$P^{2} = P$$这两个性质，其证明过程与一维情况类似，在此不再详述，读者可以自行验证。\n\n## 三、最小二乘法初涉\n\n前面学习的投影知识有着重要的实际应用，其中投影中的$$e = b - p$$可以看作向量$$b$$与向量$$a$$（或向量$$b$$与平面）之间偏移量的大小，这为使用最小二乘法拟合直线提供了便利。\n\n【例】求解过三个点$$(1,1)$$，$$(2,2)$$，$$(3,2)$$拟合的直线方程。\n\n1. **列出方程**：假设最优直线方程为$$b = C + Dt$$，将三个点代入方程可得：\n\n$$\nC + D = 1\n$$\n\n$$\nC + 2D = 2\n$$\n\n$$\nC + 3D = 2\n$$\n\n1. **转化为矩阵方程并求解**：将上述方程列成矩阵方程$$Ax = b$$，发现该方程无解。此时运用投影中讲到的方法，将方程化为$$A^{T}b = A^{T}A\\hat{x}$$来求解。这种方法的关键在于，原本无解的方程$$Ax = b$$，经过处理后得到的$$A^{T}A\\hat{x} = A^{T}b$$可以求出最优解，从而实现将无解的方程转换为可求解的最优方程。最小二乘法在后续课程中还会详细讲解。\n\n## 四、学习感悟\n\n本节内容是上一节正交知识的延伸。借助正交概念计算投影，并利用投影与向量之间的偏差引入最小二乘法，从而解决方程$$Ax = b$$无解时的最优解问题，实现直线拟合。这部分内容实际应用性较强，核心目的是求解$$A^{T}A\\hat{x} = A^{T}b$$，以获得最优解。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数14-正交向量与子空间","url":"/2025/03/28/Linear_Algebra/线性代数-14/","content":"\n# Linear Algebra-正交向量与子空间-14\n\n## 一、知识概要\n\n本节开启新的研究篇章，聚焦于之前提及的子空间，不过研究视角转向正交方向，重点探讨子空间的相关性质以及正交向量的特性等内容。这些核心要点集中呈现在下表中。\n\n| 子空间              | 维数      | 与矩阵关系                                |\n| ------------------- | --------- | ----------------------------------------- |\n| 列空间 $$C(A)$$     | $$r$$     | 由矩阵 $$A$$ 的列向量生成的空间           |\n| 行空间 $$C(A^T)$$   | $$r$$     | 由矩阵 $$A$$ 的行向量转置后生成的空间     |\n| 零空间 $$N(A)$$     | $$n - r$$ | 满足 $$Ax = 0$$ 的所有解向量构成的空间    |\n| 左零空间 $$N(A^T)$$ | $$m - r$$ | 满足 $$A^T y = 0$$ 的所有解向量构成的空间 |\n\n\n## 二、正交向量与子空间\n\n### 2.1 基本正交概念\n\n在探讨正交向量之前，先明确正交的定义：在线性代数范畴内，正交等同于垂直，无论是向量正交还是空间正交，都可按垂直的概念来理解。\n\n1. **向量正交**：观察向量 $$x$$ 和 $$y$$，从垂直关系可直观得出 $$x^t y = 0$$。这一结论也能通过勾股定理推导得出：\n   - 根据勾股定理，有 $$|x|^2 + |y|^2 = |x + y|^2$$ 。\n   - 用向量形式表示为 $$x^t x + y^t y = (x + y)^t(x + y)$$ 。\n   - 对等式右边展开化简：\n\n$$\n(x + y)^t(x + y)=(x^t + y^t)(x + y)=x^t x + x^t y + y^t x + y^t\n$$\n\n从而得到 $$x^t y + y^t x = 0$$ 。\n\n- 由于 $$x^t y$$ 与 $$y^t x$$ 本质相同，均表示两个一维向量的点乘，所以进一步化简可得 $$2x^t y = 0$$ ，即两个向量正交时， $$x^t y = 0$$。\n\n- 特别地，若两个向量中一个是零向量，根据上述结论，这两个向量一定正交。\n\n1. **空间正交**：两个空间正交的定义为，**一个空间中的任意向量，都与另一个空间中的任意向量正交**。例如，黑板所在平面和地面所在平面的子空间并不正交，因为它们存在交线，交线上的非零向量不满足空间正交的定义。这表明，**若两个平面在某一非零向量处相交，那么这两个平面一定不正交**。\n2. $$R^2$$**子空间的正交情况**：在 $$R^2$$ 中，平面上的子空间有三种类型，分别是整个平面 $$D$$ 、过原点的直线 $$L$$ 以及原点 $$O$$ 。\n\n   - $$L$$ 与 $$D$$ 的正交情况：在一个平面内，直线不可能始终与该平面垂直。\n   - $$L$$与 $$O$$ 的正交情况：$$L$$ 与 $$O$$ 永远正交。\n   - $$L$$与另一个 $$L$$的正交情况：根据正交定义，只有当两条直线在原点处互相垂直时，这两个 $$L$$ 空间才正交。\n\n### 2.2 零空间与行空间的正交关系\n\n零空间与行空间存在正交关系，这种关系就如同将一个空间一分为二，得到的两个子空间相互正交。\n\n1. **证明正交关系**：将矩阵 $$A$$ 写成行向量形式，对于方程 $$Ax = 0$$ ，即：\n\n$$\n\\begin{bmatrix}\nR_1 \\\\\nR_2 \\\\\n\\vdots \\\\\nR_m\n\\end{bmatrix}\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nR_1(x_1, x_2, \\cdots) \\\\\nR_2(x_1, x_2, \\cdots) \\\\\n\\vdots \\\\\nR_m(x_1, x_2, \\cdots)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\n0 \\\\\n\\vdots \\\\\n0\n\\end{bmatrix}\n$$\n\n可以发现，$$A$$ 的每一行 $$R_x$$ 与向量 $$x$$ 的列相乘结果都为 0 。其中，$$x$$ 代表零空间中的任意向量，而 $$A$$ 的每一行的线性组合构成了$$A$$的行空间，这完全符合正交子空间的定义，所以零空间与行空间是正交的。\n\n1. **维数关系及示例**：行空间与零空间的维数之和恰好为 $$n$$ 。以矩阵 $$A = \\begin{bmatrix}1 & 2 & 5 \\\\ 2 & 4 & 10\\end{bmatrix}$$ 为例，$$Ax = 0$$ 可表示为：\n\n$$\n\\begin{bmatrix}1 & 2 & 5 \\\\ 2 & 4 & 10\\end{bmatrix}\n\\begin{bmatrix}x_1 \\\\ x_2 \\\\ x_3\\end{bmatrix}\n=\n\\begin{bmatrix}0 \\\\ 0 \\\\ 0\\end{bmatrix}\n$$\n\n在此例中，$$A$$ 的行空间是一维的，通过计算可得其零空间是二维的（$$3 - 1 = 2$$），可以理解为垂直于向量 $$(1, 2, 5)$$ 的一个平面。行空间与零空间的向量都是三维的，它们都是 $$R^3$$ 的子空间，这充分验证了零空间与行空间维数之和等于空间 $$R^n$$ 的维数这一性质，也解释了二者类似于将一个空间一分为二得到两个正交子空间的关系，这种关系被称为 $$R^n$$ 空间的正交补。\n\n### 2.3 无解方程的最优解\n\n在实际应用中，矩阵的数据常来源于测量，难免存在测量不准确的情况。例如求解 $$Ax = b$$ 方程时，如果 $$A$$ 的列数较多，其中可能混入不准确数据，导致无法用常规方法求出准确解。此时，需要寻找方程的最优解，方法是将方程改写为 $$A^T A \\hat{x} = A^T b$$ ，求解得到的 $$\\hat{x}$$ 即为最优解（注意，$$\\hat{x}$$ 并非 $$Ax = b$$ 的解）。\n\n1. $$A^T A$$矩阵的性质：\n\n   - **方阵性质**：设 $$A$$ 为 $$m×n$$ 矩阵，则 $$A^T A$$ 为 $$n×n$$ 型的矩阵 ，即 $$A^T A$$ 的结果总是方阵。\n   - **对称性质**：因为 $$(A^T A)^T = A^T A$$ ，所以 $$A^T A$$ 总是对称阵。\n2. $A^T A$的可逆性判断：$$A^T A$$ 矩阵不一定总是可逆的。当 $$A$$ 矩阵列向量线性相关时，$$A^T A$$ 就不可逆。\n   证明：假设$$A$$ 矩阵列向量线性相关，且$$A^T A$$可逆，则存在非零向量$$x$$，使得$$A^T Ax=0$$。\n   $$\n   ^T Ax=0\\xrightarrow{左乘x^T}x^T A^T Ax=0\\xrightarrow{}||Ax||=0\\xrightarrow{A列向量线性相关}x=0\n   $$\n   \n   与$$x\\neq 0$$矛盾，因此当 $$A$$ 矩阵列向量线性相关时，$$A^T A$$ 就不可逆。\n   判断 $$A^T A$$ 是否可逆有以下两个基本结论：\n   \n   - $$N(A^T A) = N(A)$$ ，即 $$A^T A$$ 与 $$A$$ 的零空间相同。\n   - $$A^T A$$ 与 $$A$$ 的秩相同。\n\n由上述结论可知，$$A^T A$$ 可逆意味着其零空间中只有零向量，即 $$A$$ 的各列线性无关。所以在求最优解时，需要先判断 $$A$$ 的列向量是否线性无关，再进行求解。\n\n## 三、学习感悟\n\n本节围绕正交概念展开深入学习，从向量正交逐步延伸到空间正交，进而揭示了零空间与行空间之间的正交关系。最后探讨并引入了解决 $$Ax = b$$ 无解情况的方法，这部分内容是本章的核心要点。空间之间的正交关系在开篇的表中已有所体现，理解正交与子空间的概念是后续深入学习核心内容——求解 $$A^T A \\hat{x} = A^T b$$ 的重要基础。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数13-复习","url":"/2025/03/28/Linear_Algebra/线性代数-13/","content":"\n# Linear Algebra-复习-13\n\n## 一、知识概要\n\n本节为习题课，主要目的是回顾之前所学内容，帮助学习者掌握经典题型的解法，巩固线性代数的基础知识。\n\n## 二、例题\n\n### 【例 1】\n\n设$$u$$，$$v$$，$$w$$是$$R^{7}$$空间内的非零向量，由它们生成了一个属于$$R^{7}$$的向量子空间，求此空间的维数。\n\n**答案**：三个向量生成的空间，维数可能是 0、1、2、3。由于题设中向量为非零向量，所以维数不可能是 0，最终答案为 1、2、3。\n\n**解析**：向量组生成的子空间维数等于向量组的极大线性无关组所含向量的个数。在本题中，三个非零向量可能线性相关，也可能线性无关。若三个向量线性相关，极大线性无关组可能含 1 个或 2 个向量，此时子空间维数为 1 或 2；若三个向量线性无关，极大线性无关组含 3 个向量，子空间维数为 3 。\n\n### 【例 2】\n\n有一个 $$5×3$$的阶梯形矩阵$$U$$，秩为3，求矩阵$$U$$ 的零空间。\n\n**答案**：只有零向量。\n\n**复习概念**：\n\n1. **零空间**：使得$$Ax = 0$$成立的所有解向量构成的空间。\n2. **行阶梯矩阵**：在矩阵中可画出一条阶梯线，线的下方全为 0，每个台阶只有一行，台阶数即是非零行的行数，阶梯线的竖线（每段竖线的长度为一行）后面的第一个元素为非零元，也就是非零行的第一个非零元。例如：\n\n$$\n\\begin{bmatrix}∗ & ∗ & ∗ & ∗ & ∗ \\\\0 & ∗ & ∗ & ∗ & ∗ \\\\0 & 0 & 0 & * & * \\\\0 & 0 & 0 & 0 & *\\\\0 & 0 & 0 & 0 & 0\\end{bmatrix}\n$$\n\n1. **行最简形矩阵**：非零行的第一个非零元都为 1，且这些非零元所在的列的其他元素都为 0。例如：\n\n$$\n\\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 \\\\\n\\end{bmatrix},\\begin{bmatrix}\n1 & 0 & 2 & 0 & -2 \\\\\n0 & 1 & -1 & 0 & 3 \\\\\n0 & 0 & 0 & 1 & 4 \\\\\n0 & 0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n\n1. **矩阵 A 右乘列向量的意义**：矩阵$$A$$右乘列向量可以理解为对$$A$$各列向量的线性组合。\n\n**分析**：由矩阵$$U$$的秩为 3 可知，其列向量线性无关。因为零空间是由满足$$Ux = 0$$的解向量构成，而列向量线性无关意味着不存在非零的线性组合能得到零向量，所以$$U$$的零空间中只有零向量。\n\n### 【例 3】\n\n给定 $$10×3$$矩阵$$B$$，$$B$$中含有矩阵$$R$$和$$2R$$，即$$B=\\begin{bmatrix}R\\\\2R\\end{bmatrix}$$（$$R$$是行最简形矩阵）。求该矩阵的秩以及其阶梯型矩阵。\n\n**答案**：利用分块矩阵思想，$$B$$可化简为$$\\begin{bmatrix}R\\\\0\\end{bmatrix}$$，这就是$$B$$的阶梯型矩阵，它的秩即为矩阵$$R$$的秩。\n\n**进一步问题**：矩阵$$C=\\begin{bmatrix}R & R\\\\R & 0\\end{bmatrix}$$的行最简形是什么？\n\n**解答**：\n\n$$\n\\begin{bmatrix}R & R\\\\R & 0\\end{bmatrix} \\xrightarrow{行变化} \\begin{bmatrix}R & R\\\\0 & -R\\end{bmatrix} \\xrightarrow{提出 (-1)} \\begin{bmatrix}R & R\\\\0 & R\\end{bmatrix} \\xrightarrow{行变化} \\begin{bmatrix}R & 0\\\\0 & R\\end{bmatrix}\n$$\n\n注意：严格意义上还应当将$$\\begin{bmatrix}R & 0\\\\0 & R\\end{bmatrix}$$中$$R$$的下面零行移到最简形$$\\begin{bmatrix}R & 0\\\\0 & R\\end{bmatrix}$$整体的最下面一行，这才是标准的行最简型矩阵。\n\n**再进一步问题**：已知$$R$$的秩为 3，求$$C$$的转置矩阵的零空间的维数。\n\n**知识回顾**：矩阵的零空间的维数等于列数减去矩阵的秩（$$n-r$$），列满秩的矩阵对应零空间的维数为 0。\n\n**解答**：这里，$$C$$为 $$10×6$$的矩阵，则$$C^{T}$$为$$6×10$$的矩阵，$$n-r=10-(3+3)=4$$，所以其零空间的维数为 4。\n\n### 【例 4】\n\n已知$$Ax=\\begin{bmatrix}2\\\\4\\\\2\\end{bmatrix}$$，$$x=\\begin{bmatrix}2\\\\0\\\\0\\end{bmatrix}+c\\begin{bmatrix}1\\\\1\\\\0\\end{bmatrix}+d\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$$，求$$A$$的行向量的生成空间的相关信息。\n\n**分析**：\n\n1. **矩阵**$$A$$的形状：由$$Ax=\\begin{bmatrix}2\\\\4\\\\2\\end{bmatrix}$$，因为是$$A$$（$$m×n$$）与$$x$$（$$n×1$$）相乘得到结果，所以$$n = 3$$，又因为结果是 $$3×1$$向量，所以$$m = 3$$，可知矩阵$$A$$的形状是$$3×3$$的。\n2. **矩阵**$$A$$的秩：已知零空间的维数为 2，根据$$n-r=2$$，且$$A$$的列数$$n = 3$$，可得$$A$$的秩$$r = 1$$ 。\n3. **矩阵**$$A$$的具体形式：由通解$$x$$的形式，先将$$c = d = 0$$代入$$Ax = b$$方程，即$$A\\begin{bmatrix}2\\\\0\\\\0\\end{bmatrix}=\\begin{bmatrix}2\\\\4\\\\2\\end{bmatrix}$$，由此可推出$$A$$的第一行为$$\\begin{bmatrix}1 & 2 & 1\\end{bmatrix}$$。又因为$$Ax = b$$通解中包含了零空间$$Ax = 0$$的两个特解$$\\begin{bmatrix}1\\\\1\\\\0\\end{bmatrix}$$，$$\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$$，将其代入方程$$Ax = 0$$就能解出$$A$$的形式，最终确定$$A=\\begin{bmatrix}1 & -1 & 0\\\\2 & -2 & 0\\\\1 & -1 & 0\\end{bmatrix}$$。\n\n**引申问题**：既然$$A=\\begin{bmatrix}1 & -1 & 0\\\\2 & -2 & 0\\\\1 & -1 & 0\\end{bmatrix}$$，那么当$$b$$满足何种条件时，$$Ax = b$$有解？\n\n**分析**：由之前几节的结论知道，当$$b$$属于矩阵的列空间时有解。对于$$A$$矩阵来说，其列向量线性相关，实际上只有一列对线性组合有贡献。\n\n**答案**：$$b$$向量应当满足$$b = c\\begin{bmatrix}1\\\\2\\\\1\\end{bmatrix}$$（$$c$$为任意常数）。\n\n### 【例 5】\n\n如果一个方阵$$A$$的零空间只包含零向量，那它转置矩阵的零空间呢？\n\n**答案**：也只包含零向量。\n\n**解析**：根据矩阵的性质，方阵$$A$$与其转置矩阵$$A^{T}$$的秩相等。已知$$A$$的零空间只包含零向量，说明$$A$$满秩，那么$$A^{T}$$也满秩，所以$$A^{T}$$的零空间同样只包含零向量。\n\n### 【例 6】\n\n5 阶可逆方阵是否构成向量空间？\n\n**答案**：否。因为向量空间必须包含零向量，而 5 阶可逆方阵中不包含零矩阵，所以肯定不是向量空间。\n\n### 【例 7】\n\n存在除零矩阵外的平方为零的矩阵吗？\n\n**答案**：存在，例如$$B=\\begin{bmatrix}0 & 1\\\\0 & 0\\end{bmatrix}$$ 。这个例子在后续学习中对于理解特殊矩阵的性质很重要。\n\n### 【例 8】\n\n方阵的列线性无关，$$Ax = b$$是否总是有解？\n\n**分析**：因为矩阵列线性无关且为方阵，所以该方阵可逆。在之前学习消元矩阵时提到，可逆矩阵可以通过消元回代求解。所以此时$$Ax = b$$总是可解的。\n\n### 【例 9】\n\n研究矩阵$$B$$的零空间，已知$$B$$是 $$3×4$$矩阵，由一个可逆矩阵$$\\begin{bmatrix}1 & 1 & 0\\\\0 & 1 & 0\\\\1 & 0 & 1\\end{bmatrix}$$左乘矩阵$$\\begin{bmatrix}1 & 0 & -1 & 2\\\\0 & 1 & 1 & -1\\\\0 & 0 & 0 & 0\\end{bmatrix}$$ 得到。\n\n**解答**：首先，$$B$$有四个列向量，所以$$B$$的零空间必是$$R^{4}$$的子空间。引入结论：假设有矩阵$$C$$，$$D$$，当$$C$$可逆的时候，$$N(CD)=N(D)$$（$$N(A)$$表示$$A$$的零空间），原因是可以对$$CDx = 0$$两侧同时乘上$$C^{-1}$$ 。回到本题，$$B$$零空间的求解只取决于矩阵$$\\begin{bmatrix}1 & 0 & -1 & 2\\\\0 & 1 & 1 & -1\\\\0 & 0 & 0 & 0\\end{bmatrix}$$ ，通过计算，或者直接使用之前介绍过的结论（第 7 课），可得$$B$$零空间的基为$$\\begin{bmatrix}1\\\\ -1\\\\1\\\\0\\end{bmatrix}$$，$$\\begin{bmatrix}-2\\\\1\\\\0\\\\1\\end{bmatrix}$$。\n\n**进一步问题**：求$$Bx=\\begin{bmatrix}1\\\\0\\\\1\\end{bmatrix}$$的通解。\n\n**分析**：先分析其特解，观察$$B$$的第一列，$$B$$的第一列恰好就是等式右侧的$$b=\\begin{bmatrix}1\\\\0\\\\1\\end{bmatrix}$$ 。在$$Ax = b$$中，如果$$b$$与$$A$$中一个列向量相同，则可以直接写出一个特解，即该列系数为 1，其余列系数为 0 的线性组合方式，所以这里的一个特解为$$\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix}$$ 。而零空间的基之前已讨论得出，所以通解即可求出。\n\n### 【例 10】\n\n如果矩阵是方阵，是否意味着矩阵的行空间等于列空间？\n\n**答案**：错误，反例：$$B=\\begin{bmatrix}0 & 1\\\\0 & 0\\end{bmatrix}$$ 。该矩阵的行空间是由向量$$(0, 1)$$张成的空间，列空间是由向量$$(1, 0)$$张成的空间，二者不相等。\n\n### 【例 11】\n\n如果$$A$$与$$B$$的四个子空间相同，则$$A$$是$$B$$的倍数？\n\n**答案**：错误，例如：任意的可逆矩阵的四个子空间都相同，但它们不一定成倍数关系。\n\n### 【例 12】\n\n给定矩阵$$A$$，交换其中的两行，哪些子空间没变？\n\n**答案**：行空间与零空间。交换矩阵的两行，行向量组的线性相关性不变，所以行空间不变；同时，$$Ax = 0$$的解的情况也不变，所以零空间不变。\n\n### 【例 13】\n\n为什么向量$$(1, 2, 3)$$不能既是$$A$$的某一行，又在$$A$$零空间中？\n\n**分析**：直接代入方程$$Ax = 0$$，若向量$$(1, 2, 3)$$是$$A$$的某一行，设$$A=\\begin{bmatrix}1 & 2 & 3\\\\ \\cdot & \\cdot & \\cdot\\\\ \\cdot & \\cdot & \\cdot\\end{bmatrix}$$，则$$\\begin{bmatrix}1 & 2 & 3\\\\ \\cdot & \\cdot & \\cdot\\\\ \\cdot & \\cdot & \\cdot\\end{bmatrix}\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}=\\begin{bmatrix}1\\times1 + 2\\times2 + 3\\times3\\\\ \\cdot\\\\ \\cdot\\end{bmatrix}=\\begin{bmatrix}14\\\\ \\cdot\\\\ \\cdot\\end{bmatrix}\\neq\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}$$，等式不成立。\n\n**结论**：给定矩阵，其行空间与零空间共享的向量只能是零向量（以后会提到：矩阵的零空间与行空间正交）。\n\n## 三、学习感悟\n\n这节复习课结束，意味着线性代数这一部分的基础内容告一段落。接下来的课程将围绕正交、特征值等概念展开讨论，这些内容将进一步深化对线性代数的理解和应用。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数12-矩阵应用:图与网络","url":"/2025/03/28/Linear_Algebra/线性代数-12/","content":"\n# Linear Algebra-矩阵应用:图与网络-12\n\n## 一、知识概要\n\n本节重点阐述图与矩阵之间的紧密联系，借助矩阵来展现图的特性。与前面几节内容不同，之前例子中的矩阵元素大多是为解释性质而设定的，而本节矩阵元素均源于实际问题，这能更直观地体现之前所学矩阵性质在实际场景中的应用价值。\n\n## 二、图和关联矩阵\n\n我们先来看一个有向图（图一）：\n\n![Linear_Algebra120](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra120.png)\n\n在本节中，我们围绕这个有向图展开研究。对于有向图，我们可以写出它的关联矩阵 $$A$$，如下：\n\n$$\nA=\\begin{bmatrix} -1 & 1 & 0 & 0 \\\\ 0 & -1 & 1 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ -1 & 0 & 0 & 1 \\\\ 0 & 0 & -1 & 1 \\end{bmatrix}\n$$\n\n对于不太熟悉关联矩阵的读者，这里简单介绍一下。在这个 $$5×4$$ 的矩阵中，每一列对应一个节点，例如第一列代表节点 1，第二列代表节点 2，以此类推；每一行则代表一条边的走向，第一行代表边 1，第二行代表边 2，依此类推。需要注意的是，在每一行所代表的边中，若该边以某个节点为起点，那么在矩阵中对应元素为 -1；若以某个节点为终点，对应元素则为 1。\n\n以第一行为例，第一行代表边 1 的特征。在图（一）中，边 1 从节点 1 出发，到达节点 2，这在矩阵中就表现为 $$A_{11} = -1$$，$$A_{12} = 1$$。其他行以此类推。\n\n接下来，我们探讨图（一）所代表的实际意义。\n\n【例】假设 $$x$$ 表示每个节点上的电势，研究 $$Ax = b$$ 这种形式能得出哪些结论。\n\n1. 当 $$b$$**为零向量**时：此时需要求解 $$Ax = 0$$，即：\n\n$$\nAx=\\begin{bmatrix} -1 & 1 & 0 & 0 \\\\ 0 & -1 & 1 & 0 \\\\ -1 & 0 & 1 & 0 \\\\ -1 & 0 & 0 & 1 \\\\ 0 & 0 & -1 & 1 \\end{bmatrix}\\begin{bmatrix}x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4\\end{bmatrix}=\\begin{bmatrix}x_2 - x_1 \\\\ x_3 - x_2 \\\\ x_3 - x_1 \\\\ x_4 - x_1 \\\\ x_4 - x_3\\end{bmatrix}=\\begin{bmatrix}0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{bmatrix}\n$$\n\n求解上述方程组可得：$$x = C\\begin{bmatrix}1 \\\\ 1 \\\\ 1 \\\\ 1\\end{bmatrix}$$（$$C$$ 为常数）。\n\n因为 $$x$$ 代表各个节点的电势，所以 $$x$$ 的解集表明当 $$b = 0$$ 时，各点电势必须相等。我们知道，电势差与电流的形成密切相关，$$b = 0$$ 意味着各条边上都没有电流（即电势差为零），而最终解得各点电势相等时边上电流为 0，这与我们的物理常识相符。\n\n1. 当 $$b$$**不为零**时：我们可以通过特解加上通解的方法，求出在不同 $$b$$ 值情况下方程的解。这些解代表了**在不同电势差情况下，各点电势的大小**。\n\n接下来研究左零空间 $$A^T y = 0$$ 的特点。首先，矩阵 $$A$$ 的转置为：\n\n$$\nA^T=\\begin{bmatrix} -1 & 0 & -1 & -1 & 0 \\\\ 1 & -1 & 0 & 0 & 0 \\\\ 0 & 1 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 1 & 1 \\end{bmatrix}\n$$\n\n然后求解方程 $$A^T y = 0$$，即：\n\n$$\nA^T y=\\begin{bmatrix} -1 & 0 & -1 & -1 & 0 \\\\ 1 & -1 & 0 & 0 & 0 \\\\ 0 & 1 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 1 & 1 \\end{bmatrix}\\begin{bmatrix}y_1 \\\\ y_2 \\\\ y_3 \\\\ y_4 \\\\ y_5\\end{bmatrix}=\\begin{bmatrix}0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{bmatrix}\n$$\n\nA转置后，$$y$$ 有五个分量，是对 $$A^T$$ 的行进行线性组合。由于 $$A^T$$ 的行代表 1 - 5 边，结合前面的例子背景，这里求解的就是流过每条边的电流。\n\n求解该方程可得：\n\n$$\n-y_1 - y_3 - y_4 = 0\n$$\n\n$$\ny_1 - y_2 = 0\n$$\n\n$$\ny_2 + y_3 - y_5 = 0\n$$\n\n$$\ny_4 + y_5 = 0\n$$\n\n这些方程体现了**基尔霍夫定律**，即**每个节点流入和流出的电流相同**。每个方程分别代表一个节点的电流情况，最终解得的 $$\\begin{bmatrix}y_1 & y_2 & y_3 & y_4 & y_5\\end{bmatrix}$$ 就是满足这一特性的各条边的电流值。\n\n## 三、实际应用的扩展\n\n$$Ax = \\begin{bmatrix}x_2 - x_1 & x_3 - x_2 & x_3 - x_1 & x_4 - x_1 & x_4 - x_3\\end{bmatrix}$$，这个式子表示每两点之间的电势差。该方程将图的特征（通过矩阵 $$A$$ 体现）与各点电势（x）紧密联系起来。\n\n在研究 $$A^T y$$ 时，其中的 $$y$$ 代表各个边上的电流。结合电流与电势差的关系，我们联想到初中所学的欧姆定律。电流与电压之间存在一个比例系数，假设用矩阵 $$C$$ 表示，即有：\n\n$$\\begin{bmatrix}y_1 \\\\ y_2 \\\\ y_3 \\\\ y_4\\end{bmatrix}=C\\begin{bmatrix}x_2 - x_1 \\\\ x_3 - x_2 \\\\ x_3 - x_1 \\\\ x_4 - x_3\\end{bmatrix}=C Ax$$，也就是 $$y = CAx$$。\n\n这样，我们就成功地用矩阵表示了图像、电流和电势差这些概念。\n\n进一步拓展，前面研究的 $$A^T y = 0$$ 是**无源场**的情况。如果存在外加电源，可表示为 $$A^T y = f$$（$$f$$ 表示外加电源的影响）。结合前面得到的 $$y = CAx$$，最终得到式子：$$A^T CAx = f$$。\n\n## 四、学习感悟\n\n本节内容与之前所学知识联系紧密，同时与实际应用的结合也十分紧密。从一个有向图出发，结合实际物理问题，详细解释了如何运用矩阵来阐述欧姆定律和基尔霍夫定律。学习完本节后，我们对之前所学的各种空间在实际问题中的作用有了更深入、更切实的理解，真正体会到线性代数知识的实用性和广泛应用。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数11-矩阵空间,秩1矩阵","url":"/2025/03/28/Linear_Algebra/线性代数-11/","content":"\n# Linear Algebra-矩阵空间,秩 1 矩阵-11\n\n## 一、知识概要\n\n上节末尾我们介绍了矩阵空间，它是一种延伸的向量空间。本节将从矩阵空间入手，探讨矩阵空间的维数、基等问题，揭示微分方程与线性代数之间的联系，并剖析秩为 1 的矩阵的特点。\n\n## 二、矩阵空间\n\n在上一节的基础上，我们将所有 3×3 的矩阵视为“向量空间”中的元素。在由所有 3×3 矩阵构成的集合中，矩阵之间的加法与数乘矩阵运算都是封闭的。因此，这个集合 M 可以被称作空间。\n\n上节提到，M 有两个基本的子空间：\n\n1. **对称矩阵 S**：对称矩阵满足矩阵转置等于自身，即$$A^T = A$$。\n2. **上三角矩阵 U**：上三角矩阵主对角线以下的元素均为 0。\n\n在这两个矩阵集合中，加法封闭与数乘封闭的性质很容易证明。例如，对于对称矩阵$$A$$和$$B$$，以及实数$$k$$，$$(A + B)^T = A^T + B^T = A + B$$，$$(kA)^T = kA^T = kA$$，这就证明了对称矩阵集合对加法和数乘封闭；上三角矩阵同理。\n\n而 S 与 U 空间相交，得到另一个子空间：对角阵 D。对角阵既是对称矩阵，又是上三角矩阵，其主对角线以外的元素都为 0。\n\n### 2.1 基与维数\n\n1. **M 的基与维数**：M 的基与$$R^9$$的基类似。对于$$R^9$$，其标准基是 9 个单位向量，每个向量只有一个分量为 1，其余分量为 0。在 3×3 矩阵空间 M 中，其基可以表示为：\n\n$$\n\\left[\\begin{array}{lll}1 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 1 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right], \\cdots,\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 1\\end{array}\\right]\n$$\n\n由于 3×3 矩阵有 9 个元素，所以 M 的维数为 9。这就如同在$$R^9$$向量空间中，需要 9 个线性无关的向量才能构成基，从而确定空间的维数。\n\n1. **S 与 U 的基与维数**：对称矩阵 S 的基有 6 个，如下：\n\n$$\n\\left[\\begin{array}{lll}1 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 1 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 1\\end{array}\\right]\n$$\n\n上三角矩阵 U 的基也有 6 个：\n\n$$\n\\left[\\begin{array}{lll}1 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 1 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 1\\end{array}\\right]\n$$\n\n所以 S 和 U 的维数都是 6。这里要强调的是，矩阵基与向量在形式上有所不同。向量的基通常是简单的数值向量，而矩阵基则是由矩阵构成，其元素的排列和性质与矩阵的运算规则紧密相关。\n\n1. **对角阵 D 的基与维数**：对角阵 D 的基很明显只有 3 个：\n\n$$\n\\left[\\begin{array}{lll}1 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 0\\end{array}\\right],\\left[\\begin{array}{lll}0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 1\\end{array}\\right]\n$$\n\n所以对角阵 D 的维数为 3，其基正好是 S 与 U 的交集。用数学符号表示为：$$dim(S \\cap U)=3$$。\n\n1. **S + U 的维数**：在向量空间中，两个子空间的并集通常不是向量空间，因为两个向量相加可能会超出这个并集的范围。而$$S + U$$这个集合，包含了 S 与 U 的线性组合，即任意对称阵加上任意上三角矩阵的和都在这个集合里。实际上，$$S + U$$这个集合就是 M。所以$$S + U$$的维数是 9。\n\n联系上述所有维数，存在这样一个等式：\n\n$$\ndim(S)+dim(U)=dim(S \\cap U)+dim(S + U)\n$$\n\n代入具体维数可得：$$6 + 6 = 3 + 9$$\n\n### 2.2 微分方程\n\n“空间”的概念应用广泛，线性空间中的元素不仅可以是向量、矩阵，还可以是方程的解。\n\n以解微分方程$$\\frac{d^{2} y}{d x^{2}}+y=0$$为例，在实数范围内，该微分方程有两个特解：$$y = \\sin x$$与$$y = \\cos x$$。而它的所有解都是这两个特解的线性组合，即$$y = c_1\\cos x + c_2\\sin x$$。\n\n这与零空间的概念类似，我们可以将这些解看作线性空间中的元素，称其为解空间。解空间中的元素满足线性运算封闭条件，即如果$$y_1 = c_{11}\\cos x + c_{12}\\sin x$$和$$y_2 = c_{21}\\cos x + c_{22}\\sin x$$是解空间中的两个解，那么$$y_1 + y_2 = (c_{11} + c_{21})\\cos x + (c_{12} + c_{22})\\sin x$$也是解，$$ky_1 = kc_{11}\\cos x + kc_{12}\\sin x$$（$$k$$为实数）同样是解。\n\n从空间的角度来看，这个解空间的两个基就是$$\\cos x$$与$$\\sin x$$，它们的线性组合构成了解空间，所以解空间的维数为 2。\n\n## 三、秩一矩阵\n\n### 3.1 秩一矩阵的优点\n\n1. **易于分解**：对于矩阵$$A=\\left[\\begin{array}{lll}1 & 4 & 5 \\\\ 2 & 8 & 10\\end{array}\\right]$$，很明显它的秩为 1。因为第二行元素是第一行元素的 2 倍，满足秩一矩阵的特点，即每一行都是第一行的倍数。这类矩阵可以分解为一列乘一行的形式，$$A=\\left[\\begin{array}{lll}1 & 4 & 5 \\\\ 2 & 8 & 10\\end{array}\\right]=\\left[\\begin{array}{l}1 \\\\ 2\\end{array}\\right]\\left[\\begin{array}{lll}1 & 4 & 5\\end{array}\\right]$$。一般地，秩一矩阵都可以写为$$A = UV^T$$的形式，其中$$U$$是列向量，$$V^T$$是行向量。\n2. **可搭建其他矩阵**：秩一矩阵还可以用来“搭建”其他矩阵。例如，秩为 4 的矩阵可以通过四个秩一矩阵搭建出来。这一过程类似于矩阵乘法中的“列乘行”形式，通过一列一行的组合搭出一个矩阵。假设要搭建一个秩为 4 的矩阵$$B$$，可以找到四个线性无关的秩一矩阵$$A_1 = U_1V_1^T$$，$$A_2 = U_2V_2^T$$，$$A_3 = U_3V_3^T$$，$$A_4 = U_4V_4^T$$，然后通过线性组合$$B = k_1A_1 + k_2A_2 + k_3A_3 + k_4A_4$$（$$k_1,k_2,k_3,k_4$$为非零实数）来构造。\n\n### 3.2 空间角度解释同秩矩阵\n\n从空间角度看，所有秩为 4 的矩阵构成的集合 M 不能称之为空间。原因主要有两点：\n\n1. **不包含零向量**：零矩阵的秩为 0，而不是 4，所以集合 M 中不包含零向量。在线性空间的定义中，零向量是必须存在的元素。\n2. **对加法不封闭**：根据矩阵秩的性质$$R(A + B) \\leq R(A) + R(B)$$，两个秩为 4 的矩阵相加，结果的秩可能小于或等于 8，但不一定等于 4。例如，对于矩阵$$A=\\left[\\begin{array}{cccc}1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1\\end{array}\\right]$$和$$B=\\left[\\begin{array}{cccc}-1 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 0 \\\\ 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & -1\\end{array}\\right]$$，$$A + B$$是零矩阵，秩为 0，这表明两个秩为 4 的矩阵相加，结果的秩可能发生变化，不满足对加法封闭的条件。所以所有秩为 4 的矩阵集合并不能构成空间。同理，秩为 1 的矩阵集合也不能构成空间。\n\n### 3.3 子空间的转化\n\n通过以下例子加深对子空间的理解：\n\n在四维空间中，向量$$v=\\left[\\begin{array}{l}v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4\\end{array}\\right]$$都满足$$v_1 + v_2 + v_3 + v_4 = 0$$，设这样的向量构成的集合为 S。\n\n首先判断 S 是否为子空间：\n\n1. **加法封闭**：设$$v=\\left[\\begin{array}{l}v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4\\end{array}\\right]$$，$$w=\\left[\\begin{array}{l}w_1 \\\\ w_2 \\\\ w_3 \\\\ w_4\\end{array}\\right]$$都属于 S，即$$v_1 + v_2 + v_3 + v_4 = 0$$，$$w_1 + w_2 + w_3 + w_4 = 0$$。那么$$v + w=\\left[\\begin{array}{l}v_1 + w_1 \\\\ v_2 + w_2 \\\\ v_3 + w_3 \\\\ v_4 + w_4\\end{array}\\right]$$，且$$(v_1 + w_1)+(v_2 + w_2)+(v_3 + w_3)+(v_4 + w_4)=(v_1 + v_2 + v_3 + v_4)+(w_1 + w_2 + w_3 + w_4)=0$$，所以$$v + w$$也属于 S，满足加法封闭。\n2. **数乘封闭**：对于任意实数$$k$$，$$kv=\\left[\\begin{array}{l}kv_1 \\\\ kv_2 \\\\ kv_3 \\\\ kv_4\\end{array}\\right]$$，且$$kv_1 + kv_2 + kv_3 + kv_4 = k(v_1 + v_2 + v_3 + v_4)=0$$，所以$$kv$$也属于 S，满足数乘封闭。\n3. **包含零向量**：当$$v_1 = v_2 = v_3 = v_4 = 0$$时，满足$$v_1 + v_2 + v_3 + v_4 = 0$$，即零向量属于 S。\n\n综上，S 是一个子空间。\n\n接下来求 S 的维数：\n\n假设有一矩阵$$A=\\left[\\begin{array}{llll}1 & 1 & 1 & 1\\end{array}\\right]$$，由 S 中$$v$$的特殊性质，可得$$Av=\\left[\\begin{array}{llll}1 & 1 & 1 & 1\\end{array}\\right]\\left[\\begin{array}{l}v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4\\end{array}\\right]=v_1 + v_2 + v_3 + v_4 = 0$$。\n\n这样就通过 A 构造了一个$$Ax = 0$$的方程，将 S 空间转化为了 A 的零空间。此时问题转化为求此零空间的基和维数。\n\n矩阵 A 的秩$$r$$为 1，列数$$n = 4$$。根据秩的定义，主元只有一个，自由变元有$$n-r=4-1=3$$个。\n\n所以 S 的零空间是三维空间，其基为$$Av = 0$$的三个特解：\n\n$$\n\\left[\\begin{array}{r}-1 \\\\ 1 \\\\ 0 \\\\ 0\\end{array}\\right],\\left[\\begin{array}{r}-1 \\\\ 0 \\\\ 1 \\\\ 0\\end{array}\\right],\\left[\\begin{array}{r}-1 \\\\ 0 \\\\ 0 \\\\ 1\\end{array}\\right]\n$$\n\n最后回顾 A 的列空间与左零空间：\n\n1. **列空间**：$$A=\\left[\\begin{array}{llll}1 & 1 & 1 & 1\\end{array}\\right]$$，它的列空间的基就是$$R^1$$的基，其线性组合构成的空间就是$$R^1$$。所以 A 列空间即为$$R^1$$。\n2. **左零空间**：A 的左零空间是线性组合各行得到零向量的方式。对于$$A=\\left[\\begin{array}{llll}1 & 1 & 1 & 1\\end{array}\\right]$$，很显然它的左零空间只有零向量。\n\n## 四、小世界图\n\n这部分内容是为下一节“图与网络”做铺垫，主要介绍图与矩阵之间的关联。\n\n给定一个包含五个节点和六条边的图，可以用一个 5×6 的矩阵来表示其中的所有信息，具体表示方法将在下节课详细讲解。\n\n![Wz6mbsBNQokk46xpF49cOtMXncg](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Wz6mbsBNQokk46xpF49cOtMXncg.png)\n\n此外，“六度分割理论”大家可能有所耳闻，该理论指出任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。在这个理论中，将人抽象成点，将联系抽象为图，这体现了图在描述关系网络方面的应用，也进一步说明了图与矩阵之间存在着某种潜在的联系，具体内容同样留到下节课探讨。\n\n## 五、学习感悟\n\n本节主要介绍了线性空间，包括矩阵空间、解空间等具体类型。秩一矩阵不仅将之前学习的矩阵乘法列乘行方式联系起来，而且其易于分解的特点使其在矩阵构造中具有重要作用。通过对这些内容的学习，我们对线性代数的知识体系有了更深入的理解，也为后续学习图与网络等相关内容奠定了基础。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数10-四个基本子空间","url":"/2025/03/28/Linear_Algebra/线性代数-10/","content":"\n# Linear Algebra-四个基本子空间-10\n\n## 一、知识概要\n\n此前介绍过列空间、零空间，但对于一个矩阵而言，可挖掘的空间不止这些。本节介绍四个基本子空间，作为对空间概念的补充，方便后续讨论。\n\n## 二、四个基本空间介绍\n\n对于一个$$m×n$$矩阵$$A$$，以下四个基本空间是其基础：\n\n1. **列空间 **$$C(A)$$：由矩阵$$A$$的列向量线性组合构成的空间。$$m×n$$矩阵$$A$$的每个列向量有$$m$$个分量，属于$$R^{m}$$空间，所以列空间是$$R^{m}$$的子空间。\n2. **零空间 **$$N(A)$$：由$$Ax = 0$$的解构成的空间。由于$$x$$本质是对$$A$$列向量的线性组合，$$A$$有$$n$$个列向量，所以零空间是$$R^{n}$$的子空间 。\n3. **行空间 **$$C(A^{T})$$：矩阵$$A$$各行线性组合构成的子空间，也可理解为$$A$$转置的列空间，即$$C(A^{T})$$。$$A$$的每个行向量有$$n$$个分量，都在$$R^{n}$$中，所以$$A$$的行空间是$$R^{n}$$的子空间。\n4. **左零空间 **$$N(A^{T})$$：可以理解为$$A^{T}$$的零空间。$$A^{T}$$是一个$$n×m$$的矩阵，$$A^{T}$$有$$m$$个列向量，所以左零空间是$$R^{m}$$的子空间。\n\n### 2.1 四个基本空间的维数与基\n\n研究$$m×n$$的矩阵$$A$$，其四个子空间的基本性质如下：\n\n1. **列空间**：设矩阵$$A$$的秩为$$r$$，$$A$$有$$r$$个主列，这$$r$$个主列就是列空间$$C(A)$$一组基，一组基里有$$r$$个向量，所以列空间维数为$$r$$。\n2. **零空间**：当矩阵$$A$$秩为$$r$$时，自由列为$$n-r$$列。这$$n-r$$列决定了$$x$$中的$$n-r$$个自由变元，赋值后构成零空间的$$n-r$$个基向量，故零空间维数为$$n-r$$。\n3. **行空间**：$$A$$的行空间可化为$$A^{T}$$的列空间，也可直接对$$A$$的行向量进行变换，行空间的维数是秩数$$r$$。\n\n   - **例**：设$$A=\\begin{bmatrix}1&2&3&1\\\\1&1&2&1\\\\1&2&3&1\\end{bmatrix}$$，对$$A$$进行变换得到$$\\begin{bmatrix}1&0&1&1\\\\0&1&1&0\\\\0&0&0&0\\end{bmatrix}$$（行最简形矩阵$$R$$，左上角是单位矩阵$$I$$，右上角是自由列$$F$$，下面是全零行）。$$A$$只有两行线性无关，秩为 $$2$$，$$A$$行向量的基就是$$R$$的前两行，维数为 $$2$$。行变换不改变$$A$$的行空间，将$$A$$化简为行最简型$$R$$后取前$$r$$（秩数）行向量，即为$$A$$行空间的基。\n4. **左零空间**：左零空间写成方程形式为$$A^{T}y = 0$$，两边同时转置得$$y^{T}A = 0$$ ，此时对于 A 矩阵而言，$$y^{T}$$左乘 A 得到零向量，因此我们称之为左零空间。$$A^{T}$$是$$n×m$$的矩阵，其零空间维数为$$m-r$$。\n\n   - 寻找左零空间的基：设$$A=\\begin{bmatrix}1&2&3&1\\\\1&1&2&1\\\\1&2&3&1\\end{bmatrix}$$，行变换后得到行最简矩阵$$R=\\begin{bmatrix}1&0&1&1\\\\0&1&1&0\\\\0&0&0&0\\end{bmatrix}$$，行变换过程可用消元矩阵$$E$$表示，即\n\n$$\nEA=\\begin{bmatrix}-1&2&0\\\\1&-1&0\\\\-1&0&1\\end{bmatrix}\\begin{bmatrix}1&2&3&1\\\\1&1&2&1\\\\1&2&3&1\\end{bmatrix}=\\begin{bmatrix}1&0&1&1\\\\0&1&1&0\\\\0&0&0&0\\end{bmatrix}=R\n$$\n\n观察$$R$$下面一行为零行，抽出$$E$$第三行$$\\begin{bmatrix}-1&0&1\\end{bmatrix}$$，$$\\begin{bmatrix}-1&0&1\\end{bmatrix}\\begin{bmatrix}1&2&3&1\\\\1&1&2&1\\\\1&2&3&1\\end{bmatrix}=\\begin{bmatrix}0&0&0&0\\end{bmatrix}=0$$，得到左零空间的一组基$$[-1,0,1]$$，向量个数为$$m-r=3-2=1$$个。寻找左零矩阵的基，重点是找$$A$$行组合为零的系数，通过将$$\\begin{bmatrix}A&I\\end{bmatrix}\\xrightarrow{初等行变换}\\begin{bmatrix}R&E\\end{bmatrix}$$，求得$$E$$矩阵，根据$$R$$中的零行找到$$E$$中的线性组合方式，得到左零空间的基。\n\n### 2.2 四个基本空间图像\n\n$$m×n$$矩阵对应的四个基本空间图像如下：\n\n| 子空间                | 所属空间          | 维数    |\n| --------------------- | ----------------- | ------- |\n| 列空间 $$C(A)$$       | $$R^{m}$$的子空间 | $$r$$   |\n| 行空间 $$C(A^{T})$$   | $$R^{n}$$的子空间 | $$r$$   |\n| 零空间 $$N(A)$$       | $$R^{n}$$的子空间 | $$n-r$$ |\n| 左零空间 $$N(A^{T})$$ | $$R^{m}$$的子空间 | $$m-r$$ |\n\n\n## 三、矩阵空间\n\n线性空间的元素不一定是实数组成的向量，所有 $$3×3$$的矩阵可当成一个“向量空间”中的向量，只要满足线性空间的八条规律，对线性运算封闭，就可将其当做线性空间中的元素。因为矩阵本身满足线性空间的八条运算律，所以可将所有的$$3×3$$矩阵看做一个线性空间。\n\n其常见子空间有上三角矩阵、对称矩阵、对角矩阵，上三角矩阵与对称矩阵的交集为对角矩阵（$$diag$$）。例如，随意给出对角矩阵的一个基：$$\\begin{bmatrix}1&0&0\\\\0&0&0\\\\0&0&0\\end{bmatrix}$$，$$\\begin{bmatrix}1&0&0\\\\0&3&0\\\\0&0&0\\end{bmatrix}$$，$$\\begin{bmatrix}0&0&0\\\\0&0&0\\\\0&0&7\\end{bmatrix}$$。\n\n## 四、学习感悟\n\n本节主要是概念的渗透，介绍了四个基本空间，其中左零空间是新内容，即行向量的线性组合得到零向量，需要重点理解。2.2 中的表格在后续学习中会经常用到。此外，还引出了向量空间的概念，下节会详细介绍。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数09-线性无关,基和维数","url":"/2025/03/28/Linear_Algebra/线性代数-9/","content":"\n# Linear Algebra-线性无关,基和维数-09\n\n## 引言\n\n向量的线性无关意味着什么？如何用线性无关的概念来帮助我们描述包括零空间在内的子空间。\n\n## 线性无关(Linear Independence)\n\n矩阵_A_为 mxn 矩阵，其中 m<n（未知数个数多于方程数）。则_A_中具有至少一个自由变量，那么_A_x=0 一定具有非零解。_A_的列向量可以线性组合得到零向量，所以_A_的列向量是线性相关的。\n\n若$$c_1x_1+c_2x_2+...+c_nx_n=0$$仅在$$c_1=c_2=...=c_n$$时才成立，则称$$x_1,x_2,...,x_n$$是线性无关的。若这些向量作为列向量构成矩阵_A_，则方程Ax=0 只有零解 x=0，或称矩阵_A_的零空间只有零向量。换而言之，若存在非零向量 c，使得Ac=0，则这个矩阵_A_的列向量线性相关。\n\n在$$R^2$$空间中，两个向量只要不在一条直线上就是线性无关的。（在$$R^3$$中，三个向量线性无关的条件是它们不在一个平面上。）若选定空间$$R^2$$中的三个向量，则他们必然是线性相关的。例如，如下的三个列向量是线性相关的。\n\n$$\nA=\\begin{bmatrix}2&1&2.5\\\\1&2&-1\\end{bmatrix}\n$$\n\n此矩阵构成的方程_Ax=0 必有非零解，即三个向量线性相关。\n\n如果矩阵_A_的列向量为线性无关，则_A_所有的列均为主元列，没有自由列，矩阵的秩为 n。若_A_的列向量为线性相关，则矩阵的秩小于 n，并且存在自由列。\n\n## 张成空间(Spanning Space)\n\n当一个空间是由向量$$v_1,v_2,...,v_k$$的所有线性组合组成时，我们称这些向量张成了这个空间。例如矩阵的列向量张成了该矩阵的列空间。\n\n如果向量$$v_1,v_2,...,v_k$$张成空间 S，则 S 是包含这些向量的最小空间。\n\n## 基与维数(Basis and Dimension)\n\n向量空间的基是具有如下两个性质的一组向量：$$v_1,v_2,...,v_d$$\n\n- $$v_1,v_2,...,v_d$$线性无关\n- $$v_1,v_2,...,v_d$$张成该向量空间\n\n因此空间的基告诉我们关于该空间的一切信息。\n\n[例]$$R^3$$空间有一组基$$\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix},\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix},\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$$，因为它们满足$$c_1\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}+c_2\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}+c_3\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}=\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}$$只有零解，并且这三个向量线性无关，可以张成$$R^3$$空间。\n\n而$$\\begin{bmatrix}1\\\\1\\\\2\\end{bmatrix},\\begin{bmatrix}2\\\\2\\\\5\\end{bmatrix},\\begin{bmatrix}3\\\\3\\\\8\\end{bmatrix}$$则不能构成一组基，因为以它们为列向量组成的矩阵，有两个相同的行，消元肯定有自由列存在，因此这三个向量并非线性无关。\n\n> 当判定线性相关性时，可以随时在矩阵、空间和方程组的概念之间切换，哪个判据更容易判定就用哪个，这里显然矩阵不可逆更容易看出来，因为存在行向量重复的情况。从这里也可以看到行向量线性相关则列向量不可能线性无关。\n\n若以$$R^n$$空间中的 n 个向量为列向量构成的矩阵为可逆矩阵，则这些向量可以构成$$R^n$$空间中的一组基。\n\n## 子空间的基(Basis for a subspace)\n\n向量$$\\begin{bmatrix}1\\\\1\\\\2\\end{bmatrix},\\begin{bmatrix}2\\\\2\\\\5\\end{bmatrix}$$可以张成$$R^3$$中的一个平面，但是它们无法成为$$R^3$$空间的一组基。\n\n空间的每一组基都具有相同的向量数，这个数值就是空间的维数（dimension）。所以$$R^n$$空间的每组基都包含 n 个向量。\n\n## 列空间和零空间的基(Basis of a column space and nullspace)\n\n取$$A=\\begin{bmatrix}1&2&3&1\\\\1&1&2&1\\\\1&2&3&1\\end{bmatrix}$$\n\n讨论列空间：矩阵_A_的四个列向量张成了矩阵_A_的列空间，其中第 3 列和第 4 列与前两列线性相关，而前两个列向量线性无关。因此前两列为主元列。他们组成了列空间 C(_A_)的一组基。矩阵的秩为 2。\n\n实际上对于任何矩阵_A_均有：矩阵的秩 r=矩阵主元列的数目=列空间的维数\n\n> 注意：矩阵具有秩 rank 而不是维数 dimension，而空间有维数而不是秩。\n\n当知道了列空间的维数，可以从矩阵列向量中**随意选取足够数量的线性无关的向量**，它们每一组都可以构成列空间的一组基。\n\n## 讨论下零空间\n\n本例中矩阵的列向量不是线性无关的，因此其零空间 N(_A_)不止包含零向量。因为可以看出第 3 列是第 1 列和第 2 列的加和。所以向量$$\\begin{bmatrix}−1\\\\−1\\\\1\\\\0\\end{bmatrix}$$必然在零空间 N(_A_)之内。同样还可以对$$x_4$$赋值为 1，从而得到$$\\begin{bmatrix}-1\\\\0\\\\0\\\\1\\end{bmatrix}$$也在零空间之内。它们就是_A_x=0 的两个特解。\n\n零空间的维数=自由列的数目=n-r，因此本例中 N(A)的维数为 4-2=2。这两个特解就构成了零空间的一组基。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数08-求解 Ax=b:可解性与结构","url":"/2025/03/28/Linear_Algebra/线性代数-8/","content":"\n# Linear Algebra-求解 Ax=b:可解性与结构-08\n\n## 可解的条件\n\n仍以 $$A=\\begin{bmatrix}\n1&2&2&2\\\\\n2&4&6&8\\\\\n3&6&8&10\\\\\n\\end{bmatrix}$$为例，则方程为$$\\begin{bmatrix}\n1&2&2&2\\\\\n2&4&6&8\\\\\n3&6&8&10\\\\\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\nx_4\\\\\n\\end{bmatrix}=\\begin{bmatrix}\nb_1\\\\\nb_2\\\\\nb_3\\\\\n\\end{bmatrix}$$\n\n矩阵 A 的第三行为第一行和第二行的加和，因此$$Ax=b$$中的 b 要满足$$b_3=b_2+b_1$$，否则方程无解。\n\n检验$$Ax=b$$是否可解的方法是增广矩阵进行行消元。如果矩阵 A 的行被完全消去的话，则对应的 b 的分量也得是 0。在本例中，矩阵 A 的第三行被消去：\n\n$$\n\\begin{bmatrix}\n1&2&2&2&b_1\\\\\n2&4&6&8&b_2\\\\\n3&6&8&10&{b_3}\\\\\n\\end{bmatrix}->...->\\begin{bmatrix}\n1&2&2&2&b_1\\\\\n0&0&2&4&b_2-b_1\\\\\n0&0&0&0&b_3-b_2-b_1\\\\\n\\end{bmatrix}\n$$\n\n如果$$Ax=b$$有解，则$$b_3-b_2-b_1=0$$。在本例中我们令 $$b=\\begin{bmatrix}\n1\\\\\n5\\\\\n6\\\\\n\\end{bmatrix}$$\n\n前几讲讨论过，只有当 b 处于矩阵的列空间 C(_A_)之中时，方程才有解。本讲推导出矩阵_A_的行向量若经过线性组合成为了零向量，则对应的 b 经同样的线性组合后也要等于 0。\n\n## 通解\n\n为求得$$Ax=b$$的所有解，我们首先检验方程是否可解，然后找到一个特解。将特解和矩阵零空间向量相加即为方程的通解。\n\n## 特解\n\n求$$Ax=b$$特解的方法是将自由变量均赋值为 0，求其主变量。\n\n本例中，令$$x_2=x_{4}=0$$得到方程组：\n\n$$\nx_1+2x_3=1\\\\\n2x_3=3\n$$\n\n不难得到，$$x_3=\\frac{3}{2},x_1=-2$$，因此特解为$$x_p=\\begin{bmatrix}-2\\\\0\\\\3/2\\\\0\\end{bmatrix}$$。\n\n> 上一讲说了主元列和自由列的一个重要区别就是，自由列可以表示为主元列的线性组合，主元列之间是线性无关的。\n>\n> $$\n> U=\\begin{bmatrix}x&*&*&*&*&*&*&*\\\\\n> 0&0&y&*&*&*&*&*\\\\\n> 0&0&0&0&0&z&*&*\\\\\n> 0&0&0&0&0&0&0&u\\\\\n> \\end{bmatrix}\n> $$\n\n> 我们仍以消元完成后的梯形矩阵_U_为例，其包含四个主元列。对于_A_x=b 的求解转变为_U_x=c，其中 c 是向量 b 经过与左侧 A 矩阵相同的行操作得到的向量。显然，此时四个主元列的线性组合可以组成任何$$R^4$$中的向量，我们将 x 中的自由变量赋值为 0 就可以去掉自由列列向量的干扰，求得方程的特解$$x_p$$。如果消元得到的 U 最后 i 行为 0，如果方程要有解，c 的最后 i 个分量就要为 0，这时主元列才可以通过线性组合得到 c，否则方程无解。\n\n## 与零空间进行线性组合\n\n$$Ax=b$$的通解为$$x_{uni}=x_p+x_n$$，其中$$x_n$$为矩阵零空间中的向量，将$$Ax_p=b$$和$$Ax_n=0$$相加可得$$A(x_p+x_n)=b$$。\n\n上一讲我们知道，矩阵的零空间$$N(A)$$就是其特解$$\\begin{bmatrix}-2\\\\1\\\\0\\\\0\\end{bmatrix},\\begin{bmatrix}2\\\\0\\\\-2\\\\1\\end{bmatrix}$$的线性组合的集合，因此方程$$Ax=\\begin{bmatrix}1\\\\5\\\\6\\end{bmatrix}$$的通解即为：$$x_{uni}=\\begin{bmatrix}-2\\\\0\\\\3/2\\\\0\\end{bmatrix}+c_1\\begin{bmatrix}-2\\\\1\\\\0\\\\0\\end{bmatrix}+c_2\\begin{bmatrix}2\\\\0\\\\-2\\\\1\\end{bmatrix}$$，式中$$c_1$$和$$c_2$$为任意实数。\n\n矩阵的零空间 N(_A_)是$$R^4$$空间中的二维子空间，方程的解$$Ax=b$$构成了穿过$$x_p$$点并和 N(A)平行的“平面“。但该”平面“并不是$$R^4$$空间的子空间(因为该平面不过零点，不满足数乘的条件)。\n\n> 前面求取$$Ax=b$$的特解过程中，我们令所有自由变量赋值为 0。如果不赋值为 0，则等于带着自由列进行计算，但自由列其实也就是主元列的线性组合，这样求的特解$$x_p'$$只不过是$$x_p$$与零空间特解的一个加和。\n\n## 秩 Rank\n\n矩阵的秩等于矩阵的主元数。如果 mxn 矩阵的秩为 r，则必有 r<=m 且 r<=n。\n\n下面讨论一下满秩的情形：\n\n- 列满秩：r=n。每列都有主元，x 的每一个分量都是主变量，没有自由变量。零空间 N(A)之内只有零向量。方程无解或者有唯一解$$x_p$$。\n- 行满秩：r=m。每行都有主元，无论 b 取何值，方程_A_x=b 都有解。主变量 r 个，自由变量 n-r 个。如$$A=\\begin{bmatrix}1&0&*&*\\\\0&1&*&*\\end{bmatrix}$$的形式。\n- 满秩 r=m=n，矩阵可逆。零空间只有零向量，无论 b 取何值，方程_A_x=b 都有唯一解。如单位矩阵。\n\n总结如下：\n\n| r=m=n                      | r=n<m                                  | r=m<n                                 | r<n,r<m                                    |\n| -------------------------- | -------------------------------------- | ------------------------------------- | ------------------------------------------ |\n| 有效方程数量等于未知数数量 | 有效方程数数量大于未知数数量           | 有效方程数数量小于未知数数量          | It depends.                                |\n| $$R=$$                     | $$R=\\begin{bmatrix}I\\\\0\\end{bmatrix}$$ | $$R=\\begin{bmatrix}I&F\\end{bmatrix}$$ | $$R=\\begin{bmatrix}I&F\\\\0&0\\end{bmatrix}$$ |\n| 唯一解                     | 无解或者唯一解                         | 无穷多解                              | 无解或无穷多解                             |\n\n\n> 当矩阵是_m_×_n_的矩阵，且矩阵的秩_r_既小于_m_又小于_n_时，对应的线性方程组的解的情况如下：\n>\n> - 无穷多解：对于非齐次线性方程组_Ax_=_b_，当_r_(_A_)=_r_(_A_∣_b_)<_n_时，方程组有无穷多解。因为秩小于未知数个数_n_，意味着方程组中存在自由变量，自由变量可以取任意值，从而导致方程组有无穷多组解。\n> - 无解：对于非齐次线性方程组_Ax_=_b_，当$$r(A)\\neq r(A|b)$$时，方程组无解。此时增广矩阵(_A_∣_b_)经过初等行变换后，会出现形如[0 0 ⋯ 0 ∣ _c_]（$$c\\neq 0$$）的行，这表示方程组中存在矛盾方程，所以无解。\n>   这种情况下，线性方程组不可能有唯一解。因为唯一解的充分必要条件是$$r(A)=r(A|b)=n$$，而题目中给定秩_r_小于_n_，不满足唯一解的条件。\n\n总而言之，**矩阵的秩决定了方程组解的数量**。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数07-求解 Ax=0，主变量，特解","url":"/2025/03/28/Linear_Algebra/线性代数-7/","content":"\n# Linear Algebra-求解 Ax=0，主变量，特解-07\n\n## 概要\n\n记得上一节中我们讨论了列空间和零空间的相关问题，那么这一节我们从它们的定义过渡到它们的计算，即如何求解出这些空间的一般形式。给出一种可以解出$$Ax=0$$中的 x 构成的零空间的算法。\n\n## 消元法求解零空间\n\n记得之前在讲解使用消元法解方程组$$Ax=b$$时，我们对一种情况是无法处理的，那就是矩阵 A 不可逆的情况。之前对这种情况的解释是：求出的解不唯一。这正好对应了我们现在学到的“空间”概念。\n\n我们首先从最简单的零空间(b=0)的计算谈起。\n\n### 消元法确定主变量与自由变量(消元)\n\n【例】设 $$A=\\begin{bmatrix}\n1 & 2 & 2 & 2\\\\\n2 & 4 & 6 & 8\\\\\n3 & 6 & 8 & 10\\\\\n\\end{bmatrix}$$，求由 Ax=0 中的 x 构成的零空间。\n\nAx=0 其实就是一个方程组：\n\n$$\n\\begin{bmatrix}\n1 & 2 & 2 & 2\\\\\n2 & 4 & 6 & 8\\\\\n3 & 6 & 8 & 10\\\\\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\nx_4\\\\\n\\end{bmatrix}=0\n$$\n\n还是之前学过的消元法来直接处理矩阵 A：\n\n$$\n\\begin{bmatrix}\n1 & 2 & 2 & 2\\\\\n2 & 4 & 6 & 8\\\\\n3 & 6 & 8 & 10\\\\\n\\end{bmatrix}->\\begin{bmatrix}\n1 & 2 & 2 & 2\\\\\n0 & 0 & 2 & 4\\\\\n0 & 0 & 2 & 4\\\\\n\\end{bmatrix}->\\begin{bmatrix}\n1 & 2 & 2 & 2\\\\\n0 & 0 & 2 & 4\\\\\n0 & 0 & 0 & 0\\\\\n\\end{bmatrix}=U\n$$\n\n首先注意 A 矩阵消元之后只有两个主元：1 和 2，主元的个数被称为秩，即 A 的秩为 2。\n\n接下来应该是进行回代求解了，但是在这之前，由于消元得到的 U 不是一个严格的上三角矩阵，因此方程的解就不唯一，所以先来明确几个概念。\n\n![Linear_Algebra70](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra70.png)\n\n所以这个 U 的主变量(主元)为$$x_1,x_3$$。自由变量为$$x_2,x_4$$。\n\n### 对自由变量赋值覆盖零空间(回代)\n\n1. 首先给自由变量 $$\\begin{bmatrix}\n   x_2\\\\\n   x_4\\\\\n   \\end{bmatrix}$$赋值为$$\\begin{bmatrix}\n   1\\\\\n   0\\\\\n   \\end{bmatrix}$$。\n\n回代入方程组：\n\n$$\nx_1+2x_2+2x_3+2x_4=0\\\\2x_3+4x_4=0\n$$\n\n当 $$\\begin{bmatrix}\nx_2\\\\\nx_4\\\\\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\n0\\\\\n\\end{bmatrix}$$时，解向量为：$$\\begin{bmatrix}\n-2\\\\\n1\\\\\n0\\\\\n0\\\\\n\\end{bmatrix}$$。\n\n1. 再给自由变量 $$\\begin{bmatrix}\n   x_2\\\\\n   x_4\\\\\n   \\end{bmatrix}$$赋值为$$\\begin{bmatrix}\n   0\\\\\n   1\\\\\n   \\end{bmatrix}$$。\n\n再次回代入方程组，此时的解向量为 $$\\begin{bmatrix}\n2\\\\\n0\\\\\n-2\\\\\n1\\\\\n\\end{bmatrix}$$。\n\n还有别的给 $$\\begin{bmatrix}\nx_2\\\\\nx_4\\\\\n\\end{bmatrix}$$赋值的方法吗？很明显其余的赋值方法都可以被$$\\begin{bmatrix}\n1\\\\\n0\\\\\n\\end{bmatrix}$$和$$\\begin{bmatrix}\n0\\\\\n1\\\\\n\\end{bmatrix}$$的线性组合所覆盖，所以这两个解向量足够代表零空间的特征了，我们称这两个解向量为：**特解**。其特殊之处便在于给自由变量赋值为了$$\\begin{bmatrix}\n1\\\\\n0\\\\\n\\end{bmatrix}$$和$$\\begin{bmatrix}\n0\\\\\n1\\\\\n\\end{bmatrix}$$。\n\n通过**特解的任意倍的线性组合可以构造出整个零空间。**\n\n即$$Ax=0$$的所有解，或者说$$Ax=0$$中的 x 构成的零向量空间为：\n\n$$\nx=c\\begin{bmatrix}\n-2\\\\\n1\\\\\n0\\\\\n0\\\\\n\\end{bmatrix}+d\\begin{bmatrix}\n2\\\\\n0\\\\\n-2\\\\\n1\\\\\n\\end{bmatrix}\n$$\n\n### 算法总结\n\n对于一个$$m\\times n$$的矩阵 A，若其秩(R)为 r，那么就意味着其主变量为 r 个，而自由变量为 n-r 个。也就是只有 r 个方程起作用，而一共有 n 个变量 x，我们将其中的 n-r 个自由变量依次赋值为：$$\\begin{bmatrix}\n1\\\\\n0\\\\\n...\\\\\n0\\\\\n\\end{bmatrix},\\begin{bmatrix}\n0\\\\\n1\\\\\n...\\\\\n0\\\\\n\\end{bmatrix},...,\\begin{bmatrix}\n0\\\\\n0\\\\\n...\\\\\n1\\\\\n\\end{bmatrix}$$。接下来解方程求特解，将特解的任意倍进行线性组合就可以了。\n\n## 简化行阶梯形式\n\n上面的消元法看上去已经很完美了，但是最后一步解方程还有化简的余地，最后得到的 U 矩阵还可以被进一步化简。\n\n拿上面【例】中的 U 矩阵 $$\\begin{bmatrix}\n1 & 2 & 2 & 2\\\\\n0 & 0 & 2 & 4\\\\\n0 & 0 & 0 & 0\\\\\n\\end{bmatrix}$$ 为例，继续化简：\n\n- 首先向上消元，使主元列**除主元之外都是 0**：$$\\begin{bmatrix}\n  1 & 2 & 0 & -2\\\\\n  0 & 0 & 2 & 4\\\\\n  0 & 0 & 0 & 0\\\\\n  \\end{bmatrix}$$\n- 提出一列元素公倍数，**使主元均为 1**：$$R=2\\begin{bmatrix}\n  1 & 2 & 0 & -2\\\\\n  0 & 0 & 1 & 2\\\\\n  0 & 0 & 0 & 0\\\\\n  \\end{bmatrix}$$\n- 列交换，使左上角变为单位阵 I：$$2\\begin{bmatrix}\n  1 & 0 & 2 & -2\\\\\n  0 & 1 & 0 & 2\\\\\n  0 & 0 & 0 & 0\\\\\n  \\end{bmatrix}$$\n\n在矩阵中主元行和主元列的交汇处存在一个单位阵，通过“列交换”，可以将矩阵 R 中的主元列集中在左侧，从而在左上角形成这个单位阵，而将自由列集中在矩阵的右侧。如果矩阵 A 中的某些行是线性相关的，则在矩阵 R 的下半部分就会出现一些完全为 0 的行向量。\n\n![Linear_Algebra71](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/Linear_Algebra71.png)\n\n这里的$$I$$是一个$$r\\times r$$的方阵，F 即自由列消元后组成的部分。\n\n原方程$$Ax=0$$变为求解 R 的主元行乘以 x，$$\\begin{bmatrix}\nI & F\n\\end{bmatrix}\\begin{bmatrix}\nx_{pivot} \\\\ x_{free}\n\\end{bmatrix}=0$$\n\n我们将$$Ax=0$$的特解作为列向量写成矩阵$$N$$，即零空间矩阵。则其形式为 $$N=\\begin{bmatrix}\n\\\\\nI\n\\end{bmatrix}$$。这里的I为一个$$(n-r)\\times (n-r)$$的矩阵，就是对n-r个自由变量分别赋值1所构造出来的，零空间矩阵满足$$RN=0$$，这里的0是一个$$m\\times (n-r)$$的矩阵，则从矩阵分块乘法运算可知零空间矩阵上半部分为$$-F$$，即N的最终形式为$$N=\\begin{bmatrix}\n-F\\\\\nI\n\\end{bmatrix}$$。\n\n> 对于矩阵 R 而言，求零空间的特解就变得非常简单，只需要将消元得到的 F 部分拼接上单位矩阵就可以得到所有的通解。注意如果在变换出 R 左上角的单位矩阵的过程中如果采用的列变换，则在最后的解中也要完成相应的变换。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数06-列空间和零空间","url":"/2025/03/28/Linear_Algebra/线性代数-6/","content":"\n# Linear Algebra-列空间和零空间-06\n\n## 概要\n\n本节从之前学习的子空间开始，介绍了子空间的部分性质。并重点介绍了列空间与方程$$Ax=b$$之间的联系，并由此引出了零空间，根据$$Ax=b$$这个方程给出了两种构建子空间的方法。\n\n## 子空间\n\n### 子空间回顾\n\n首先我们回顾一下上次讲到的子空间。首先明确，**子空间必须对线性运算封闭。**我们从一个简单的向量空间：$$R^3$$空间开始。其图像如下，整个三维空间皆为$$R^3$$空间。\n\n![three_dimension](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/three_dimension.png)\n\n上一节中我们学习过，$$R^3$$的子空间就是如下三个（注：子空间必须包含原点，即零向量）：\n\n1. 穿过原点的无限延伸的平面 P；\n2. 穿过原点的无限延伸的直线 L；\n3. Z，原点；\n\n反映在图像上，即：\n\n![liekongjian1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/liekongjian1.png)\n\n很明显，子空间直线 L 或平面 P 上，任取两个向量相加，得到的向量仍在该子空间中。而且将其上的向量做数乘伸长或缩短一定倍数，其结果也还在该子空间中，所以它们都对线性运算封闭。\n\n### 子空间的“交”与“并”\n\n上面我们都是分别研究的两个子空间，那么接下来我们对两个空间之间联系的部分展开讨论。\n\n#### P∪L 空间\n\n我们还是聚焦于$$R^3$$的子空间 P 与 L，首先要研究的就是他们的并空间，即：现有一集合，包含了 P 与 L 中的所有向量，那么这个集合是子空间吗？\n\n答案是否定的。\n\n很明显，我们将直线 L 与平面 P 看做同一个集合 P∪L 之后，这个集合对线性运算并不封闭。比如我们随便在直线 L 上取一个向量 a，在平面 P 上取一个向量 b，此时向量 a+b 的方向就会夹在直线 L 与平面 P 之间，脱离了 P∪L 的范围，因此 P∪L 无法构成子空间。\n\n![liekongjian2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/liekongjian2.png)\n\n#### P∩L 空间\n\n如果看的是两个子空间的交集，那么上面那个$$R^3$$的例子就很合适。因为平面 P 与直线 L 只在原点相交，而原点显然是$$R^3$$的子空间之一。\n\n如果推广到任意两个子空间的交呢？假设现在有子空间 S 和 T，问其交集 S∩T 是否为子空间？\n\n这次答案是肯定的。\n\n为什么呢？抽象层面上来看，S∩T 的集合是比 S，T 限制条件更多的集合，相当于一个更小的集合，所以 S∩T 势必满足原本 S 和 T 的条件，所以可以构成一个子空间。\n\n## 列空间\n\n### 列空间回顾\n\n我们通过一个例子来回顾之前的内容。\n\n现有矩阵 $$A=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}$$，矩阵的列向量$$\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}$$均是$$R^4$$中的四维向量，所以**A的列空间是**$$R^4$$ **的子空间。**\n\n那么列空间里包含了什么呢？除了 $$\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}$$三个列向量，列空间里还包含着它们的各种线性组合。也就是说，A的列空间是由$$\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}$$ 三个列向量张开的一个子空间。\n\n那么这个子空间有多大呢？这就需要$$Ax=b$$方程来解释了。\n\n### Ax=b 的空间解释\n\n还是取 $$A=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}$$。假设有一个方程$$Ax=b$$ 如下：\n\n$$\nAx=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}=\\begin{bmatrix}\nb_1\\\\\nb_2\\\\\nb_3\\\\\nb_4\\\\\n\\end{bmatrix}=b\n$$\n\n**首先第一个问题**：这个方程是否始终有解？\n\n我们看到，Ax 的本质就是对 A 的列向量进行线性组合：\n\n$$\nAx=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}=x_1\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}+x_2\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}+x_3\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}\n$$\n\n或者可以认为，Ax 代表着 A 的列空间。\n\n显然，三个四维向量的线性组合是无法铺满整个四维空间的，就如同两个三维向量无法张开一个三维空间一样。所以，这里的 Ax 只能是$$R^4$$空间的部分子空间，也就是说，无法保证任意拿出一个四维向量 $$b=\\begin{bmatrix}\nb_1\\\\\nb_2\\\\\nb_3\\\\\nb_4\\\\\n\\end{bmatrix}\\in R^4$$，都能找到A列向量的一种线性组合，使$$Ax=b$$。\n\n**第二个问题**：什么样的 b 可以使方程 Ax=b 有解？\n\n上面介绍过，Ax 就表示着 A 列向量的所有线性组合，也就是 A 的列空间。上面提到，A 的列空间就是$$R^4$$的一个子空间，所以对于一个四维向量 b，只要 b 在“A 的列空间”这个$$R^4$$的子空间中，那么就可以找到一种 A 列向量的线性组合来构成 b。也就是使得 Ax=b 有解。\n\n**第三个问题**：能否去掉 A 的一列，却不影响 A 的列空间呢？\n\n先看看这三个列向量：$$\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}$$。显然第三列$$\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}$$可以写成前两列的线性组合：$$\\begin{bmatrix}\n2\\\\\n3\\\\\n4\\\\\n5\\\\\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}+\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}$$。也就是说这第三列对线性组合没有贡献。所以我们仅依靠前两列的线性组合就可以构成A的列空间。我们称$$\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}\\begin{bmatrix}\n1\\\\\n1\\\\\n1\\\\\n1\\\\\n\\end{bmatrix}$$ 这样的列为主列。所以去掉第三列，并不影响 A 的列空间的构成。\n\n## 零空间\n\n### 零空间介绍\n\n所谓零空间，就是$$Ax=0$$的所有解所构成的一个空间。\n\n还是以 $$A=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}$$ 为例，其零空间就是下面这个方程的解构成的空间：\n\n$$\nAx=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}=\\begin{bmatrix}\n0\\\\\n0\\\\\n0\\\\\n0\\\\\n\\end{bmatrix}=0\n$$\n\n也就是 $$x=\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}$$，可以看到x有三个分量，所以A的零空间是$$R^3$$ 的子空间。\n\n所以，对于$$m\\times n$$的矩阵来说，列空间是$$R^m$$的子空间，零空间是$$R^n$$的子空间。**列空间关键在于列空间的维数，零空间关键在于列向量的个数。**\n\n首先来验证这样的 $$\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}$$ 为什么能构成向量空间？\n\n1. 加法封闭：在此零空间中任取两向量 v,w，有 Av=Aw=0，很显然 A(v+w)=0，所以(v+w)也属于零空间，加法封闭得证；\n2. 数乘封闭：在此零空间中任取向量 v，Av=0，则 cAv=0。矩阵 A 与常数 c 位置可交换，所以 A(cv)=0。所以 cv 也在零空间中。数乘运算封闭得证。\n\n【例】求 $$A=\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}$$ 的零空间。\n\n我们讨论过，这个 A 的第三列可以写成前两列的线性组合，所以可以写出令 Ax=0 的一个解：$$\\begin{bmatrix}\n1\\\\\n1\\\\\n-1\\\\\n\\end{bmatrix}$$，而其零空间即为：$$C\\begin{bmatrix}\n1\\\\\n1\\\\\n-1\\\\\n\\end{bmatrix}$$(C表示任意常数)。反映在图像上，就是$$R^3$$ 中的一条穿过原点的直线。\n\n### Ax=b 的空间解释\n\n那如果上面构造零空间的方程右侧变为任意向量的话，其解集 x 还能构成向量空间吗？\n\n如：\n\n$$\n\\begin{bmatrix}\n1 & 1 & 2\\\\\n2 & 1 & 3\\\\\n3 & 1 & 4\\\\\n4 & 1 & 5\\\\\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\\\\\n\\end{bmatrix}\n$$\n\n这样的所有 x 构成的解集还是向量空间吗？\n\n显然不是。将 $$\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}=\\begin{bmatrix}\n0\\\\\n0\\\\\n0\\\\\n\\end{bmatrix}$$ 代入，其显然不是这个方程的解，就是说明这个解集里根本没有零向量。之前我们学过，任何一个向量集合中必须要有零向量。就是说明这个解集连最基本的要求都无法满足，构不成向量空间。\n\n反映在图像上，这里所有的 $$\\begin{bmatrix}\nx_1\\\\\nx_2\\\\\nx_3\\\\\n\\end{bmatrix}$$ 其实构成的是一个不过原点的平面。\n\n这也告诉我们，想从 x 的角度研究$$Ax=b$$这个方程，则只有 b 是零向量时，x 才能构成空间(零空间)，其他情况中连零向量都不在解集中，更别谈向量空间了。\n\n## 学习感悟\n\n这一节我们学习了列空间与零空间，从$$Ax=b$$入手，给出了两种构建子空间的方法：\n\n1. 从 A 的列向量入手，根据列向量的线性组合构造空间；\n2. 从$$Ax=0$$方程组入手，让 x 满足特定条件来构造子空间；\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"局域网 Git 搭建","url":"/2025/03/24/Git/局域网Git搭建/","content":"\n# 局域网 Git 搭建\n\n## 共享文件夹配置 Git 服务器\n\n本文说明在局域网中用一台电脑作为服务器，在服务器中创建一个文件夹，并设置共享。然后该文件夹作为公开的版本库，局域网内其他电脑都可以访问，这样可以实现统一的版本管理。\n\n## 配置公开版本库\n\n首先选取一个数据盘，在数据盘中建立一个文件夹，本例中的名称就是 git。\n\n- 在 git 目录下新建一个裸仓库名字为 rx_script,命令如下：\n\n```bash\ngit init --bare rx_script\n```\n\n> `git init --bare` 是 Git 里的一个常用命令，其作用是创建一个裸仓库。\n> **命令解析**\n> `git init` 用于初始化一个新的 Git 仓库。而 `--bare` 是 `git init` 的一个参数，添加这个参数后，创建的仓库就不会包含工作目录，只包含 Git 版本控制所需的元数据文件，如 `objects`（存储对象数据）、`refs`（存储引用信息）、`HEAD`（指向当前分支）等。\n> **主要作用**\n>\n> - **作为共享仓库**：在团队协作开发中，通常需要一个中央仓库来存储项目的代码，让团队成员能够共享代码。由于裸仓库没有工作目录，避免了工作目录可能带来的文件冲突、本地修改等问题，所以非常适合作为共享仓库。成员们可以将自己本地仓库的代码推送到这个裸仓库，也能从这里拉取其他成员的更新。\n> - **服务器端部署**：在服务器上部署 Git 仓库时，一般会使用裸仓库。服务器的主要功能是存储和管理代码，并不需要实际的工作目录。使用裸仓库可以减少服务器的资源占用，提高性能。\n> - **版本控制与备份**：裸仓库保存了项目的完整版本历史记录，可用于对项目进行版本控制和备份。即使本地仓库出现问题，也能从裸仓库恢复到任意一个历史版本。\n\nrx_script 目录结构如下：\n\n![LMWPbBh5goked9xJlaJcvV6Lnpg](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/LMWPbBh5goked9xJlaJcvV6Lnpg.png)\n\n- 设置 git 文件夹为共享文件夹\n\n右键 git 文件夹，属性：\n\n![WtwBbu2uroip2LxIOYLciZ3dneh](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/WtwBbu2uroip2LxIOYLciZ3dneh.png)\n\n- 用户设置为 everyone，并进行共享\n\n![GT3Fb5PNYonC8vxVseTcOvX9nBf](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/GT3Fb5PNYonC8vxVseTcOvX9nBf.png)\n\n- 此时文件夹属性中就有一个网络路径：\n\n![TW3fbKXh2oCfuHxeW0ncZ3nYnSg](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/TW3fbKXh2oCfuHxeW0ncZ3nYnSg.png)\n\n## 客户端\n\n- 在客户端，右键我的电脑-> 映射网络驱动器：\n\n![LDKKbn8h5opAFyxrSx7cviNPnAd](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/LDKKbn8h5opAFyxrSx7cviNPnAd.png)\n\n- 此时会发现电脑下多了个 Y 盘。Y 盘就是公开文件夹：\n\n![MDzpbsImToKDg1xd7ATcM03rnpj](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img/MDzpbsImToKDg1xd7ATcM03rnpj.png)\n\ngit 就是公开版本库\n\n## 测试\n\n在各自需要同步的电脑上，创建本地版本库，并于远端进行关联即可。\n\n比如我要在\"D:\\proj\\scrpit\"路径下去关联版本库，仅需：\n\n```bash\ngit init\ngit remote add origin Y:\\\\rx_script\n```\n\n后续完成\"git add\"，\"git commit\"，“git push”等操作后即完成了对仓库的初始化。\n\n> 考虑到仓库大小，最好第一次上库的时候就添加.gitignore 文件，避免跟踪过多不必要的文件。\n\n在仓库第一次初始化完后，后续接入的电脑仅需：\n\n```bash\ngit init\ngit remote add origin Y:\\\\rx_script\ngit fetch\n```\n\n即可完成仓库的同步。\n","tags":["Git"],"categories":["Git"]},{"title":"线性代数05-转置矩阵与向量空间","url":"/2025/03/16/Linear_Algebra/线性代数-5/","content":"\n# Linear Algebra-转置矩阵与向量空间-05\n\n## 概要\n\n本节我们再谈置换矩阵与转置矩阵，并介绍对称矩阵，之后便进入学习线代的关键所在：向量空间与子空间。\n\n## 置换矩阵\n\n### 回顾\n\n所谓的置换矩阵 P，就是用来完成行交换的矩阵，更具体地说，是行重新排列了的单位矩阵。例如 I 就是一个置换矩阵，只不过 I 对矩阵没影响。\n\n那么对于 n 阶矩阵来说，有多少个置换矩阵呢？答案是：n!种，也就是将单位矩阵 I 各行重新排列后所有可能的情况的数量。\n\n置换矩阵的另一个优点就是可逆，因为置换矩阵各行还原后可以得到单位矩阵。而且对于置换矩阵 P，有$$PP^T=I$$，也就是$$P^{-1}=P^{T}$$。\n\n这个性质其实很好理解，首先明确，P 是置换矩阵，因此 P 的每个列向量中只有一个分量是 1，其余分量均是 0。而既然要求$$PP^{-1}=I$$，那就**说明**$$P$$**中每一行的行向量与**$$P^{-1}$$**中每一列的列向量的数量积为 1，也就意味着**$$P$$**中每一行与**$$P^{-1}$$**中每一列中分量 1 出现的位置相同**，也就是$$P$$与$$P^{-1}$$沿对角线对称，所以$$P^{-1}=P^{T}$$。\n\n### 置换矩阵的使用\n\n在讲消元法的时候，主元位置为 0 是一件很让人头疼的事，这时就需要置换矩阵 P 来完成行交换，确保消元过程顺利进行。上节学习$$A=LU$$分解时，我们没有考虑要交换行的过程，如果我们想写出更普适的 LU 分解式的话，必须把行交换情况考虑进去，即：$$PA=LU$$，先用行交换使得主元位置不为 0，行顺序正确，其后再使用 LU 分解。\n\n## 转置矩阵\n\n### 转置矩阵回顾\n\n之前简单介绍过转置矩阵，即：\n\n$$\nA=\\begin{bmatrix}\n1 & 3\\\\\n2 & 3\\\\\n4 & 1\\\\\n\\end{bmatrix},A^T=\\begin{bmatrix}\n1 & 2 & 4\\\\\n3 & 3 & 1\\\\\n\\end{bmatrix}\n$$\n\n用符号来表示就是对$$A$$矩阵以及$$A^T$$矩阵中每一个元素，都有：\n\n$$\n(A^T)_{ij}=A_{ji}\n$$\n\n也就是说，转置矩阵中，行元素与列元素交换了，理解转置很简单。\n\n### 对称矩阵\n\n对称矩阵，顾名思义，就是主对角线两侧元素对应相等的矩阵。或者说，对于矩阵 A，如果有$$A=A^T$$，那么矩阵 A 就是一个对称矩阵，如 $$\\begin{bmatrix}\n3 & 1 & 7\\\\\n1 & 2 & 9\\\\\n7 & 9 & 4\\\\\n\\end{bmatrix}$$。\n\n那么我们如何获取到对称矩阵呢？很简单，矩阵$$A$$与$$A^T$$相乘得到的方阵一定是对称矩阵，因为我们从对称矩阵的定义来看，取$$(A^TA)^T$$，根据转置的运算规律，可知$$(AB)^T=B^TA^T$$，所以有：\n\n$$\n(A^TA)^T=A^TA^{TT}=A^TA\n$$\n\n所以任何的$$A^TA$$，转置仍然是其本身，故称为对称矩阵。\n\n## 向量空间与子空间\n\n### 向量空间\n\n首先明确“向量空间”的概念，它表示一整个空间的向量，但是要注意，不是任意向量的集合都能被称为向量空间。所谓的向量空间，必须满足一定规则，就是：**该空间对线性运算(相加，数乘)封闭**。类似：v->3v 或者 v, w-> v+w 运算，若得到的 3v 或者 v+w 都仍然在此空间中，则这个空间可称为向量空间。\n\n举个例子，$$R^2$$就是一个向量空间，其中的向量均为二维实向量。在$$R^2$$上就存在线性组合，我们举例说明：\n\n$$\\begin{bmatrix}\n3\\\\\n2\\\\\n\\end{bmatrix},\\begin{bmatrix}\n0\\\\\n0\\\\\n\\end{bmatrix},\\begin{bmatrix}\n\\pi\\\\\ne\\\\\n\\end{bmatrix}$$均在$$R^2$$的实数二维向量空间中，对它们做线性运算，得到的结果仍然在$$R^2$$ 空间中。\n\n![transport_matrix0](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix0.png)\n\n显然，$$R^2$$的向量空间可以构成一个平面，即是图上的 xoy 平面。这个向量空间存在的关键在于上图中平面上任何向量都在$$R^2$$向量空间中，尤其是**零向量**。因为线性运算是“数乘”“相加”，任何向量乘上 0 或者加上其反向向量后得到的都是零向量，所以它必然存在于所有向量空间中，这一点十分重要。\n\n同样，推广到$$R^3$$空间，$$R^3$$中是三维的向量，每个分量均为实数，例如 $$\\begin{bmatrix}\n3\\\\\n2\\\\\n0\\\\\n\\end{bmatrix}$$，这样的向量就在$$R^3$$ 空间中。\n\n再进行推广，$$R^n$$空间中包括所有的 n 维向量，每个列向量有 n 个分量，且分量均为实数。\n\n再举一个不是向量空间的例子：\n\n还是$$R^2$$空间中，但是这次我们只取第一象限内的区域 D：\n\n![transport_matrix1](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix1.png)\n\n显然，这部分空间无法满足“线性组合仍在空间中”的要求，比如数乘运算时，随便取个负数，向量就会跑到第三象限去，脱离 D 空间范围内了。\n\n### 子空间\n\n上面的反例已经证明，在向量空间里随便取其一部分，很可能得到的不是向量空间。那如果我们取向量空间的一部分，构成的有没有可能是向量空间呢？ 答案是有的，这样还能构成向量空间的部分我们称之为子空间，还是以$$R^2$$为例：\n\n![transport_matrix2](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix2.png)\n\n如图，整个坐标平面表示的就是原向量空间$$R^2$$，而这条**穿过原点的直线**就是$$R^2$$的子空间之一。检验一下这条直线上的任意向量，他们的“数乘”，“相加”运算结果全部仍在这条直线上，这就构成了一个子空间。而如果这条直线不过原点，那么零向量都不在这个空间中，就更别谈什么子空间了。\n\n那$$R^2$$空间中，还有没有其他的子空间呢？既然我们这么强调零向量，那就让它单独成一个空间就好了。记为 Z，其中之后一个零向量，它也是$$R^2$$的子空间之一。\n\n再稍微推广一下，$$R^3$$的子空间就是如下三个：\n\n1. 穿过原点的平面；\n2. 穿过原点的直线；\n3. Z，原点；\n\n### 列空间\n\n上面介绍的子空间都是基于已知的图像来寻找的，接下来我们**通过具体的矩阵来构造一个子空间**，比如：列向量构造出的列空间。\n\n我们以 $$A=\\begin{bmatrix}\n1 & 3\\\\\n2 & 3\\\\\n4 & 1\\\\\n\\end{bmatrix}$$为例。首先能看出来，各列向量$$\\begin{bmatrix}\n1\\\\\n2\\\\\n4\\\\\n\\end{bmatrix},\\begin{bmatrix}\n3\\\\\n3\\\\\n1\\\\\n\\end{bmatrix}$$均属于$$R^3$$，而且由这两个向量张开的子空间必须满足“线性运算封闭”这一性质。也就是说$$\\begin{bmatrix}\n1\\\\\n2\\\\\n4\\\\\n\\end{bmatrix},\\begin{bmatrix}\n3\\\\\n3\\\\\n1\\\\\n\\end{bmatrix}$$以及它们的线性组合构成了一个$$R^3$$ 的子空间，我们称之为：列空间，记为 C(A)。\n\n![transport_matrix3](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/transport_matrix3.png)\n\n因为 $$\\begin{bmatrix}\n1\\\\\n2\\\\\n4\\\\\n\\end{bmatrix},\\begin{bmatrix}\n3\\\\\n3\\\\\n1\\\\\n\\end{bmatrix}$$ 不在同一条直线上，所以，这个列空间表现在图像上，就是**一个过原点与这两个列向量的平面**。\n\n两个向量 $$\\begin{bmatrix}\n1\\\\\n2\\\\\n4\\\\\n\\end{bmatrix},\\begin{bmatrix}\n3\\\\\n3\\\\\n1\\\\\n\\end{bmatrix}$$以及它们的所有线性组合都在这个二维平面上，构成一个空间。这里需要我们好好理解，用教授的话说“$$R^3$$情况下还可以作图，但是更高维的类似于$$R^{10}$$情况你要怎么办？譬如求$$R^{10}$$ 空间中 5 个向量线性组合是什么样的？如果不共线，我们就可以类似地理解为一个十维空间中的五维平面之类的东西。”\n\n这里还要注意列向量之间的性质，如果列向量之间就是共线的，那么其列空间就是一条过原点的直线。\n\n## 学习感悟\n\n这节介绍了向量空间和子空间，并由子空间引出了通过具体的列向量构成的空间—列空间。如何理解空间的概念非常重要，本节中对低维的空间做了图，目的是便于我们理解“空间”这一概念。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"芯片的工艺角","url":"/2025/03/16/IC/Basic/芯片的工艺角/","content":"\n# 芯片的工艺角\n\n## **芯片领域中的工艺角：概念与原理**\n\n在芯片设计中，“工艺角”（Process Corner）通常指的是制造过程中由于工艺参数的离散性（例如阈值电压、栅极氧化层厚度、掺杂浓度等）而造成的晶体管性能差异。**不同的工艺角会导致芯片在速度、功耗等方面出现差异**。为了保证芯片在各种可能的制造偏差条件下都能正常工作，设计工程师会在仿真阶段对不同工艺角进行分析和验证。\n\n### **1. 什么是工艺角？**\n\n工艺角（Process Corner）可以理解为在晶圆制造工艺允许的范围内，器件性能的最坏或最好情况的组合。通常用几个关键词来描述：\n\n- **SS（Slow-Slow）**：NMOS 和 PMOS 都是“最慢”工艺角。\n- **FF（Fast-Fast）**：NMOS 和 PMOS 都是“最快”工艺角。\n- **TT（Typical-Typical）**：NMOS 和 PMOS 都是“典型”工艺角。\n- **SF（Slow-Fast）**：NMOS 慢、PMOS 快。\n- **FS（Fast-Slow）**：NMOS 快、PMOS 慢。\n\n这里的“慢”和“快”并不是指实际的时钟速度，而是**指器件的特性**：阈值电压较高时，器件会偏慢；阈值电压较低时，器件会偏快。\n\n![NXz3bLJ0IoffE9xsET2cQNhln1e](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/NXz3bLJ0IoffE9xsET2cQNhln1e.png)\n\n### **2. 为什么要考虑工艺角？**\n\n半导体制造过程中不可避免地会有一定的工艺波动（Process Variation）。如果只针对“典型”工艺角进行设计和验证，那么在实际制造时可能会遇到比典型情况更差或更好的器件性能，从而造成电路无法正常工作、功耗或速度不达标等问题。\n\n- **在慢角（SS）下**：器件速度变慢，电路延迟增加；同时器件阈值电压通常更高，漏电流更小，静态功耗会有所降低，但动态功耗也会因为速度减慢而有不同表现。\n- **在快角（FF）下**：器件速度加快，电路延迟降低；但阈值电压通常更低，漏电流更大，可能导致静态功耗上升。\n\n因此，设计工程师需要在快角、慢角等极端情况下进行时序和功耗分析，以确保芯片在这些最坏或最好条件下依然能够正常工作。\n\n---\n\n## **其他影响芯片性能的因素：电压与温度**\n\n除了工艺本身的差异外，芯片在不同电压和温度下的性能也会发生变化。为了全面反映芯片的工作范围，工程师通常会考虑**PVT（Process、Voltage、Temperature）三个因素的组合，也称为PVT Corners**。\n\n- **电压（Voltage）**：工作电压的上限和下限会影响晶体管的驱动能力和漏电流。\n- **温度（Temperature）**：高温会增加漏电流、减小迁移率，导致器件速度下降；低温则可能使器件速度上升。\n\n因此，芯片设计通常要在最坏和最好的电压、温度条件下进行时序和功耗分析，确保芯片能够在整个 PVT 范围内可靠工作。\n\n---\n\n## **工艺角可能造成的影响**\n\n### **对 PIN 信号的影响**\n\n不同工艺角会影响 **信号完整性、时序、功耗和驱动能力**，对 **输入（Input）** 和 **输出（Output）** PIN 均有影响。\n\n#### **(1) 数字信号 PIN**\n\n**影响因素：**\n\n- **传播延迟（Propagation Delay）**\n\n  - **FF 工艺角**：MOSFET 开关速度快，延迟最短，可能导致时序收敛困难，甚至产生 **赛道竞争（Race Condition）** 问题。\n  - **SS 工艺角**：MOSFET 速度慢，延迟最长，可能导致 Setup 时间（Tsetup）或 Hold 时间（Thold）违例，影响时序可靠性。\n- **上升/下降时间（Rise/Fall Time）**\n\n  - FF 工艺角时，边沿更陡，可能导致高频噪声更强。\n  - SS 工艺角时，边沿变缓，可能影响高速通信接口，如 **DDR、PCIe** 等。\n- **电平阈值（Logic Threshold）**\n\n  - 不同工艺角会导致输入信号的**高低电平阈值变化**，影响输入信号的识别可靠性。\n\n#### **(2) 模拟信号 PIN**\n\n**影响因素：**\n\n- **增益与失真（Gain & Distortion）**\n\n  - FF 工艺角：MOSFET 的跨导（gm）更大，增益可能变高，但非线性失真也可能增大。\n  - SS 工艺角：跨导变小，增益可能下降，影响放大器性能。\n- **输入偏置电流（Input Bias Current）**\n\n  - FF 工艺角：漏电流增加，输入偏置电流可能增大，影响高阻抗模拟电路（如 ADC、运放）。\n  - SS 工艺角：偏置电流较小，但可能增加噪声。\n- **带宽和相位裕量**\n\n  - FF 工艺角：MOSFET 速度快，带宽可能增加，但相位裕量可能降低，导致不稳定。\n  - SS 工艺角：带宽下降，信号可能变得更慢，影响 ADC 采样率。\n\n---\n\n### **对干扰（EMI/噪声）的影响**\n\n工艺角会影响 **电磁干扰（EMI）、串扰（Crosstalk）和电源噪声（Power Noise）**，进而影响 PIN 信号的稳定性。\n\n#### **(1) 电磁干扰（EMI）**\n\n- **FF 工艺角**：\n\n  - MOSFET 速度快，信号切换更陡峭，高频分量更强，容易产生更强的 EMI。\n  - 需要额外考虑 **PCB 走线屏蔽、地弹噪声（Ground Bounce）** 及 **去耦电容（Decoupling Cap）** 的优化。\n- **SS 工艺角**：\n\n  - 由于信号上升/下降时间变慢，EMI 相对较弱，但会导致信号质量下降，如**眼图（Eye Diagram）收缩**。\n\n#### **(2) 串扰（Crosstalk）**\n\n- **FF 工艺角**：\n\n  - 信号上升时间短，高频分量增加，容易导致相邻信号线（特别是高速总线，如 DDR）之间的串扰增强。\n  - 需要增加 **信号屏蔽、差分走线** 或调整 PCB 布局。\n- **SS 工艺角**：\n\n  - 信号传播时间变长，串扰相对较弱，但过慢的信号可能影响数据传输速率。\n\n#### **(3) 电源噪声（Power Noise）**\n\n- **FF 工艺角**：\n\n  - 由于开关速度快，电流突变更剧烈，容易引起 **电源纹波（Power Ripple）** 和 **地弹噪声（Ground Bounce）**，导致信号抖动（Jitter）。\n  - 需要优化电源去耦和 LDO/电感的设计。\n- **SS 工艺角**：\n\n  - 电流变化较小，电源噪声较低，但电路性能可能不足，如振荡器频率下降、PLL 锁定时间变长。\n\n### 典型案例\n\n|              应用              |             FF 影响              |            SS 影响             |\n| :----------------------------: | :------------------------------: | :----------------------------: |\n| 高速数字接口（DDR, PCIe, USB） |    EMI 增加，可能出现信号反射    |    速度变慢，数据吞吐量下降    |\n|            ADC/DAC             |        增益偏移，噪声增大        |     带宽变小，响应速度下降     |\n|         PLL（锁相环）          |   锁定时间缩短，但相位噪声增加   | 锁定时间变长，可能无法正常工作 |\n|     电源管理（LDO, DC-DC）     | 纹波增大，可能需要更大的去耦电容 |       稳压变慢，响应滞后       |\n\n---\n\n## **设计优化策略**\n\n### **(1) 数字电路优化**\n\n- 采用 **静态时序分析（STA）**，确保在 **SS 工艺角** 仍满足时序要求。\n- 在 FF 角测试 **EMI**，如果过大，可调整信号上升时间（如插入小电容）。\n- 适当调整 **驱动强度**，减少串扰影响。\n\n### **(2) 模拟电路优化**\n\n- 在 **SS 工艺角** 下确保带宽足够，避免增益衰减影响信号质量。\n- 在 **FF 工艺角** 下关注功耗和失真，避免 MOSFET 过驱动。\n\n### **(3) 电源优化**\n\n- 采用 **更好的去耦电容（如 X7R/X5R 陶瓷电容）**，减少电源噪声。\n- 在 PLL 设计中，优化 **环路滤波器（Loop Filter）** 以适应不同工艺角。\n- 适当增加 **电源裕量（Voltage Margining）**，确保不同工艺角下都能稳定工作。\n\n---\n\n## **总结**\n\n工艺角（TT、SS、FF）不仅影响芯片的核心逻辑，还会对 **PIN 信号质量、EMI、串扰、电源噪声** 等方面产生显著影响：\n\n- **FF 工艺角**：信号快、噪声大、功耗高、串扰强，时序更紧张。\n- **SS 工艺角**：信号慢、功耗低、噪声小，但可能影响电路性能。\n- **SF/FS 工艺角**：主要影响模拟电路的 P/N 不匹配问题，如放大器失调。\n\n在设计时，需要 **PVT（Process-Voltage-Temperature）联合仿真**，并针对不同工艺角进行 **时序分析、信号完整性优化、去耦设计**，确保系统可靠运行。\n\n在半导体工艺不断缩进（如从 7nm 向 5nm、3nm 演进）的过程中，器件的工艺波动日益显著，对设计的精细化管理也提出了更高要求。只有深入理解并有效应对工艺角的挑战，才能在芯片设计中保证高良率、高性能和低功耗，为最终产品提供可靠的技术支撑。\n","tags":["Basics"],"categories":["IC","Basics"]},{"title":"线性代数04-矩阵LU分解","url":"/2025/03/16/Linear_Algebra/线性代数-4/","content":"\n# Linear Algebra-矩阵的 LU 分解-04\n\n## 概要\n\n这一节首先完善之前讲到的逆矩阵内容，然后使用消元矩阵介绍 A 的 LU 分解，即将矩阵 A 分解为矩阵 L 与上三角矩阵 U，介绍这种运算的普遍规律。最后再一次提起之前介绍的“行交换矩阵”，引入置换矩阵的概念。\n\n## 逆矩阵性质补充\n\n首先考虑一个问题：如果 A，B 都是可逆矩阵的话，AB 的逆矩阵是什么呢？这个问题并不复杂，想求出逆矩阵，无非就是令$$AB\\times(AB)^{-1}=I$$，而我们不难想到$$ABB^{-1}A^{-1}=I$$，因此有：\n\n$$\n(AB)^{-1}=B^{-1}A^{-1}\n$$\n\n由于下一章中要涉及到矩阵的转置问题，我们在这里一起讨论矩阵转置和矩阵的逆的关系。\n\n首先介绍一下转置矩阵，转置矩阵就是将原矩阵各行转换为各列所得到的新矩阵，如：\n\n$$\nA=\\begin{bmatrix}\n1 & 2\\\\\n3 & 4\\\\\n4 & 1\n\\end{bmatrix},A^T=\\begin{bmatrix}\n1 & 3 & 4\\\\\n2 & 4 & 1\n\\end{bmatrix}\n$$\n\n接下来我们看看转置矩阵和逆矩阵有什么联系。说到逆矩阵，最经典的式子无非就是$$AA^{-1}=I$$。为了找到转置矩阵$$A^T$$与逆矩阵$$A^{-1}$$间的关系，我们对$$AA^{-1}=I$$两边同时进行转置运算，得到：\n\n$$\n(AA^{-1})^T=(A^{-1})^TA^T=I\n$$\n\n为什么$$(A^{-1})^T$$会变换到$$A^T$$的前面来呢？我们用非方阵 A 来理解一下这个过程，假设 A 是一个 $$3\\times 4$$的矩阵，则A的右逆$$A^{-1}$$是一个$$4\\times 3$$的矩阵，二者相乘是一个 $$3\\times 3$$ 的单位矩阵。\n\n对其求转置，如果$$A^T$$在$$(A^{-1})^T$$前面，则会得到一个 $$4\\times 4$$ 的单位矩阵，矛盾。\n\n再次观察此式：$$(A^{-1})^TA^T=I$$，由于 A 是方阵，则$$A^{T}$$必然也是方阵，那么我们就能得到$$A^T$$的逆矩阵，即为$$(A^{-1})^T$$，也就是说：$$(A^T)^{-1}=(A^{-1})^T$$\n\n这个结果告诉我们：**对于单个矩阵，转置和取逆两个运算顺序可以颠倒。**\n\n## 矩阵的 LU 分解\n\n我们熟悉的消元法都是直接使用行变换得来的，而由于消元矩阵的存在，说明用矩阵乘法也可以达到与之一样的消元效果。所以，现在假设有可逆矩阵 A，如果有：$$A-初等行变换->U(上三角矩阵)$$，就一定有类似于这样的形式：$$E\\times A=U$$的等式存在，使 A 相当于进行了初等行变换成为了 U。而我们已经学习了逆矩阵，E 这样的矩阵一定有逆矩阵，因为它本身就是由单位阵变化过来的。所以$$E\\times A=U$$可以写成$$A=E^{-1}\\times U$$。这一形式即为$$A=LU$$形式，这个过程就是 LU 分解过程。\n\n那么**矩阵 L(下三角矩阵)**是否有什么特别之处呢？我们可以通过一道例题来探讨下：\n\n【例】现有$$E_{32}E_{31}E_{21}A=U$$，已知 $$E_{32}=\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & -5 & 1\\\\\n\\end{bmatrix}$$，$$E_{21}=\\begin{bmatrix}\n1 & 0 & 0\\\\\n-2 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{bmatrix}$$，$$E_{31}=I$$，求$$A=LU$$ 分解后的 L。\n\n思路：\n\n1. 逆矩阵化简为$$A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U$$；\n2. 后面计算各个矩阵：$$E_{21}^{-1}=\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   2 & 1 & 0\\\\\n   0 & 0 & 1\\\\\n   \\end{bmatrix}$$，$$E_{32}^{-1}=\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & 1 & 0\\\\\n   0 & 5 & 1\\\\\n   \\end{bmatrix}$$\n3. 直接带入计算：$$L=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}=\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   2 & 1 & 0\\\\\n   0 & 5 & 1\\\\\n   \\end{bmatrix}$$\n\n观察发现，L 具有一个非常重要的特点，L 矩阵中各个元素都是$$E_{21}^{-1}$$与$$E_{32}^{-1}$$中对应位置的元素。\n\n以上的结论给了我们启示，在使用$$A=LU$$分解矩阵的时候，我们只需要从 U 入手，反过来考虑：**看如何通过行变换可以将上三角矩阵 U 变回 A，然后再将单位阵按此形式变化，就得到了 L 矩阵。**这个性质也是$$A=LU$$形式分解矩阵的最大优点。\n\n### LU 分解意义\n\n对于线性方程组 $$Ax = b$$，当矩阵 A 可以进行 LU 分解$$A = LU$$时，原方程组可转化为 $$LUx = b$$。令 $$Ux = y$$，则先求解 $$Ly = b$$（因为 L 是下三角矩阵，求解相对容易，可通过前代法逐步计算），得到 y；再求解 $$Ux = y$$（U 是上三角矩阵，可通过回代法求解），从而得到原方程组的解 x。相比于直接求解 $$Ax = b$$，这种方法在计算量上通常更具优势，尤其是对于大型矩阵，可显著减少计算量和计算时间。\n\n### 运算量\n\n以上，我们已经学会了 A=LU 分解矩阵方法，那么现在有一个额外问题，就是消元的运算量问题，比如现在我们有一个 $$100\\times 100$$ 的大矩阵(无 0 元素)。我们需要运算(将一个数乘系数后加到另一数上消元，每一个这样的过程称为一次运算)多少次后，才能将其化为上三角矩阵呢？\n\n这个问题我们先从列的角度进行考虑，第一列消元运算结束后，矩阵将会变成 $$\\begin{bmatrix}\n1 & ... & ... & ...\\\\\n0 & ... & ... & ...\\\\\n... & ... & ... & ...\\\\\n0 & ... & ... & ...\\\\\n\\end{bmatrix}$$的形式，这一步中，第一列的元素运算了100次，而第一行一共有100个元素，于是仅第一行与第一列的消元结束后，我们就运算了$$100^2$$次。之后我们要研究的就变成了剩下的 $$99\\times 99$$的矩阵。以此类推，最后的运算量为：$$\\sum_{k=1}^{n}k^2$$\n\n这种写法看上去比较难计算，我们可以根据微积分中学到的知识，加入我们计算的不是离散点之和，而是连续区域上函数的黎曼和的话，我们可以通过积分来计算区域面积值的和。我们可以采用积分来估计和，也就是这样估算：$$\\sum_{k=1}^{n}k^2=\\int_{1}^{n}x^2dx$$。\n\n## 置换矩阵\n\n我们之前接触过行变换所用到的矩阵，即是将单位阵 I 按照对应行变换方式进行操作之后得到的矩阵。它可以交换矩阵中的两行，代替矩阵行变换。什么时候我们需要使用矩阵行变换呢？一个经典的例子就是：在消元过程中，当矩阵主元位置上面为 0 时，我们就需要用行变换将主元位置换位非 0 数。\n\n这样的由单位阵变换而来的矩阵，通过矩阵乘法可以使被乘矩阵行交换。我们将这样的矩阵称为置换矩阵 P。我们通过一个例子来熟悉一下置换矩阵。\n\n【例】求矩阵 $$\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{bmatrix}$$ 的所有置换矩阵，并判断其性质。\n\n一共有 6 个置换矩阵：\n\n$$\n\\begin{bmatrix}1 & 0 & 0\\\\0 & 1 & 0\\\\0 & 0 & 1\\\\\\end{bmatrix}\\begin{bmatrix}0 & 1 & 0\\\\1 & 0 & 0\\\\0 & 0 & 1\\\\\\end{bmatrix}\\begin{bmatrix}1 & 0 & 0\\\\0 & 0 & 1\\\\0 & 1 & 0\\\\\\end{bmatrix}\\begin{bmatrix}0 & 1 & 0\\\\0 & 0 & 1\\\\1 & 0 & 0\\\\\\end{bmatrix}\\begin{bmatrix}0 & 0 & 1\\\\0 & 1 & 0\\\\1 & 0 & 0\\\\\\end{bmatrix}\\begin{bmatrix}0 & 0 & 1\\\\1 & 0 & 0\\\\0 & 1 & 0\\\\\\end{bmatrix}\n$$\n\n这可以理解为一个群，很明显，我们任取两个矩阵相乘，结果仍在这个群中。\n\n> 推广到 n 阶矩阵，n 阶矩阵有(n!)个置换矩阵，就是将单位矩阵 I 各行重新排列后所有可能的情况数量。其中(n!)的计算过程如下：首先单看第一行，有 n 种选择，其次看第二行，有(n-1)中选择，依次到最后一行，因此一共有(n!)个置换矩阵。\n\n## 学习感悟\n\n本节我们对矩阵的转置、逆矩阵的性质进行了部分介绍，学习了矩阵的 LU 分解，了解了这种分解方式的优点所在，并学会了直接构造 L 矩阵，简化消元过程。\n\n![matrix_lu_xmind](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/matrix_lu_xmind.png)\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数03-矩阵乘法和逆矩阵","url":"/2025/03/16/Linear_Algebra/线性代数-3/","content":"\n# Linear Algebra-乘法和逆矩阵-03\n\n## 知识概要\n\n前面介绍了向量与矩阵之间的乘法，这一节我们要介绍两个矩阵之间的乘法，并讨论逆矩阵存在的条件。最后介绍了求解逆矩阵的方法。\n\n## 矩阵乘法\n\n### 矩阵乘法最常见求解方式\n\n首先了解下矩阵之间进行乘法时，我们是如何求解单个元素的呢？\n\n以$C=A\\times B$为例，矩阵 C 中第 i 行第 k 列的元素等于矩阵 A 的第 i 行元素与矩阵 B 的第 k 列对应元素乘积之和。\n\n设矩阵 A 是一个 $3\\times4$的矩阵，矩阵B是一个$4\\times4$的矩阵，根据矩阵乘法规则，它们的乘积$C = AB$是一个 $3\\times4$的矩阵。其计算公式为：$$c_{ik}=\\sum_{j = 1}^{4}a_{ij}b_{jk}=a_{i1}b_{1k}+a_{i2}b_{2k}+a_{i3}b_{3k}+a_{i4}b_{4k}$$\n\n推广到一般：$$C_{ij}=(A的第i行)\\cdot(B的第j列)=\\sum_{k=1}^{n}a_{ik}b_{kj}$$\n\n需要注意的是矩阵的规格问题，从向量点乘的角度看，**A 的列数必须要与 B 的行数相同**。\n\n### 列组合与行组合方式\n\n#### 列组合\n\n上一节我们学习到，矩阵与列向量的乘积，结果是一个列向量，该列向量可视为矩阵各列的线性组合。\n\n那我们在计算矩阵间的乘法时，**B 矩阵中的各列其实就是用来组合 A 矩阵的各列向量**。其中$$b_{0},b_{1}$$等分别是 B 矩阵的列向量：\n\n$$\nA\\times B = A\\times \\begin{bmatrix}\nb_{0} & b_{1} & b_{2} & b_{3}\\end{bmatrix}=\\begin{bmatrix}\nAb_{0} & Ab_{1} & Ab_{2} & Ab_{3}\\end{bmatrix}=C\n$$\n\n该方法关键在于将右侧矩阵 B 看做列向量的线性组合，将问题转化为矩阵与向量的乘法问题。表明了矩阵 C 就是矩阵 A 中各列向量的线性组合，而 B 其实是在告诉我们，要以什么样的方式组合 A 中的列向量。\n\n#### 行组合\n\n同理，我们还学过行向量与矩阵的乘法，得到一个行向量。\n\n$$\n\\begin{bmatrix}\n   m & n & k\n\\end{bmatrix}\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\\\\\n   a_{2,1} & a_{2,2} & a_{2,3}\\\\\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix}=m\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\n\\end{bmatrix}+n\\begin{bmatrix}\n   a_{2,1} & a_{2,2} & a_{2,3}\n\\end{bmatrix}+k\\begin{bmatrix}\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix}\n$$\n\n因此这次就把矩阵 A 看做行向量的组合就行了，其中$$a_{0}^{T},a_{1}^{T}$$分别是 A 的行向量：\n\n$$\nA\\times B=\\begin{bmatrix}\n   a_{0}^{T} \\\\\n   a_{1}^{T} \\\\\n   a_{2}^{T}\n\\end{bmatrix}\\times B=\\begin{bmatrix}\n   a_{0}^{T}\\times B \\\\\n   a_{1}^{T}\\times B \\\\\n   a_{2}^{T}\\times B\n\\end{bmatrix} = C\n$$\n\n即矩阵 B 各行的线性组合组成了 C 的各行。\n\n### 列乘以行\n\n常规方法中，计算$A\\times B=C$的矩阵乘法时，使用 A 的行向量乘上 B 的列向量得到 C 中各个位置的元素。\n\n而我们这次介绍的方法，是用 A 的列向量乘以 B 的行向量，得到各个矩阵，再将矩阵相加，得到 C。\n\n我们通过一个例子来说明：\n\n【例】求解 $$\\begin{bmatrix}\n2 & 7\\\\\n3 & 8\\\\\n4 & 9\n\\end{bmatrix}\\begin{bmatrix}\n1 & 6\\\\\n1 & 2\n\\end{bmatrix}$$\n\n列乘行方法：\n\n$$\n\\begin{bmatrix}\n2 & 7\\\\\n3 & 8\\\\\n4 & 9\n\\end{bmatrix}\\begin{bmatrix}\n1 & 6\\\\\n1 & 2\n\\end{bmatrix}=\\begin{bmatrix}\n2\\\\\n3\\\\\n4\n\\end{bmatrix}\\begin{bmatrix}\n1 & 6\n\\end{bmatrix}+\\begin{bmatrix}\n7\\\\\n8\\\\\n9\n\\end{bmatrix}\\begin{bmatrix}\n1 & 2\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 12\\\\\n3 & 18\\\\\n4 & 24\n\\end{bmatrix}+\\begin{bmatrix}\n7 & 14\\\\\n8 & 16\\\\\n9 & 18\n\\end{bmatrix}=\\begin{bmatrix}\n9 & 26\\\\\n11 & 34\\\\\n13 & 42\n\\end{bmatrix}\n$$\n\n注意这里每一次都是用列向量与行向量相乘得到一个矩阵，而每次得到的矩阵都是有特点的，比如 $$\\begin{bmatrix}\n2\\\\\n3\\\\\n4\n\\end{bmatrix}\\begin{bmatrix}\n1 & 6\n\\end{bmatrix}=\\begin{bmatrix}\n2 & 12\\\\\n3 & 18\\\\\n4 & 24\n\\end{bmatrix}$$，其中$$\\begin{bmatrix}\n2 & 12\\\\\n3 & 18\\\\\n4 & 24\n\\end{bmatrix}$$的每一列都与$$\\begin{bmatrix}\n2\\\\\n3\\\\\n4\n\\end{bmatrix}$$同向，每一行都与$$\\begin{bmatrix}\n1 & 6\n\\end{bmatrix}$$ 同向。因此，该矩阵的列空间(矩阵列所有可能的线性组合)和行空间(矩阵行所有可能的线性组合)都是一条直线。\n\n### 分块乘法\n\n分块乘法就是宏观上的矩阵乘法，比如现在有一个 $50\\times 50$的矩阵与$50\\times 50$矩阵相乘，一个个进行运算很麻烦，尤其是如果矩阵在某一区域上有一定的性质(如某一矩阵分块内全部为 0 元素)，那么我们可以将其分块，如：\n\n$$\n\\begin{bmatrix}\nA_{1} & A_{2}\\\\\nA_{3} & A_{4}\n\\end{bmatrix}\\begin{bmatrix}\nB_{1} & B_{2}\\\\\nB_{3} & B_{4}\n\\end{bmatrix}=\\begin{bmatrix}\nC_{1} & C_{2}\\\\\nC_{3} & C_{4}\n\\end{bmatrix}\n$$\n\n其中的$$A_{i},B_{i}$$都是划分后的一块块矩阵，如：\n\n![blocked_matrix_mulply](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/blocked_matrix_mulply.png)\n\n而$$C_{1}=A_{1}B_{1}+A_{2}B_{3}$$，和矩阵乘法的计算步骤一样，只是这里的$$A_{1}B_{1},A_{2}B_{3}$$都是矩阵间的乘法而已。只要 A 和 B 分块相互匹配，就可以用这样的分块乘法求解。\n\n## 逆矩阵\n\n### 逆矩阵介绍\n\n之前我们介绍过一些逆矩阵的定义，对于一个**方阵** A，如果 A 可逆，就有$A^{-1}$，使得：$AA^{-1}=I=A^{-1}A$。\n\n如果 A 是**非方阵**，左侧的$A^{-1}$与右侧的$A^{-1}$不可能相同，因为此时左右侧的$A^{-1}$形状一定不相同。\n\n再以一个没有逆的矩阵为例：$$\\begin{bmatrix}\n1 & 2\\\\\n3 & 6\n\\end{bmatrix}$$，矩阵中的两个列向量互为倍数，也就是说其中一个向量对他们的线性组合无意义，那么这个 A 不可能有逆，换句话说：**若存在非零向量 x，使得 Ax=0，那么 A 就不可能有逆矩阵。**\n\n为什么呢？如果 A 有逆，且 x 是非零向量。则我们在$Ax=0$这个等式两边同时乘上$A^{-1}$，就有$A^{-1}Ax=Ix=0$，又因为$Ix=x$不是零向量，矛盾。因此此时 A 没有逆矩阵。\n\n此时再回头看矩阵 $$\\begin{bmatrix}\n1 & 2\\\\\n3 & 6\n\\end{bmatrix}$$，由于两个列向量线性相关，一定有一个x，使得$Ax=0$，如$$\\begin{bmatrix}\n3\\\\\n-1\n\\end{bmatrix}$$，因此该矩阵不可逆。\n\n### 逆矩阵求解\n\n其实求逆矩阵就是解方程组的过程，举例说明：\n\n【例】求解 $$\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}$$ 的逆矩阵\n$$\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}\\begin{bmatrix}\na & b\\\\\nc & d\n\\end{bmatrix}=I=\\begin{bmatrix}\n1 & 0\\\\\n0 & 1\n\\end{bmatrix}\n$$\n\n从列向量的角度看，得到两个方程：\n\n$$\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}\\begin{bmatrix}\na\\\\\nc\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\n0\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}\\begin{bmatrix}\nb\\\\\nd\n\\end{bmatrix}=\\begin{bmatrix}\n0\\\\\n1\n\\end{bmatrix}\n$$\n\n解这个方程就行了，但是这样做低阶矩阵还好，高阶矩阵计算量未免太大了。所以这里介绍一下高斯-若尔当方法。\n\n### 高斯-若尔当方法\n\n还是上面的例子，两个方程：$$\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}\\begin{bmatrix}\na\\\\\nc\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\n0\n\\end{bmatrix}$$，$$\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}\\begin{bmatrix}\nb\\\\\nd\n\\end{bmatrix}=\\begin{bmatrix}\n0\\\\\n1\n\\end{bmatrix}$$\n\n这个方法就是可以同时处理两个方程组，即使用增广矩阵联系两个方程。增广矩阵格式如下：\n\n$$\n\\begin{bmatrix}\n1 & 3 & 1 & 0\\\\\n2 & 7 & 0 & 1\n\\end{bmatrix}\n$$\n\n接下来进行行变换，将左侧的 $2\\times 2$ 矩阵消为单位矩阵 I，此时右侧矩阵即为逆矩阵。\n\n$$\n\\begin{bmatrix}\n1 & 3 & 1 & 0\\\\\n2 & 7 & 0 & 1\n\\end{bmatrix}->\\begin{bmatrix}\n1 & 3 & 1 & 0\\\\\n0 & 1 & -2 & 1\n\\end{bmatrix}->\\begin{bmatrix}\n1 & 0 & 7 & -3\\\\\n0 & 1 & -2 & 1\n\\end{bmatrix}\n$$\n\n即逆矩阵为 $$\\begin{bmatrix}\n7 & -3\\\\\n-2 & 1\n\\end{bmatrix}$$。\n\n接下来我们论证其合理性：\n\n上面这个过程，对 $$\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}$$进行消元处理使它变成单位矩阵I，就相当于**左乘一堆的消元矩阵**，设为E，就有$$E\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}=I$$，那么E肯定就是$A^{-1}$。再看右边，单位矩阵I经历了与$$\\begin{bmatrix}\n1 & 3\\\\\n2 & 7\n\\end{bmatrix}$$同样的消元过程，最后的结果相当于$EI=A^{-1}$，那虚线右侧得到的结果就是$A^{-1}$。\n\n## 学习收获\n\n本节介绍了认识矩阵乘法的不同角度，并介绍了逆矩阵的相关知识以及如何求解逆矩阵。MIT 的课程少有繁琐的证明，更多的是理解和类比，多从向量、空间、线性组合的角度去认识矩阵之间的运算。\n\n![linear_algebra_multiply_and_inverse](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/linear_algebra_multiply_and_inverse.png)\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数02-矩阵消元","url":"/2025/03/16/Linear_Algebra/线性代数-2/","content":"\n# Linear Algebra-矩阵消元-02\n\n## 概要\n\n这一节中我们介绍一下消元法，即是上一节中我们提到的“系统化”求解方程所用的方法，通过矩阵的消元运算可以很轻松地求解复杂方程。另外介绍了消元矩阵，即消元运算在矩阵乘法中所表现的形式。并从消元矩阵引入，介绍逆矩阵的基础知识。\n\n## 消元法求解方程\n\n### 消元法介绍\n\n对于一些“好”的系数矩阵（可逆）A 来说，我们可以使用**消元法**来求解方程$Ax=b$，我们还是从一个例子开始谈起。\n\n求解方程：$x+2y+z=2, 3x+8y+z=12, 4y+z=2$\n\n还是使用矩阵运算，将方程写成矩阵的形式$Ax=b$，$\\begin{bmatrix}\n1 & 2 & 1 \\\\\\\\\n3 & 8 & 1 \\\\\\\\\n0 & 4 & 1\n\\end{bmatrix}\\begin{bmatrix}\nx \\\\\\\\\ny \\\\\\\\\nz\n\\end{bmatrix}=\\begin{bmatrix}\n2 \\\\\\\\\n12 \\\\\\\\\n2\n\\end{bmatrix}$\n\n所谓矩阵的消元法，与我们初等数学中学习的解二元一次方程组的消元法其实师出同门，都是将不同行的方程进行消元运算来简化方程，最后能得到简化的方程组，只不过这里我们是将系数单独抽出来做运算，**寻找一种矩阵情况下的普遍规律而已**。\n\n消元针对的是系数矩阵 A：$\\begin{bmatrix}\n1 & 2 & 1 \\\\\n3 & 8 & 1 \\\\\n0 & 4 & 1\n\\end{bmatrix}$。首先注意，左上角的 1 是消元法的关键，被称为主元“1”，接下来通过我们熟悉的“将一行乘倍数加到另一行”的行化简方法将第一列中除了主元之外的元素全变为 0。\n\n$$\n\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   3 & 8 & 1 \\\\\n   0 & 4 & 1\n\\end{bmatrix}-(2,1)->\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   0 & 2 & -2 \\\\\n   0 & 4 & 1\n\\end{bmatrix}\n$$\n\n第一步目标达成，我们在第一列中只留下了主元 1，很好，接下来我们可以认为第一行与第一列已经“完工”了，再看去掉第一行第一列之后右下角剩下的部分：$\\begin{bmatrix}\n2 & -2 \\\\\\\\\n4 & 1\n\\end{bmatrix}$，同样，我们将左上角的 2 视为主元，消元第一列，使其列上（不包括已经完成消元的第一行中的元素）除此主元 2 外都为 0。\n$$\n\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   0 & 2 & -2 \\\\\n   0 & 4 & 1\n\\end{bmatrix}-(3,2)->\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   0 & 2 & -2 \\\\\n   0 & 0 & 5\n\\end{bmatrix}\n$$\n\n这时候第三行只剩下 5，我们直接将其处理为主元即可。得：\n\n$$\n\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   3 & 8 & 1 \\\\\n   0 & 4 & 1\n\\end{bmatrix}-(2,1)->\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   0 & 2 & -2 \\\\\n   0 & 4 & 1\n\\end{bmatrix}-(3,2)->\\begin{bmatrix}\n   1 & 2 & 1 \\\\\n   0 & 2 & -2 \\\\\n   0 & 0 & 5\n\\end{bmatrix}\n$$\n\n由于**矩阵 A 可逆**，因此经过消元处理得到的上三角矩阵 $U=\\begin{bmatrix}\n1 & 2 & 1 \\\\\\\\\n0 & 2 & -2 \\\\\\\\\n0 & 0 & 5\n\\end{bmatrix}$ 中有三个主元。至此，消元结束，得到的 U 即为我们想要化简的形式。\n\n> TIPS：\n> 并不是所有的矩阵都可以消元处理，需要注意在消元过程中，如果主元位置(左上角)为 0，那么意味着这个主元不可取，需要进行“换行处理”，首先看它的下一行对应位置是不是 0，如果不是，就将这两行位置互换，将非零数视为主元。如果是，就再看下下行，以此类推。若其下面每一行都看到了，仍然没有非零数的话，那就意味着这个矩阵不可逆，消元法求出的解不唯一。下面是三个例子：\n> $\\begin{bmatrix}\n> 0 & 2 & 1 \\\\\\\\\n> 0 & 2 & -2 \\\\\\\\\n> 0 & 0 & 5\n> \\end{bmatrix}$，$\\begin{bmatrix}\n> 1 & 2 & 1 \\\\\\\\\n> 0 & 0 & -2 \\\\\\\\\n> 0 & 0 & 5\n> \\end{bmatrix}$，$\\begin{bmatrix}\n> 1 & 2 & 1 \\\\\\\\\n> 0 & 2 & -2 \\\\\\\\\n> 0 & 0 & 0\n> \\end{bmatrix}$\n\n### 回带求解\n\n其实回带求解应该跟消元法同时进行，只不过一些在一些软件的工作原理中他们是分别进行的，所以这里我们分开讨论，先介绍增广矩阵：\n\n仍然是例一中的方程：$\\begin{bmatrix}\n1 & 2 & 1 \\\\\\\\\n3 & 8 & 1 \\\\\\\\\n0 & 4 & 1\n\\end{bmatrix}\\begin{bmatrix}\nx \\\\\\\\\ny \\\\\\\\\nz\n\\end{bmatrix}=\\begin{bmatrix}\n2 \\\\\\\\\n12 \\\\\\\\\n2\n\\end{bmatrix}$，我们先给出增广矩阵形式：\n$$\n\\begin{bmatrix}\n   1 & 2 & 1 & 2\\\\\n   3 & 8 & 1 & 12\\\\\n   0 & 4 & 1 & 2\n\\end{bmatrix}\n$$\n\n显然，就是把系数矩阵 A 和向量 b 拼接成一个矩阵就行了。\n\n然后像我们之前说的那样消元，但是这次要带着增广的 $b=\\begin{bmatrix}\n2 \\\\\\\\\n12 \\\\\\\\\n2\n\\end{bmatrix}$ 一起进行：\n$$\n\\begin{bmatrix}\n   1 & 2 & 1 & 2\\\\\n   3 & 8 & 1 & 12\\\\\n   0 & 4 & 1 & 2\n\\end{bmatrix}-(2,1)->\\begin{bmatrix}\n   1 & 2 & 1 & 2\\\\\n   0 & 2 & -2 & 6\\\\\n   0 & 4 & 1 & 2\n\\end{bmatrix}-(3,2)->\\begin{bmatrix}\n   1 & 2 & 1 & 2 \\\\\n   0 & 2 & -2 & 6\\\\\n   0 & 0 & 5 & -10\n\\end{bmatrix}\n$$\n\n之后，我们再带回方程$Ax=b$，变为：\n\n$$\nx+2y+z=2, 2y-2z=6, 5z=-10\n$$\n\n从下向上开始求解，就很容易求出 x, y, z 的值了。\n\n## 消元矩阵\n\n### 行向量与矩阵的乘法\n\n上面的消元法是从简单的变换角度介绍了消元的具体操作，接下来我们需要用矩阵来表示变换的步骤，这是十分必要的，因为这是一种“系统地”变换矩阵的方法。\n\n首先介绍向量与矩阵之间的乘法，上一节中我们提到了矩阵和列向量之间的乘法，是矩阵中列向量的线性组合，如：\n\n$$\n\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\\\\\n   a_{2,1} & a_{2,2} & a_{2,3}\\\\\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix}\\begin{bmatrix}\n   m\\\\\n   n\\\\\n   k\n\\end{bmatrix}=m\\begin{bmatrix}\n   a_{1,1}\\\\\n   a_{2,1}\\\\\n   a_{3,1}\n\\end{bmatrix}+n\\begin{bmatrix}\n   a_{1,2}\\\\\n   a_{2,2}\\\\\n   a_{3,2}\n\\end{bmatrix}+k\\begin{bmatrix}\n   a_{1,3}\\\\\n   a_{2,3}\\\\\n   a_{3,3}\n\\end{bmatrix}\n$$\n\n但这并不能解决我们现在的问题，因为我们在消元法中使用到的是行变换，那么我们就要思考，行向量和矩阵的乘积是什么呢？\n\n$$\n\\begin{bmatrix}\n   m & n & k\n\\end{bmatrix}\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\\\\\n   a_{2,1} & a_{2,2} & a_{2,3}\\\\\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix}=m\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\n\\end{bmatrix}+n\\begin{bmatrix}\n   a_{2,1} & a_{2,2} & a_{2,3}\n\\end{bmatrix}+k\\begin{bmatrix}\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix}\n$$\n\n从上面的过程可以看出，**行向量和矩阵的乘积是矩阵中行向量的线性组合**。\n\n至于行向量为什么放左边则是从矩阵乘法的维数匹配去考虑，以上式为例，行向量维数为 $1\\times3$，矩阵维数为$3\\times3$，因此行向量只能置于矩阵的左侧。\n\n### 消元矩阵介绍\n\n该部分内容是重点。学会了行向量与矩阵之间的乘法，我们就可以使用行向量对矩阵的行进行操作了。所谓消元矩阵，就是将消元过程中的行变换转化为矩阵之间的乘法形式。\n\n首先需知下面三个式子成立：\n\n$$\n\\begin{bmatrix}\n   1 & 0 & 0\n\\end{bmatrix}\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\\\\\n   a_{2,1} & a_{2,2} & a_{2,3}\\\\\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix} = \\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\n   0 & 1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\\\\\n   a_{2,1} & a_{2,2} & a_{2,3}\\\\\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix} = \\begin{bmatrix}\n   a_{2,1} & a_{2,2} & a_{2,3}\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\n   0 & 0 & 1\n\\end{bmatrix}\\begin{bmatrix}\n   a_{1,1} & a_{1,2} & a_{1,3}\\\\\n   a_{2,1} & a_{2,2} & a_{2,3}\\\\\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix} = \\begin{bmatrix}\n   a_{3,1} & a_{3,2} & a_{3,3}\n\\end{bmatrix}\n$$\n\n此时将 $\\begin{bmatrix}\n1 & 0 & 0\n\\end{bmatrix}\\begin{bmatrix}\n0 & 1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n0 & 0 & 1\n\\end{bmatrix}$构成一个矩阵：单位阵：$\\begin{bmatrix}\n1 & 0 & 0\\\\\\\\\n0 & 1 & 0\\\\\\\\\n0 & 0 & 1\n\\end{bmatrix}$，易得单位阵与矩阵相乘不改变矩阵。消元矩阵就是单位阵的变换形式，我们仍以例一中的矩阵说明：\n$$\n\\begin{bmatrix}\n   ? & ? & ?\\\\\n   ? & ? & ?\\\\\n   ? & ? & ?\n\\end{bmatrix}\\begin{bmatrix}\n   1 & 2 & 1\\\\\n   3 & 8 & 1\\\\\n   0 & 4 & 1\n\\end{bmatrix}=\\begin{bmatrix}\n   1 & 2 & 1\\\\\n   0 & 2 & -2\\\\\n   0 & 4 & 1\n\\end{bmatrix}\n$$\n\n首先明确：\n\n$$\n\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & 1 & 0\\\\\n   0 & 0 & 1\n\\end{bmatrix}\\begin{bmatrix}\n   1 & 2 & 1\\\\\n   3 & 8 & 1\\\\\n   0 & 4 & 1\n\\end{bmatrix}=\\begin{bmatrix}\n   1 & 2 & 1\\\\\n   3 & 8 & 1\\\\\n   0 & 4 & 1\n\\end{bmatrix}\n$$\n\n消元过程的第一步是将第一行乘(-3)加到第二行，这是对第二行的操作，那么我们就从单位阵的第二行着手：\n\n$$\n\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & 1 & 0\\\\\n   0 & 0 & 1\n\\end{bmatrix}-[L2=L2+L1*(-3)]->\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   -3 & 1 & 0\\\\\n   0 & 0 & 1\n\\end{bmatrix}\n$$\n\n根据先前的结论，“**行向量和矩阵的乘积是矩阵中行向量的线性组合”**。因此\n\n$$\n\\begin{bmatrix}\n   -3 & 1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n   1 & 2 & 1\\\\\n   3 & 8 & 1\\\\\n   0 & 4 & 1\n\\end{bmatrix}=-3\\begin{bmatrix}\n   1 & 2 & 1\n\\end{bmatrix}+1\\begin{bmatrix}\n   3 & 8 & 1\n\\end{bmatrix}=\\begin{bmatrix}\n   0 & 2 & -2\n\\end{bmatrix}\n$$\n\n因此，经验证，这一步的消元矩阵就是 $\\begin{bmatrix}\n1 & 0 & 0\\\\\\\\\n-3 & 1 & 0\\\\\\\\\n0 & 0 & 1\n\\end{bmatrix}$，我们将其记为$E_{21}$，意义是将矩阵 A 中 2 行 1 列(2,1)位置变为 0 的消元矩阵。\n\n同样，计算 $\\begin{bmatrix}\n1 & 2 & 1 & 2\\\\\\\\\n0 & 2 & -2 & 6\\\\\\\\\n0 & 4 & 1 & 2\n\\end{bmatrix}-(3,2)->\\begin{bmatrix}\n1 & 2 & 1 & 2\\\\\\\\\n0 & 2 & -2 & 6\\\\\\\\\n0 & 0 & 5 & -10\n\\end{bmatrix}$ 这一步的消元矩阵，即为：\n$$\n\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & 1 & 0\\\\\n   0 & 0 & 1\n\\end{bmatrix}-[L3=L3+L2*(-2)]->\\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & 1 & 0\\\\\n   0 & -2 & 1\n\\end{bmatrix}\n$$\n\n得到：\n\n$$\nE_{32}E_{21}A=U(Upper\\ triangular\\ matrix)\n$$\n\n其中 U 为上三角矩阵。使用矩阵乘法的结合律，先计算$$E_{32}E_{21}$$，即为 E，则 E 就是整个此次消元过程的消元矩阵。\n\n核心：求消元矩阵就是从单位阵 I 入手，按照 A 每次变换的消元步骤操作 I 矩阵，能分别得到$E_{row,col}$，最后相乘得到 E 即可。\n\n### 行交换矩阵与逆矩阵\n\n#### 行变换与列变换\n\n有了上面消元矩阵的启发，易得能够交换 $2\\times2$ 矩阵中两行的矩阵为：\n\n$$\n\\begin{bmatrix}\n   0 & 1\\\\\n   1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n   a & b\\\\\n   c & d\n\\end{bmatrix}=\\begin{bmatrix}\n   c & d\\\\\n   a & b\n\\end{bmatrix}\n$$\n\n而交换 $2\\times2$ 矩阵中两列的矩阵为：\n\n$$\n\\begin{bmatrix}\n   a & b\\\\\n   c & d\n\\end{bmatrix}\\begin{bmatrix}\n   0 & 1\\\\\n   1 & 0\n\\end{bmatrix}=\\begin{bmatrix}\n   b & a\\\\\n   d & c\n\\end{bmatrix}\n$$\n\n所以，**左乘等同于行变换，右乘等同于列变换**。\n\n#### 逆矩阵初探\n\n可以说我们学会了消元矩阵，就相当于我们可以用矩阵乘法对一个矩阵进行任何变化了，那么我们考虑一个逆过程，即我们如何把一个消元结束的矩阵 U 变为未经消元的矩阵 A 呢？答案就是乘上一个逆矩阵。\n\n如例一中的$E_{21}$，是第一行乘以3到第二行，即\n\n\n$$E_{21}=\\begin{bmatrix}\n1 & 0 & 0\\\\\n-3 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}$$\n那么与之相反，我们在第二行加上第一行$\\times3$就可以复原这一运算过程，即：$\\begin{bmatrix}\n1 & 0 & 0\\\\\\\\\n3 & 1 & 0\\\\\\\\\n0 & 0 & 1\n\\end{bmatrix}\\begin{bmatrix}\n1 & 0 & 0\\\\\\\\\n-3 & 1 & 0\\\\\\\\\n0 & 0 & 1\n\\end{bmatrix}=\\begin{bmatrix}\n1 & 0 & 0\\\\\\\\\n0 & 1 & 0\\\\\\\\\n0 & 0 & 1\n\\end{bmatrix}=I$。其中的I是单位矩阵。\n此时的$\\begin{bmatrix}\n1 & 0 & 0\\\\\\\\\n3 & 1 & 0\\\\\\\\\n0 & 0 & 1\n\\end{bmatrix}$称为$$E_{21}^{-1}$$，就有了$$E_{21}^{-1}E_{21}=I$$。\n\n## 学习感悟\n\n本节从矩阵消元的角度，介绍解方程的通用做法，并介绍了消元矩阵，使我们从矩阵乘法层面理解了消元的过程，并延伸了消元矩阵的应用：就是基于单位阵 I 的变化，对矩阵 A 进行行列变换的过程。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"线性代数01-方程组的几何解释","url":"/2025/03/15/Linear_Algebra/线性代数-1/","content":"\n# Linear Algebra-方程组的几何解释-01\n\n## 概要\n\n从本节开始，我们重新开始学习线性代数的有关知识。首先从解方程谈起，学习线性代数的应用之一就是求解复杂的方程问题，本文的核心就是从行图像和列图像的角度解方程。\n\n## 方程组的几何解释\n\n### 二维的行图像\n\n首先我们可以通过一个例子来从行图像角度求解方程：\n\n[例]求解方程：$2x-y=0, -x+2y=3$\n\n我们首先按行将方程写成矩阵形式：$\\begin{bmatrix}\n2 & -1 \\\\\\\\\n-1 & 2\n\\end{bmatrix}\\begin{bmatrix}\nx \\\\\\\\\ny\n\\end{bmatrix}=\\begin{bmatrix}\n0 \\\\\\\\\n3\n\\end{bmatrix}\\\\\\\\\n$\n\n系数矩阵(A)：将方程系数按行提取出来，构成一个矩阵；\n\n未知向量(x)：将方程未知数提取出来，按列构成一个向量；\n\n向量(b)：将等号右侧结果按列提取，构成一个向量；\n\n下面我们可以通过行图像来求解这个方程，所谓行图像，就是在系数矩阵上，一次取一行构成方程，在坐标系上作图。和我们在初等数学中学习的作图求解方程的过程无异。由图可知，图中的绿点(1,2)就是方程组的解。\n\n![矩阵解的几何形式](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/EhNZbaZKooRziqxci8bccsZznzc.png)\n\n### 二维的列图像\n\n从列图像角度，我们再次求解这个方程 $2x-y=0, -x+2y=3$\n\n这一次我们求解过程中，我们将方程按列提取，使用的矩阵为：$x\\begin{bmatrix}\n2 \\\\\\\\\n-1\n\\end{bmatrix}+y\\begin{bmatrix}\n-1 \\\\\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n0 \\\\\\\\\n3\n\\end{bmatrix}$\n\n如上，我们使用列向量构成系数矩阵，**将问题转化为**：\n\n如何将向量 $\\begin{bmatrix}\n2 \\\\\\\\\n-1\n\\end{bmatrix}$与向量$\\begin{bmatrix}\n-1 \\\\\\\\\n2\n\\end{bmatrix}$正确组合，得到结果向量$\\begin{bmatrix}\n0 \\\\\\\\\n3\n\\end{bmatrix}$?\n\n接下来我们使用列图像求解此方程：\n\n![linear_column_pic0](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/linear_column_pic0.png)\n\n即寻找合适的 x，y 使得 x 倍的(2, -1) + y 倍的(-1, 2)得到最终的向量(0, 3)。很明显能看出来，x 为 1，y 为 2 时满足条件。反映在图像上，显然结果正确。\n\n进一步思考的话，对于 $x\\begin{bmatrix}\n2 \\\\\\\\\n-1\n\\end{bmatrix}+y\\begin{bmatrix}\n-1 \\\\\\\\\n2\n\\end{bmatrix}$ 这个方程，如果 x 和 y 可以取任意值，那么可以得到什么呢？显然**我们可以得到二维平面中任何方向的向量。**\n\n## 方程组的几何解释推广\n\n### 高维行图像\n\n我们将方程维数推广，从三维开始，$2x-y=0, -x+2y-z=-1, -3y+4z=4$，如果我们继续使用行图像的方法求解，那么会得到一个很复杂的图像。\n\n矩阵形式如下：\n\n$A=\\begin{bmatrix}\n2&-1&0\\\\\\\\\n-1&2&-1\\\\\\\\\n0&-3&4\n\\end{bmatrix}$，$b=\\begin{bmatrix}\n0\\\\\\\\\n-1\\\\\\\\\n4\n\\end{bmatrix}$，方程：$Ax=b$，$\\begin{bmatrix}\n2&-1&0\\\\\\\\\n-1&2&-1\\\\\\\\\n0&-3&4\n\\end{bmatrix}\\begin{bmatrix}\nx\\\\\\\\\ny\\\\\\\\\nz\n\\end{bmatrix}=\\begin{bmatrix}\n0\\\\\\\\\n-1\\\\\\\\\n4\n\\end{bmatrix}$\n\n如果绘制行图像，这是 3 个平面相交得到一点，常见的思路是先联立其中两个平面，使其相交于一条直线，再研究这条直线与剩下的第三个平面相交于哪个点，最后得到的点坐标即为方程的解。直观上这种求解方式很难直接绘制更高维数的图像。\n\n### 高维列图像\n\n还是刚刚的例子，$2x-y=0\\\\\\\\-x+2y-z=-1\\\\\\\\-3y+4z=4$，如果我们使用列图像的思路进行计算，那么矩阵形式就变为：\n\n$$\nx\\begin{bmatrix}\n   2\\\\\\\\\n   -1\\\\\\\\\n   0\n\\end{bmatrix}+y\\begin{bmatrix}\n   -1\\\\\\\\\n   2\\\\\\\\\n   -3\n\\end{bmatrix}+z\\begin{bmatrix}\n   0\\\\\\\\\n   -1\\\\\\\\\n   4\n\\end{bmatrix}=\\begin{bmatrix}\n   0\\\\\\\\\n   -1\\\\\\\\\n   4\n\\end{bmatrix}\n$$\n\n左侧是线性组合，右侧是线性组合组成的结果，这样一来思路就清晰多了，“寻找线性组合”成为了解题的关键。\n\n显然这道题是一个特例，明显$x=0,y=0,z=1$是方程的解，这在行图像中并不明显。\n\n我们之所以更推荐使用列图像求解方程，是因为**这是一种更系统的求解方法，即寻找线性组合**，而不用绘制每个行方程的图像后寻找那个很难直观看出来的交点坐标。另一个优势在于，如果我们改变最后的结果 b，如本题中，我们将其改为 $x\\begin{bmatrix}\n2\\\\\\\\\n-1\\\\\\\\\n0\n\\end{bmatrix}+y\\begin{bmatrix}\n-1\\\\\\\\\n2\\\\\\\\\n-3\n\\end{bmatrix}+z\\begin{bmatrix}\n0\\\\\\\\\n-1\\\\\\\\\n4\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\\\\\n1\\\\\\\\\n-3\n\\end{bmatrix}$，那么我们就重新寻找一个线性组合就够了。但如果我们使用的是行图像呢？那意味着我们要完全重画三个平面图像，就简便性来讲，两种方法高下立判。\n\n另外，还要注意的一点是，对任意的 b 是不是都能求解$Ax=b$这个矩阵方程呢？也就是对于 $3\\times3$的系数矩阵A，其列的线性组合是否都能覆盖整个三维空间呢？对于我们上面举的这些例子，都是可以的。但是有些矩阵就是不行的，比如三个列向量本身就只构成了一个平面，那么这样的三个向量组成的向量只能分布在该平面上，肯定无法覆盖整个三维空间。如三个列向量分别为：$\\begin{bmatrix}\n2\\\\\\\\\n-1\\\\\\\\\n0\n\\end{bmatrix}$，$\\begin{bmatrix}\n-1\\\\\\\\\n2\\\\\\\\\n-3\n\\end{bmatrix}$，$\\begin{bmatrix}\n1\\\\\\\\\n1\\\\\\\\\n-3\n\\end{bmatrix}$。这三个向量就构成了一个平面，其中$\\begin{bmatrix}\n2\\\\\\\\\n-1\\\\\\\\\n0\n\\end{bmatrix}+\\begin{bmatrix}\n-1\\\\\\\\\n2\\\\\\\\\n-3\n\\end{bmatrix}=\\begin{bmatrix}\n1\\\\\\\\\n1\\\\\\\\\n-3\n\\end{bmatrix}$。对于这个方程组而言，就无法实现对于任意的 b，方程的解都存在。\n\n### 矩阵乘法\n\n如 Ax，如果我们已知一个矩阵 A 和一个向量 x，那么我们如何求解它们的积呢？例如 $A=\\begin{bmatrix}\n2&5\\\\\\\\\n1&3\n\\end{bmatrix}$，$x=\\begin{bmatrix}\n1\\\\\\\\\n2\n\\end{bmatrix}$，我们这样求：\n\n- 法一：将矩阵 A 看做列向量的组合：\n\n$$\n\\begin{bmatrix}\n   2&5\\\\\\\\\n   1&3\n\\end{bmatrix}\\begin{bmatrix}\n   1\\\\\\\\\n   2\n\\end{bmatrix}=1\\begin{bmatrix}\n   2\\\\\\\\\n   1\n\\end{bmatrix}+2\\begin{bmatrix}\n   5\\\\\\\\\n   3\n\\end{bmatrix}=\\begin{bmatrix}\n   12\\\\\\\\\n   7\n\\end{bmatrix}\n$$\n\n即 x 每个分量与矩阵中各列向量相乘，再将其求和。\n\n- 法二：向量点乘\n\n$$\n\\begin{bmatrix}\n   2&5\\\\\\\\\n   1&3\n\\end{bmatrix}\\begin{bmatrix}\n   1\\\\\\\\\n   2\n\\end{bmatrix}=\\begin{bmatrix}\n   (2,5)\\cdot(1,2)\\\\\\\\\n   (1,3)\\cdot(1,2)\n\\end{bmatrix}=\\begin{bmatrix}\n   12\\\\\\\\\n   7\n\\end{bmatrix}\n$$\n\n## 感悟\n\n该部分内容是对线性代数内容的初涉，从解方程谈起，引入列空间的概念，可以发现从列空间角度将求解方程，变化为求列向量的线性组合，这种方法更加科学，并从列向量的线性组合方式了解矩阵乘法。\n","tags":["Linear_Algebra"],"categories":["Linear_Algebra"]},{"title":"EVM-概念与数学原理","url":"/2025/03/12/Com/EVM-概念与数学原理/","content":"\n# EVM：概念与数学原理\n\n### **引言**\n\n在无线通信系统中，信号的质量直接影响数据传输的稳定性和速率。误差向量幅度（Error Vector Magnitude, EVM）是衡量调制信号质量的重要参数，广泛应用于 Wi-Fi、蜂窝网络和其他无线技术。本文将详细介绍 EVM 的概念、数学原理以及它对 Wi-Fi 传输性能的影响。\n\n---\n\n### **1. 什么是 EVM？**\n\nEVM 是衡量接收信号与理想信号之间误差的指标。它描述了调制信号在接收端与发送端理想信号之间的偏差程度，通常以百分比（%）或 dB（分贝）表示。\n\n在 Wi-Fi（IEEE 802.11 标准）中，EVM 被用来评估不同调制方案（如 BPSK、QPSK、16-QAM、64-QAM、256-QAM）的信号质量。较低的 EVM 值表示更好的信号质量，而较高的 EVM 值则意味着更多的误差，可能导致数据误码率（BER）上升。\n\n---\n\n### **2. EVM 的数学原理**\n\n#### **2.1 EVM 的计算公式**\n\nEVM 计算的基本公式如下：\n\n$$\nEVM_{rms} = \\sqrt{\\frac{\\sum_{i=1}^{N} |S_i - R_i|^2}{\\sum_{i=1}^{N} |S_i|^2}} \\times 100\n$$\n\n其中：\n\n- $S_i$ 是理想信号（发送信号）的 IQ 复数坐标。\n- $ R_i $ 是实际接收到的信号 IQ 复数坐标。\n- $ N $ 是符号的总数。\n- $ |S_i - R_i| $ 表示发送信号与接收信号之间的误差向量。\n- $ |S_i| $ 是理想信号的幅度。\n\n该公式表示误差向量的均方根（RMS）值与理想信号功率的比值，并转换为百分比形式。\n\n![KSpjbVNUno0b8Axrnl9chsa5nij](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/KSpjbVNUno0b8Axrnl9chsa5nij.png)\n\n#### **2.2 dB 形式的 EVM 计算**\n\n在无线通信测试中，EVM 常以 dB 形式表示，其计算公式为：\n\n$$\nEVM_{dB} = 10 \\log_{10} \\left( \\frac{\\sum_{i=1}^{N} |S_i - R_i|^2}{\\sum_{i=1}^{N} |S_i|^2} \\right)\n$$\n\n这种形式的 EVM 便于与其他无线通信参数（如信噪比 SNR）进行对比。\n\n---\n\n### **3. EVM 对 Wi-Fi 传输的影响**\n\nEVM 直接影响 Wi-Fi 设备的通信质量，并与以下因素密切相关：\n\n#### **3.1 调制方式与 EVM 要求**\n\n不同的 Wi-Fi 调制方式（BPSK、QPSK、16-QAM、64-QAM、256-QAM、1024-QAM）对 EVM 的要求不同，调制阶数越高，对 EVM 的要求越严格。例如：\n\n<table>\n<tr>\n<td>调制方式<br/></td><td>典型 EVM 要求 (dB)<br/></td></tr>\n<tr>\n<td>BPSK<br/></td><td>-5 dB<br/></td></tr>\n<tr>\n<td>QPSK<br/></td><td>-10 dB<br/></td></tr>\n<tr>\n<td>16-QAM<br/></td><td>-16 dB<br/></td></tr>\n<tr>\n<td>64-QAM<br/></td><td>-22 dB<br/></td></tr>\n<tr>\n<td>256-QAM<br/></td><td>-28 dB<br/></td></tr>\n<tr>\n<td>1024-QAM<br/></td><td>-32 dB<br/></td></tr>\n</table>\n\n当 EVM 超过规定的阈值时，接收端可能无法正确解调信号，导致数据误码率上升，从而降低吞吐量。\n\n#### **3.2 影响 EVM 的主要因素**\n\n1. **射频链路非理想性**：包括相位噪声、非线性放大、IQ 失衡等。\n2. **信号干扰**：其他 Wi-Fi 设备、电磁干扰源可能会影响信号质量。\n3. **多径效应**：无线信号在传播过程中经过反射、衍射等现象，会导致信号失真。\n4. **天线和匹配网络设计**：不良的天线匹配会影响信号传输质量。\n\n---\n\n### **4. 如何优化 EVM 以提高 Wi-Fi 质量？**\n\n为了降低 EVM 并提高 Wi-Fi 通信质量，可以采取以下措施：\n\n1. **优化射频设计**：改进功放线性度，减少 IQ 失衡。\n2. **增强信号处理算法**：采用数字预失真（DPD）等技术补偿非线性失真。\n3. **减少干扰**：使用 5GHz 或 6GHz 频段，避免 2.4GHz 的拥塞。\n4. **天线优化**：使用高质量天线，并确保阻抗匹配。\n5. **提高 SNR**：使用更高增益的天线，减少环境噪声，提高接收灵敏度。\n\n---\n\n### **5. 结论**\n\nEVM 是衡量 Wi-Fi 信号质量的重要指标，它通过计算误差向量的均方根值来评估接收信号与理想信号的偏差。较低的 EVM 值意味着更好的调制解调性能，从而提高数据传输的稳定性和速率。通过优化射频设计、减少干扰、提升 SNR，可以有效降低 EVM，提升 Wi-Fi 设备的通信质量。\n\n随着 Wi-Fi 6（802.11ax）和 Wi-Fi 7（802.11be）的发展，EVM 在高阶调制（如 1024-QAM、4096-QAM）中的作用将更加关键。因此，深入理解 EVM 及其优化方法，对无线通信工程师而言至关重要。\n","tags":["Communication"],"categories":["Communication"]},{"title":"DPD-数字预失真","url":"/2025/03/12/Com/DPD-数字预失真/","content":"\n# DPD-数字预失真\n\n# 前言\n\n家人们，今天咱来唠唠通信界的一个超重要 “选手”——数字预失真 DPD(Digital Pre-Distortion)，它在通信领域那可是相当有存在感，就像游戏里的神助攻，能让射频放大器变得超厉害！\n\n# DPD 是个啥\n\nDPD 这名字听起来有点绕，简单来说，就是让正常的数字信号提前 “变个样”。\n\n“数字” 嘛，说明是在数字的地盘儿搞事情，和模拟域没啥关系；\n\n“预” 就是提前的意思，在射频功率放大器 “开工” 之前就先行动；\n\n“失真” 呢，信号在传输过程中走样了就叫失真，DPD 就是故意让原始信号 “失失真” 。这就好比给信号提前做了个 “变形手术”，专门用来对付功率放大器的那些小脾气。\n\n既然 DPD 是为了对付 PA 的小脾气的，自然在信号处理系统中，DPD 就要放在 PA 的前面。\n\n# 为啥需要 DPD\n\n这就得吐槽一下射频功率放大器啦！它有个让人头疼的毛病，输入功率加到一定程度，就开始 “耍小性子”，进入非线性区。这时候，输入和输出不再是 “铁哥们”，不再成线性关系。增加输入功率，输出功率却不给力，效率直线下降，信号还失真了。就好比你使劲给车加油，车却跑不起来，还跑偏了。\n\n![DPD示意图](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Oqirbaoknoleu8xUGgscVMTJnge.png)\n\n接收端收到失真信号后，还会继续 “捣乱”，把失真加剧。那咋办呢？\n\n一般有两种办法，要么降低输入信号功率，躲开非线性区这个 “大坑”；要么增加输入信号功率，牺牲点能量换信号不失真。\n\nDPD 就属于后者，它就像个聪明的 “信号整形师”，让原先的信号朝着和功率放大器相反的方向 “变形”，抵消掉功率放大器的非线性影响 。这么一来，输出和输入信号之间的线性关系区间变宽了，功率放大器效率也提升了，不过功耗也增加了点，就当是给效率提升交的 “小电费” 吧。而且用了 DPD，无线基站的效率能大幅提升，能给网络运营商省下不少钱呢！\n\n![PA特性](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Oqirbaoknoleu8xUGgscVMTJnge1.png)\n\n# 谁能搞定 DPD？\n\n## 设备厂家\n\n那些大型设备厂家，像华为、中兴、爱立信、诺基亚、三星，都是 DPD 技术的 “大拿”，自家都有厉害的 DPD 技术，就像有独家秘籍一样。\n\n小厂就有点尴尬啦，大多没有自己的 DPD 技术，毕竟没积累嘛。没办法，只能找学校 “取经”，或者直接买 FPGA 公司提供的 IP core，就像借别人的工具来干活。\n\n## 芯片厂家\n\nFPGA 芯片厂家可就牛了，不仅能提供高性能的 DPD 解决方案，而且 IP 核参数还能自己调，不用手动一点点定制，省了好多事儿，就像给你一把万能钥匙，直接打开 DPD 的大门，还能提供超小占位面积、低成本的 FPGA 解决方案。\n\n# DPD 有什么实现难点？\n\nDPD 想发挥好作用，也不是一帆风顺的。首先，它的数学模型和参数得和功率放大器（PA）完美匹配，PA 要是变了，DPD 的数学模型或参数也得跟着变，就像脚变了，鞋也得换。\n\n随着 5G 时代到来，载波带宽越来越宽，都能达到 800MHz。以前 4G 的 DPD 数学模型在 5G 基站 PA 这儿就 “水土不服” 了，性能根本不达标，所以还得深入研究新的数学模型。\n\n最后，DPD 不管是用 FPGA、CPU 还是 DSP 来实现，都得从实现难度、资源消耗、成本控制、研发周期等多方面综合考虑，这里面的技术门道可多了，一般人还真搞不定。\n\n# 功率放大器的模型是什么样？\n\n## “宽带” 功放线性区数学模型\n\n所谓 “宽带”，就是信号带宽超宽，啥频率都能在功率放大器里畅通无阻。假设输入是 IQ 调制信号，线性区模型就是输出和输入是简单的倍数关系。经过功率放大器后，信号频谱不变，幅度还放大了，就像给信号打了一针 “放大剂”。\n\n## “宽带” 功放非线性区数学模型\n\n到了非线性区，情况就复杂了。可以用幂指数函数或者幂级数函数来描述。\n\n幂指数函数的图像如下：\n\n![幂指函数](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/WnTobcCD8oiC5px9lqMcRnBCnWc.png)\n\n幂级数函数是用来模拟非线性特性的\n\n拿幂级数函数来说，它适合模拟无记忆的弱非线性系统。\n\n$$\ny=\\sum_{n=0}^{\\infty}a_{n}(x-x_{0})^{n}\n$$\n\n上面的公式被称为幂级数，其中$x_{0}$为常数，$a_{0},a_{1},...a_{n}$称为幂级数的系数。\n\n下面以输出信号为 IQ 调制信号为例，来说明经过功率放大器后会产生很多的谐波分量；\n\n**假设 1**：输入信号为 IQ 调制信号(双音正弦信号)：\n\n$$\nx(t)=A_{1}cos(wt)+A_{2}sin(wt)\n$$\n\n**假设 2**：功率放大器是三阶函数：\n\n$$\ny(t)=a_{1}x(t)+a_{2}x^{2}(t)+a_{3}x^{3}(t)\n$$\n\n则输出信号的频谱为：基波分量 W，二阶谐波分量 2W，三阶谐波分量 3W；\n\n显然，经过功率放大器后，信号有很多的谐波分量，这就会导致信号的失真；\n\n- 产生的非基波频谱分量(二次、三次谐波分量)分走了本该作用在全部基波上的功率，造成了能量的损失；\n- 产生的非基波频谱分量(二次、三次谐波分量)落在信号通带、邻带和其他有用通带内，如果不用滤波器加以滤除，则会对有用信号产生干扰；\n- 如果产生谐波分量正好落在**信号带宽内**，这就**无法滤除**，产生无法消除的信号干扰；\n\n因此，如果功率放大器在非线性区对高频信号进行放大，损失能量是小事，最麻烦的问题是，会产生谐波干扰信号；\n\n因此，要尽量避免功率放大器对输入信号进行非线性放大，要尽量对信号进行线性放大。\n\n那么可能会有人说，直接让 PA 工作在线性区不就行了吗？实际的通信系统中会面临如下问题：\n\n![DPD问题](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Ww2tbZD2zoyDIgxCcrHc4GzpnMh.png)\n\n- 信号的幅度变化较大，峰均比（信号峰值与信号均值的比值）比较高，这就意味着即使信号均值落在线性区，信号的峰值也有可能落在非线性区；\n- 如果信号峰值和均值都落在线性区，这功率放大器的利用率就很低，大部分时间工作在低功率区，对功率放大器是很大的浪费，功率放大器的线性区间越宽，价格越贵，并且价格相差很大；\n- 移动通信系统中，要增加信号的覆盖区，就需要增大发射功率；\n\n因此，无论是从成本，还是实际部署的角度考虑，都期望尽可能让输入信号的功率，**工作在接近非线性区附近**。\n\n有了这些原因，才会有工程师想，能不能在 PA 之前，先对原始的输入信号$X(t)$进行预处理，得到$Z(t)$，使得功率放大器的输入信号$Z(t)$工作在非线性区，输出信号$Y(t)$与$X(t)$之间还是线性关系呢？\n\n这就是数字预失真 DPD 和削峰 CFR；其中 CFR 的作用是降低信号的峰均比；\n\n![CFR+DPD](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/QkgHbEVYQorlGzxKlcRcCnrEnJh.png)\n\n这样带来两个好处：\n\n- 虽然 PA 工作在非线性区，但是如果 DPD+PA，从整体来看，PA 的输出信号和 DPD 的输入信号之间还是线性关系，没有导致输入信号失真；\n- 从逻辑上看，在不改变功率放大器的情况下，增大了功率放大器的线性区间；\n\n## “带限” 系统的 Volterra 级数模型\n\n实际系统大多是 “带限” 系统，带宽有限制，DAC 对带宽影响很大。带宽增加，不仅会带来记忆效应，对 ADC 要求也更高。“带限” 系统只关心载带和邻带信号，数学模型是 Volterra 级数模型，不同阶数的非线性多项式对应不同带宽的信号非线性分量。为了让建模更准，还得在传统模型里加带限函数。\n\n下图是 DPD 结构的一个示意图\n\n![DPD结构示意图](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/STW0bDuZUo1cvIx3egycJTjHnie.png)\n\n我们使用 Volterra 级数模型对 PA 进行建模的话，可以同时考虑到非线性和记忆效应；\n\n$$\nF[x(n)]=\\sum_{k=1}^K\\sum_{q=0}^Qa_{kq}x(n-q)\\left|x(n-q)\\right|^{k-1}\n$$\n\n其中 K 是多项式级数，Q 是记忆深度。\n\n> From Xilinx DPD IP Doc，Xilinx 对于$a_{kq}$的求解\n\n# 思维导图\n\n![DPD思维导图](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/whiteboard_exported_image.png)\n","tags":["Communication"],"categories":["Communication"]},{"title":"AXI协议概述","url":"/2024/04/15/IC/AXI/AXI协议/","content":"\n## 概述\n\nAXI是一种总线协议，由ARM公司提出，面向高性能、高带宽、低延迟的片内总线。主要的特点有：\n\n1. 分离的地址/控制、数据通道；\n2. 支持非对齐的数据传输；\n3. 基于Burst传输，仅需传输首地址；\n4. 分离的读写数据通道，可供DMA使用(MM2S、S2MM)；\n5. 支持超前传输，可以连续发送多个突发传输的首地址而无需等待之前的突发传输完成，这有助于处理流水处理Transaction；\n6. 支持乱序传输；\n7. 易于添加寄存器级来实现时序收敛；\n\n与AXI传输有关的三个概念：\n\n- Transaction：两个AXI组件为了传输一组数据而进行的所有交互称为AXI Transaction，包括所有5个通道上的交互；\n- Burst：在AXI Transaction中，数据以突发传输（Burst）的形式组织。一次突发传输中可以包含一至多个数据（Transfer）。每个Transfer因为使用一个周期，又被称为一拍数据（Beat）；\n- Transfer/Beat：一次成功握手，占用一个时钟周期；\n\n## AXI读写架构\n\nAXI协议是基于Burst的传输，共定义了以下5个独立的传输通道：**读地址、读数据、写地址、写数据、写响应通道；**这五个通道都只支持单向传输。\n\nAXI使用**基于VALID/READY的握手机制**传输数据，发送端使用VALID表明地址/控制、数据信号是有效的，目的端使用READY表明自己能够接收信息；这是一种**双向流控机制**，指发送方通过置起VALID信号控制发送的时机和速度，接收方也可以通过READY信号的置起与否控制接收速度。**发送方具有传输的主动权，但接收方在不具备接收能力时，也能够通过置低信号停止传输，反压发送方；**\n\n此处应注意置起VALID信号是完全主动与独立的过程，接收方的READY信号可以依赖发送方的VALID信号，主要目的是为避免死锁情况，即VALID不能等READY，READY可以等VALID；（注：**协议建议将READY的默认电平设置为高电平**，这样减少传输过程的时间开销）\n\n![read_transaction](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/read_transaction11.png)\n\n**读操作**\n\n读操作仅涉及两个通道，首先主机在读地址通道（AR）上写入本次传输操作待读取数据的地址以及控制信息；\n\n从机在接收到地址后，将该地址上的数据通过读数据通道（R）传输给主机；\n\n![read_transaction](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/write_transaction.png)\n\n**写操作**\n\n写操作涉及三个通道，主机先在写地址通道（AW）上告知从机本次写传输操作的属性，包括地址和控制信息；然后在写数据通道上（W）向从机写入数据，一次传输操作中可能包括多个数据传输；最后从机在收完写数据后，通过写响应通道将本次传输操作的响应告知主机，作为写传输操作结束的标志。此处应注意，**写回复是针对整个传输（Transaction）操作的，而不是针对每个写入数据（Data Transfer）**\n\n## AXI一些情况的说明\n\n### 跨4K问题\n\n单次Burst传输中的数据，其传输地址不能跨越4K边界，注意此处说的不是容量。因为底层Page的存储容量为4KB，一个Burst的数据必须在同一个Page里，否则会出错；\n\n### Response问题\n\nRead操作每次transfer都会有一个response，而Write操作的每次Burst才有一次response。为什么AXI spec要做如此规定呢？\n\n1. 对于Read操作，spec明确规定必须先写addr，再读read data，那么slave返回read data时，已经能确定该transfer是否成功，因此这时的response是确知的，response就可以和read data一起回给master。\n2. 对于Write操作，addr和data均是从master到slave，而response是从slave到master，因此需要增加一个response通道。那么为什么不是每次transfer都有response？因为**写地址和写数据没有先后依赖关系**，因此，**第n次transfer时，slave可能只收到data，而没收到addr，此时还无法判断response结果**，所以write操作做不到每次transfer都给出response，而是每次burst有一次response。\n\n### 能否提前结束突发传输\n\n通信双方都不能在传输事务的所有Transfer完成前提前结束。哪怕发生错误，也需要走完传输事务的全流程。\n\n但主机也有办法减少传输的数据量：发送方**可以通过置低所有写数据的有效位（WSTRB）信号，使写数据无效**。在读传输事务中，主机可以直接丢弃读取到的数据。\n\n> No component can terminate a burst early. However, to reduce the number of data transfers in a write burst, the Manager can disable further writing by deasserting all the write strobes. In this case, the Manager must complete the remaining transfers in the burst. In a read burst, the Manager can discard read data, but it must complete all transfers in the burst.\n\n### 握手间的依赖关系\n\n双箭头表示强依赖\n\n**读Transaction**\n\n![R_channel_dependency](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/R_channel_dependency.png)\n\n**写Transaction**\n\n![W_channel_dependency](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/W_channel_dependency.png)\n\n### 读写数据结构\n\n在AXI数据传输过程中，主要涉及到窄位宽数据传输（Narrow Transfer）、非对齐传输（Unaligned Transfer）以及混合大小端传输（mix_endianness）等问题。\n\n#### 窄位宽数据传输\n\n当本次传输中数据位宽小于通道本身的数据位宽时，称为窄位宽数据传输。\n\n在窄位宽数据传输中，主机需要告知从机数据通道中哪些字节是有效的，需要使用到写数据通道上的WSTRB信号。**WSTRB信号中的单个bit置起，表示对应位置上的字节有效**。WSTRB信号比特位宽等于数据通道位宽的字节数量，比如32bit位宽的数据通道对应WSTRB信号位宽为4bit。\n\n![narrow_transfer](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/narrow_transfer.png)\n\n#### 非对齐传输\n\nAXI协议支持地址非对齐的传输，允许突发传输的首字节地址，即起始地址与**突发传输位宽**不对齐。举例说明，当总线位宽为32bit时，如果地址为0x1002，则产生了非对齐现象。与32bit位宽总线对齐的地址需要能被4整除，即ADDR[1:0]=2'b0。\n\n**注意**：此处对齐与否应当取决于突发传输的宽度，而不是总线位宽。\n\n对于非对齐传输，主机会进行两项操作：\n\n- 即使起始地址非对齐，也保证所有传输地址是对齐的；\n- 在首个transfer中添加填充数据，将首次传输填充至对齐，填充数据使用WSTRB信号标记为无效。![unaligned_transfer](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/unaligned_transfer.png)\n\n上图是在64位宽的数据总线上传输突发传输位宽为32bit的数据，起始地址为0x07，其中阴影部分是不传输的数据（WSTRB=0）\n\n#### 混合大小端传输\n\n内存中有两种大小端模式，**大端认为高字节（MSB）应该存在低地址，小端认为低字节（LSB）才应该存在低地址。**\n\n为使大小端模式在存储中共存，AXI协议设计了一种字节顺序恒定的（Byte-invariant）的大小端传输方案：\n\n- 无论大小端模式，每个数据结构存储空间的分配方式是相同的；\n- 大小端仅决定低地址是高字节还是低字节，与数据无关；\n- 在传输过程中不考虑数据的大小端，**按字节原先存储的顺序，原样传输并存放至对面**；\n\n这样做的意义在于传输双方均不对数据结构的大小端进行解析，而严格按照字节的存储顺序进行传输并转存。\n\n### 读写回复结构\n\n读写传输事务（Transaction）都存在2bit位宽的回复信号RRESP/BRESP，分别存在4种回复情况，分别为：\n\n1. OKAY，常规访问成功；\n2. EXOKAY，独占访问成功；\n3. SLVERR，从机错误，尽管从机收到了访问请求，但因种种原因向主机返回了一个错误状态，可能包括以下错误场景：FIFO或缓冲区溢出；主机发起了不支持的传输位宽；尝试向读保护的地址写入数据；超时；\n4. DECERR，解码错误，一般由interconnect组件产生，表示主机发送的传输事务地址无效，无法将传输事务发送给某个从机。\n\n协议转换的使用中忽视回复信号，默认都是OKAY。\n\n### AxCACHE信号，缓存相关\n\n含义可参考[深入AXI4总线](https://zhuanlan.zhihu.com/p/148813963)\n\n![AxCACHE](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AxCACHE.png)\n\n**Modifiable**\n\n- 单个传输事务可以被**分解**为多个传输事务\n- 同理，多个传输事务也可被**聚合**为一个\n- 读传输事务中，可以**预取**相邻地址上的读数据，要求目的地址返回比主机需求更多的数据\n- 写传输事务中，可以**访问比需求地址跨度更大的区域**，其中使用 WSTRB 信号防止更新不相关的数据\n\n**cache-allocate**\n\n**allocate**\n\n当前地址的数据可能因为前期的访问，已经分派空间并缓存于 cache 中\n\n**other allocate**\n\n当前地址的数据可缓存于 cache 中，是因为其他主机事务而分派空间缓存，或者是本机其他类型的事务而缓存。（对于读事务来说，就是先前的写事务，反之亦然）\n\n- 当AxCACHE的高两bit为2‘b00时，表示CPU指示该传输事务**无需**至CACHE中查找，**必须直接**从主存储中读取或写入主存储；\n- 当AxCACHE的高两bit为2’b11时，表示该传输事务必须**首先**在CACHE中查找，**缺失的情况下**再访问主存储。\n\n**Bufferable**\n\n表示该传输事务在传输至目的地的途中，**可以被 interconnect 或者任意的 AXI 组件缓存**，延迟若干个周期。一般应用于写传输事务。\n\n注：Write-through访问与Write-back访问的区别，**Write-through**指缓存的写入策略为直写，即**数据写入缓存的同时，也写入主存储器中**；<u>Write-back</u>指缓存的写入策略为写回，<u>数据仅写入缓存，修改的缓存仅在被替换时写入主存储</u>。\n\n### 超前传输\n\n![outstanding_axi](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_axi.jpg)\n\n超前传输是指主机在当前传输事务完成前，就可以开始下一个传输事务。因此**系统中可能存在多个进行中的传输事务。**AXI从机可选地支持超前传输，假设从机不支持超前传输，**只需要在接收到第一次Burst请求后置低AxREADY信号就可以阻止主机超前传输**。\n\n> 从应用角度来思考这个问题，如传输一段数据，假设没有outstanding，必须要等到地址握手成功了才可以传输数据，而每一次握手过程中都不能保证主从机此刻都准备好，那这样在数据传输过程中就难免会有气泡，难以实现真正的全流水和高性能；所以从设计的角度，我们就有多发几个地址的需求，比如我们可以发出去10个地址，尽管我们还没给数据，但是可以让从机知道，我们接下来要向这些地址写数据，这样就可以不用刻板地遵循，每次都要写地址握手成功再写数据。\n>\n> 所以，outstanding就是发出去的地址数量，未处理的地址可以先存放在AXI总线的缓存里，等完成一次传输事物之后，无需再握手传输地址，即可立即进行下一次的数据传输，所以outstanding本质上是为了实现数据传输的pipeline。\n\n使用超前传输深度（outstanding depth）这一指标，衡量一个主机超前传输的能力，表示主机正在进行中的事务数量。**更大的超前传输深度需要更大的缓冲区**用于保存在途事务的信息，并接受缓存读数据。**通过较大的超前传输深度能够提高系统的性能。**\n\n在超前传输**<u>且支持交织功能</u>**的情况中，事务到达顺序与数据就绪顺序是可能不一致的，所以**超前传输需要相应的机制来标识数据所属的事务。**AXI协议在各通道设计了ID信号。\n\n- 主机制定并发送：AWID、ARID用于标识传输事务；\n- 从机制定并发送：RID、BID用于标识数据或者回复，代表传输事务已完成；\n\n以**读事务为例**，协议规定：\n\n1、**对于ARID一致的多个事务，从机必须按照接收事务的顺序返回其读取的数据**；\n\n实现中可以为每个ARID维护一个缓冲区用于维护读数据的顺序；\n\n![outstanding_exp1](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_exp1.png)\n\n上图就是先读出RDATA1，再读出RDATA0，与接收事务的顺序不一致，需要<u>**数据缓冲区与事务缓冲区**</u>的地址匹配后才能进行输出。\n\n2、**具有不同ARID的事务之间可以乱序**，从机只需要维护各个ARID所属事务的返回顺序。**注意RID要与其对应事务的ARID保持一致。**\n\n对于支持不同ARID的从机来说，实现上为每个ARID准备了一个事务与数据缓冲区，就绪数据可以根据RID分配至匹配的处理模块。\n\n![outstanding_exp2](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_exp2.png)\n\n写事务与读事务类似：1、对于**相同AWID的写事务**，从机必须按照主机发出的顺序完成，包括发送的写回复（BID）信号；2、对于**不同的AWID的写事务**，从机完成的顺序没有限制；\n\n> tips：面试问题\n>\n> ID信号对于Outstanding是必须的吗？答：非必须，当没有乱序传输功能时可以省略ID信号，slave端依序即可。\n>\n\n### 多主机场景（Interconnect）\n\n在多主机场景下，如何将多主机的事务独立开是个大问题，有两种办法：\n\n- 各主机保证自己的ID与其他主机不同；\n- 中间节点对不同主机的ID进行调整，即使主机发出的ID一致，也能使从机看到的ID不同；\n\n第一种方法看起来容易，一旦ID不同事务自然独立，但协议并**没有在主机间设立消息共享机制**，因此各主机无法知道其他主机所使用的ID，也就无法保证ID不同。\n\n第二种方法是AXI协议采用的方法，中间的节点指AXI Interconnect组件或者AXI Smartconnect组件。对于Interconnect组件而言：\n\n- 任何主机事务前往任何从机必定经过Interconnect；\n- Interconnect可以从事务的来源端口，判断事务来自哪台主机；\n- 当接收到从机返回的数据后，Interconnect根据其附加在其RID/BID上的主机端口信息，转发至发起事务的主机；\n\nInterconnect的另一个功能是**仲裁**，**决定当前从哪个非空的缓冲区读取事务，输入交换结构**。Interconnect的仲裁共有两种策略：1、轮询：轮流从各个主机的缓存通道读取事务；2、优先级仲裁：优先读取高优先级缓存通道中的事务。\n\n此外，Interconnect还负责**数据的重排序**功能，由Interconnect负责保证数据返回主机的顺序，与主机发出事务的顺序一致，这要求Interconnect具有同从机类似的缓存功能以实现重排序。\n\n---\n\n**Interconnect功能小总结**：\n\n- 转发：ID\n- 仲裁：轮询、优先级\n- 重排序：事务、数据缓冲区\n\n## 参考文献\n\n[AMBA Learning Hub](https://www.zhihu.com/column/c_1251094110297509888)\n\n[AMBA AXI Spec](https://developer.arm.com/documentation/ihi0022/latest)\n\n[跨4K问题](https://blog.csdn.net/lyfwill/article/details/92797912)\n\n[AXI中模棱两可的概念](https://blog.csdn.net/hit_shaoqi/article/details/53243173)","tags":["Basics"],"categories":["IC","AXI"]},{"title":"AXI4与AXI3的区别","url":"/2024/04/15/IC/AXI/AXI4与AXI3的区别/","content":"\n## AXI3和AXI4区别-思维导图\n\n![AXI区别](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI%E5%8C%BA%E5%88%AB.png)\n\n### Brust support\n\nAX4对burst length进行了扩展：\n\nAXI3最大burst length是16 beats；AxLEN位宽是4bit\n\nAXI4支持最大到256 beats，AxLEN位宽是8bit；但是这也是有限制的：\n\n1. 只有INCR burst type支持超过16 beats的Burst；WRAP and FIXED burst types 最大还是支持16 beats的Burst，和AXI3保持一致；\n2. Exclusive accesses 的burst length 必须小于 16.\n\n在实际使用中，很少使用支持超过Burst Length超过16的命令，因为Burst Length太长会一直占用总线，影响了系统性能；而且AXI总线的一个限制就是Burst一旦开始是不能取消的，如果Burst太长，一旦出错，影响比较大。\n\n### AxCACHE Update\n\nAXI3中AxCACHE的含义\n\n![AXI3_Axcache](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI3_Axcache.png)\n\nAXI4中AxCACHE的含义\n\n![AXI4_Axcache](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI4_Axcache.png)\n\n含义可参考[深入AXI4总线](https://zhuanlan.zhihu.com/p/148813963)\n\n**Modifiable**\n\n- 单个传输事务可以被分解为多个传输事务\n- 同理，多个传输事务也可被聚合为一个\n- 读传输事务中，可以预取相邻地址上的读数据，要求目的地址返回比主机需求更多的数据\n- 写传输事务中，可以访问比需求地址跨度更大的区域，其中使用 WSTRB 信号防止更新不相关的数据\n\n**cache-allocate**\n\n**allocate**\n\n当前地址的数据可能因为前期的访问，已经分派空间并缓存于 cache 中\n\n**other allocate**\n\n当前地址的数据可缓存于 cache 中，是因为其他主机事务而分派空间缓存，或者是本机其他类型的事务而缓存。（对于读事务来说，就是先前的写事务，反之亦然）\n\n- 当AxCACHE的高两bit为2‘b00时，表示CPU指示该传输事务**无需**至CACHE中查找，**必须直接**从主存储中读取或写入主存储；\n- 当AxCACHE的高两bit为2’b11时，表示该传输事务必须**首先**在CACHE中查找，**缺失的情况下**再访问主存储。\n\n**Bufferable**\n\n表示该传输事务在传输至目的地的途中，可以被 interconnect 或者任意的 AXI 组件缓存，延迟若干个周期。一般应用于写传输事务。\n\n### Addition write response requirements\n\nAXI3:must wait for both WVALID and WREADY to be asserted before asserting BVALID.\n\n![AXI3_Write](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI3_Write.png)\n\nAXI4:must wait for AWVALID、AWREADY、WVALID、WREADY、and WLAST to be asserted before asserting BVALID.\n\n![AXI4_Write](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI4_Write.png)\n\nAXI3对BVALID的规定其实是有漏洞的，可能Transaction还未真正完成就发送了写响应。AXI4的更新更加合理和严谨。\n\n### Write interleaving\n\nAXI4协议去掉了WID信号，因此不支持写交错。这是AXI4和AXI3一个很重要的改变。\n\n写交错的去除使得在WID信号上传递的信息是多余的。因为所有写入数据必须与相关的写入地址顺序相同，任何需要WID信息的部件都可以从写地址通道的AWID中获得这些信息。\n\n写交错即指在AWID=0的数据还未发送完后，允许AWID=1的数据先发送；这样带来的代价是发送端必须要缓存多个ID的wdata，不管是master还是总线interconnect都必须要增加大量的缓存，所以增加了面积。\n\n此外，写交错增加了系统总线设计的复杂度，且容易造成死锁。所以AXI4就把写交错功能去掉了。\n\n### Locked transactions\n\nAXI4去掉了对locked transaction的支持，对信号的影响就是AxLOCK从AXI3的2-bits减少到了1bit\n\n![AXI3_lock](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI3_lock.png)\n\n![AXI4_lock](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/AXI4_lock.png)\n\n为什么去掉Locked Access呢？按手册的说法(A7.3)，有如下原因\n\n- 大部分组件用不到这个功能\n- 有Locked Access的话会增加互联(interconnect)的复杂性\n\nLocked Access和Exclusive access有哪些区别呢？其实最主要的区别是作用的对象不同。\n\nLocked Access作用的对象为总线，一旦发生Locked Access，那么其它的master都不能通过总线对该Slave进行访问。在一个复杂的SOC系统中，Locked Access对系统的影响太大了。万一发出Locked Access的master出问题，那么系统就会挂死。这种牺牲整个系统来成就某个master的机制当然最后会被淘汰。\n\nExclusive Access作用的对象为对应的Slave，支持Exclusive Access的Slave会实现一个monitor，记录发起Exclusive Access的master的ID，并记录后续发起写过程的master的ID号，进行对比。Exclusive Access对总线系统是没有要求的，只是对slave做了特殊要求。即使出错也不会影响系统的其它部分，最多是Exclusive Access失败而已。\n\n### Quality of service signaling\n\nAXI4增加了2个4bit的QoS命令信号AWQoS、ARQoS。但是AXI4协议没有规定QoS的用法，因为这是一个需要全面考虑的特性。AXI4建议的QoS是AxQoS值越大，优先级越高。\n\n增加QoS信号是随着越来越多的master对总线需求的冲突越来越明显，系统的带宽没有显著提升。那么如何给不同的IP分配不同QoS就是架构师需要考虑的事情，且没有不变的规律可以遵守。\n\n### Region Signals\n\nAXI4为了支持区域标识，增加了AxREGION信号。区域标识符的使用意味着slave不必支持不同逻辑接口之间的地址解码。一般情况下使用地址的高位来区分不同的区域，而采用了区域标识符就不用采用地址解码区分了。另外，通过划分region，对某些physical allocation进行保护，比如某个region能被读写，而某个region只提供读权限。\n\n这是一个可选的功能，ARM自己的CPU都很少支持。\n\n### USER signals\n\nAMBA4中未对USER信号做任何规定，只是建议不要使用这个信号，防止IP直接互联不兼容。一般的IP厂商都不会使用，防止兼容性问题。\n\n## AXI3和AXI4的互联\n\n我们分下面两种情况讨论\n\n### AXI4 master连接到AXI3 slave\n\n1. 因为AXI4没有WID信号，而AXI3有。但我们还不能直接把AXI4 Master的AWID直连到AXI3 slave的WID上，因为如果AXI4 master能发出outstanding的命令，当前的AWID的值和WID的值就不是对应的关系。通常的做法是将AWID缓存到一个FIFO钟，等到传完数据(收到了WLAST)再切换到下一个AWID，把这样读出的AWID当做WID使用。\n2. AXI3的AxLOCK信号是2bit的，直接将AXI3的AxLOCK信号的最低位连接到master上即可\n3. AXI4 master不能产生超过16beat的brust，因为AXI3不支持。\n4. 系统总线要么统一用AXI3，要么统一用AXI4。\n5. AXI3 slave必须注意BVALID的生成要符合AXI4协议，需要修改逻辑。\n6. QoS、USER、REGION等多余的信号需做额外的处理，一般赋默认值。\n\n### AXI3 master连接到AXI4 slave\n\n1. 由于AXI4是没有WID信号的，所以直接把WID浮空就行；\n2.  AXI4 Slave的AxLOCK[0]连接到AXI3 master的AxLOCK即可；\n3. AXI4 Slave的AxLEN[7:4]=4’h0 即可；\n4. 系统总线要么统一用AXI3, 要么统一用AXI4;\n5. QOS/USER/REGION信号等多余的信号需要做额外的处理；\n6. AXI3 master必须不能支持Write interleaving，否则必须修改AXI3 master的逻辑。\n\n## AXI接口部分名词解释\n\n### outstanding\n\n![outstanding_axi](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/outstanding_axi.jpg)\n\n### interleaving\n\nAXI3中有，AXI4中被删除。\n\n![interleave_axi3](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/interleave_axi3.png)\n\n### out-of-order\n\n![out_of_order](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/out_of_order.png)\n\n## AXI Full vs AXI Lite\n\nAXI Lite是AXI Full协议的简化版，主要区别在以下几点\n\n1. 突发长度固定为1；\n2. 数据通路要将数据位宽用满(不支持narrow transfer)，还可以使用WSTRB信号，数据位宽可选32或64；\n3. 所有的访问都是Non-modifiable、Non-bufferable；\n4. 不支持Exclusive access；\n","tags":["Basics"],"categories":["IC","AXI"]},{"title":"Verilog-Mode入门","url":"/2024/04/13/IC/EDA/Verilog-Mode入门/","content":"\n# Verilog Mode\n\n# What\n\nVerilog-mode是Emacs的一种编辑模式，主要面对verilog的开发环境，拥有很方便的自动缩进机制和AUTO机制。AUTO机制是Emacs verilog-mode中一些自动化实现脚本的功能，比如自动填充模块参数列表、自动完成模块例化、自动声明连线等。非常适合顶层模块集成使用，避免Designer的重复劳动和低级错误。\n\n# Why\n\nverilog语法中有很多内容是冗余的，模块中必须出现却起不到什么功能作用，列举如下：\n\n- 模块参数列表和模块端口声明input/output；\n- reg语句和已经被声明为输出的信号；\n- 子模块实例化的连线声明；\n- 子模块的实例化语句和子模块的端口声明；\n- 组合逻辑always语句的敏感信号列表（不过已经可以使用*来代替了）；\n\n可见verilog语法中的冗余信息还是不少的，不过这是语法规则导致的，是语言本身的缺陷，作为使用者只能遵守语法规则。这些冗余信息中比如参数列表和模块例化连线，不仅需要花费时间去编写，而且还特别容易出错，给RTL编写以及后续的修改维护都带来很多问题。那么如果解决这些问题，会带来什么效果呢？个人认为有以下几点：\n\n- 代码整洁，便于阅读；\n- 提高编码效率，尤其是顶层实例化；\n- 减少拼写错误；\n- 便于维护，比如修改、增加和删除端口，无需修改参数列表，比如修改、增加和删除子模块端口，无需修改顶层实例化；\n\n# How\n\nEmacs verilog-mode的AUTO机制，就是在代码中相应的位置写一些/*AUTO*/类似的注释，verilog-mode可以自动替换为所需的内容。Emacs编辑器和verilog-mode的AUTO机制结合，可以很方便的看到AUTO的效果，而且AUTO是以注释形式添加到verilog文件，在语法上本身是合法的，不会影响EDA工具的使用。这个环境也可以在Vim编辑器下使用，举例如下：\n\n## 自动补全\n\n1. 不想写入数据的输入输出信号列表、组合逻辑的敏感信号列表；\n\n> /\\*AUTOARG\\*/：自动生成模块参数表；\n> \n\n> /\\*AUTOSENSE\\*/ or /\\*AS\\*/：自动生成组合逻辑的敏感信号列表；（在verilog 2000中，已经对语法做出了简化，比如使用@(*)来代替敏感信号列表，但是需要EDA工具的支持。不过现在EDA工具都已经支持verilog 2005了，可以将敏感信号列表直接写为@(\\*)即可，所以AUTOSENSE功能可以不使用。）\n> \n\n```verilog\nmodule auto_arg_as(/*AUTOARG*/);\n\t\tinput a;\n\t\tinput b;\n\t\tinput c;\n\t\toutput d;\n/*AUTOREG*/\n\n\t\talways @(/*AS*/)\n\t\t\td = a ^ b ^ c;\nendmodule\n\n//After Auto\nmodule auto_arg_as(/*AUTOARG*/\n\t// Outputs\n\td,\n\t// Inputs\n\ta, b, c\n);\n\tinput a;\n\tinput b;\n\tinput c;\n\toutput d;\n/*AUTOREG*/\n\t// Beginning of automatic regs (for this module's undeclared outputs)\n\treg d;\n\t// End of automatics\n\n\talways @(/*AS*/a or b or c)\n\t\t\td = a ^ b ^ c;\n \nendmodule\n```\n\n1. 不想写内部的wire、reg数据类型定义；\n\n> /\\*AUTOWIRE\\*/：自动补全wire的定义，在重复例化模块时使用，会将内部连线的信号自动生成wire定义；（注意只在重复例化的时候使用，设计功能模块时勿用）\n> \n\n> /\\*AUTOREG\\*/：会将reg类型的output信号补全reg的定义；\n> \n\n## 自动例化与连线\n\n1. 不想例化重复的模块；\n\n如果一个模块被实例化多次，你可以使用verilog的generate语法，也可以使用Emacs verilog-mode的**AUTO_TEMPLATE** 和 **AUTO_INST** 。Verilog-mode向上索引最近的模板，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。\n\n> /\\*AUTO_TEMPLATE\\*/：TEMPLATE中的模块名称必须与实例中的模块名称相同，并且只需列出每次实例化时不同的那些信号就好了，要遵守此格式（每行只有一个端口，并且以逗号结尾，最后以分号结尾）\n> \n\n> /\\*AUTOINST\\*/：如果没有/\\*AUTO_TEMPLATE\\*/，则/\\*AUTOINST\\*/会自动补全信号列表，默认实例化的端口名与子模块的端口名一致，如果不一致需要手动将不一致的端口连线，/\\*AUTOINST\\*/不会重复覆盖；如果有/\\*AUTO_TEMPLATE\\*/，Verilog-mode会向上索引最近的模板，按模板的格式进行例化，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。\n> \n\n> /\\*AUTOINSTPARAM\\*/：在实例化时自动填充参数列表；\n> \n\n> /\\*AUTOINPUT\\*/、/\\*AUTOOUTPUT\\*/：在top层中，一般只有子模块的例化，没有任何其它粘合逻辑，这也是最好的。这时top层通过 **AUTOWIRE** 声明了子模块的输出连线，**AUTOINST** 实现了子模块的实例化，其余未声明的信号，就是top模块的输入输出信号，我们可以通过  **AUTOINPUT AUTOOUTPUT** 完成输入输出信号的声明。特别注意Top层仅做例化，不包括其他逻辑。\n> \n\n```verilog\nmodule submod(/*AUTOARG*/);\n\tinput  [1:0]  in_a;\n\tinput  [1:0]  in_b;\n  output [1:0]  out_a;\n\toutput [1:0]  out_b;\n\n\tassign out_a = in_a ^ in_b;\n\tassign out_b = in_a | in_b;\t\n\nendmodule\n```\n\n```verilog\nmodule submod_wrapper0(/*AUTOARG*/);\n/*****************************\\\n\t\tI/O\n\\*****************************/\n\t/*AUTOINPUT*/\n\t/*AUTOOUTPUT*/\n\n/*****************************\\\n\t\tSignal\n\\*****************************/\n\t/*AUTOWIRE*/\n\n/*****************************\\\n\t\tInst\n\\*****************************/\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(din_\\1[]),\n\t.out_\\(.*\\)(dout_stage1_\\1[]),\n);*/\nsubmod u_submod_0(/*AUTOINST*/);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(dout_stage1_\\1[]),\n\t.out_\\(.*\\)(dout_stage2_\\1[]),\n);*/\nsubmod u_submod_1(/*AUTOINST*/);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(dout_stage2_\\1[]),\n\t.out_\\(.*\\)(dout_\\1[]),\n);*/\nsubmod u_submod_2(/*AUTOINST*/);\n\nendmodule\n//Local Variables:\n//verilog-library-directories:(\".\")\n//End:\n\n//**********************************************************\n//          \t           After Auto\n//**********************************************************\nmodule submod_wrapper0(/*AUTOARG*/\n\t//Outputs\n\tdout_b, dout_a,\n\t//Inputs\n\tdin_b, din_a\n);\n/*****************************\\\n\t\tI/O\n\\*****************************/\n\t/*AUTOINPUT*/\n\t//Beginning of automatic inputs (from unused autoinst inputs)\n\tinput [1:0]  din_a;    // To u_submod_0 of submod.v\n\tinput [1:0]  din_b;    // To u_submod_0 of submod.v\n\t//End of automatics\n\t/*AUTOOUTPUT*/\n\t//Beginning of automatic outputs (from unused autoinst outputs)\n  output [1:0]  dout_a;    // To u_submod_2 of submod.v\n\toutput [1:0]  dout_b;    // To u_submod_2 of submod.v\n\t//End of automatics\n\n/*****************************\\\n\t\tSignal\n\\*****************************/\n\t/*AUTOWIRE*/\n\twire [1:0]    dout_stage1_a;    //From u_submod_0 of submod.v\n\twire [1:0]    dout_stage1_b;    //From u_submod_0 of submod.v\n\twire [1:0]    dout_stage2_a;    //From u_submod_1 of submod.v\n\twire [1:0]    dout_stage2_b;    //From u_submod_1 of submod.v\n\t//End of automatics\n\n/*****************************\\\n\t\tInst\n\\*****************************/\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(din_\\1[]),\n\t.out_\\(.*\\)(dout_stage1_\\1[]),\n);*/\nsubmod u_submod_0(/*AUTOINST*/\n\t// Outputs\n\t.out_a    (dout_stage1_a[1:0]),  // Templated\n\t.out_b    (dout_stage1_b[1:0]),  // Templated\n\t// Inputs\n\t.in_a    (din_a[1:0]),           // Templated\n\t.in_b    (din_b[1:0])            // Templated\n);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(dout_stage1_\\1[]),\n\t.out_\\(.*\\)(dout_stage2_\\1[]),\n);*/\nsubmod u_submod_1(/*AUTOINST*/\n\t// Outputs\n\t.out_a    (dout_stage2_a[1:0]),  // Templated\n\t.out_b    (dout_stage2_b[1:0]),  // Templated\n\t// Inputs\n\t.in_a    (dout_stage1_a[1:0]),   // Templated\n\t.in_b    (dout_stage1_b[1:0])    // Templated\n);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(dout_stage2_\\1[]),\n\t.out_\\(.*\\)(dout_\\1[]),\n);*/\nsubmod u_submod_2(/*AUTOINST*/\n\t// Outputs\n\t.out_a    (dout_a[1:0]),         // Templated\n\t.out_b    (dout_b[1:0]),         // Templated\n\t// Inputs\n\t.in_a    (dout_stage2_a[1:0]),   // Templated\n\t.in_b    (dout_stage2_b[1:0])    // Templated\n);\nendmodule\n//Local Variables:\n//verilog-library-directories:(\".\")\n//End:\n```\n\n### 取消输出\n\n比如我们尝试在TOP模块做一个glue logic，将两个模块的输出接口（如a_dfx[15:0]和b_dfx[15:0]）组合为一个输出接口（dfx[31:0]）进行输出。如果使用/\\*AUTOOUTPUT\\*/方法，会将a_dfx[15:0]，b_dfx[15:0]也放到输出口，此时我们就需要**verilog-auto-output-ignore-regexp**方法来对这类接口进行特殊处理，避免将其放到输出端口上。代码示例如下，其中将匹配到‘_dfx’的信号全部ignore。\n\n```verilog\nmodule abc(/*AUTOARG*/);\n/*AUTOINPUT*/\n/*AUTOOUTPUT*/\n/*AUTOWIRE*/\nassign dfx = {a_dfx[15:0], b_dfx[15:0]};\nmodule u_1(/*AUTOINST*/);\nmodule u_2(/*AUTOINST*/);\nendmodule\n//Localvariables:\n//verilog-auto-output-ignore-regexp:(\"_dfx\")\n//END:\n```\n\n### 正则匹配\n\n在顶层实例化时，有大量的信号需要重新命名，使用模板的话会增加大量的注释内容，不过往往这些信号命名有特定的规律，我们可以使用正则表达式来处理；\n\n@在正则匹配中匹配到例化名称中最前面的连续数字；建议使用 @ 来匹配例化名称中的数字，使用正则来匹配信号中的数字；\n\n> @ in the template takes the leading digits from the reference.\n> \n\n```verilog\n// 提取信号中固定位置的数字\n.pci_req\\([0-9]+\\)_j   (pci_req_jtag_[\\1]),\n.pci_req12_j           (pci_req_jtag_[12]),\n//---------------------------------------------\n// 删除末尾下划线内容\n.\\(.*\\)_j              (\\1[]),\n.pci_req_j             (pci_req[7:0]),\n//---------------------------------------------\n// 对信号矢量化处理(将@改为\\([0-9]+\\)也是可以的)\n.\\(.*[^0-9]\\)@    (\\1[\\2]),\n.pci_req0         (pci_req[0]),\n.pci_req1         (pci_req[1]),\n.pci_req2         (pci_req[2]),\n.pci_req3         (pci_req[3]),\n```\n\n```verilog\nmodule submod_wrapper1(/*AUTOARG*/);\n/*****************************\\\n\t\tI/O\n\\*****************************/\n\t/*AUTOINPUT*/\n\t/*AUTOOUTPUT*/\n\n/*****************************\\\n\t\tSignal\n\\*****************************/\n\t/*AUTOWIRE*/\n\n/*****************************\\\n\t\tInst\n\\*****************************/\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(din_\\1_@[]),\n\t.out_\\(.*\\)(dout_\\1_@[]),\n);*/\nsubmod u_submod_0(/*AUTOINST*/);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(din_\\1_@[]),\n\t.out_\\(.*\\)(dout_\\1_@[]),\n);*/\nsubmod u_submod_1(/*AUTOINST*/);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(din_\\1_@[]),\n\t.out_\\(.*\\)(dout_\\1_@[]),\n);*/\nsubmod u_submod_2(/*AUTOINST*/);\n\nendmodule\n//Local Variables:\n//verilog-library-directories:(\".\")\n//End:\n\n//**********************************************************\n//          \t           After Auto\n//**********************************************************\nmodule submod_wrapper1(/*AUTOARG*/\n\t//Outputs\n\tdout_b_2, dout_b_1, dout_b_0, dout_a_2, dout_a_1, dout_a_0,\n\t//Inputs\n\tdin_b_2, din_b_1, din_b_0, din_a_2, din_a_1, din_a_0\n);\n/*****************************\\\n\t\tI/O\n\\*****************************/\n\t/*AUTOINPUT*/\n\t//Beginning of automatic inputs (from unused autoinst inputs)\n\tinput [1:0]  din_a_0;    // To u_submod_0 of submod.v\n\tinput [1:0]  din_a_1;    // To u_submod_1 of submod.v\n\tinput [1:0]  din_a_2;    // To u_submod_2 of submod.v\n\tinput [1:0]  din_b_0;    // To u_submod_0 of submod.v\n\tinput [1:0]  din_b_1;    // To u_submod_1 of submod.v\n\tinput [1:0]  din_b_2;    // To u_submod_2 of submod.v\n\t//End of automatics\n\t/*AUTOOUTPUT*/\n\t//Beginning of automatic outputs (from unused autoinst outputs)\n  output [1:0]  dout_a_0;    // To u_submod_0 of submod.v\n\toutput [1:0]  dout_a_1;    // To u_submod_1 of submod.v\n\toutput [1:0]  dout_a_2;    // To u_submod_2 of submod.v\n\toutput [1:0]  dout_b_0;    // To u_submod_0 of submod.v\n\toutput [1:0]  dout_b_1;    // To u_submod_1 of submod.v\n\toutput [1:0]  dout_b_2;    // To u_submod_2 of submod.v\n\t//End of automatics\n\n/*****************************\\\n\t\tSignal\n\\*****************************/\n\t/*AUTOWIRE*/\n\n/*****************************\\\n\t\tInst\n\\*****************************/\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(din_\\1[]),\n\t.out_\\(.*\\)(dout_stage1_\\1[]),\n);*/\nsubmod u_submod_0(/*AUTOINST*/\n\t// Outputs\n\t.out_a    (dout_a_0[1:0]),  // Templated\n\t.out_b    (dout_b_0[1:0]),  // Templated\n\t// Inputs\n\t.in_a    (din_a_0[1:0]),           // Templated\n\t.in_b    (din_b_0[1:0])            // Templated\n);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(dout_stage1_\\1[]),\n\t.out_\\(.*\\)(dout_stage2_\\1[]),\n);*/\nsubmod u_submod_1(/*AUTOINST*/\n\t// Outputs\n\t.out_a    (dout_a_1[1:0]),  // Templated\n\t.out_b    (dout_b_1[1:0]),  // Templated\n\t// Inputs\n\t.in_a    (din_a_1[1:0]),   // Templated\n\t.in_b    (din_b_1[1:0])    // Templated\n);\n\n/*submod AUTO_TEMPLATE(\n\t.in_\\(.*\\)(dout_stage2_\\1[]),\n\t.out_\\(.*\\)(dout_\\1[]),\n);*/\nsubmod u_submod_2(/*AUTOINST*/\n\t// Outputs\n\t.out_a    (dout_a_2[1:0]),         // Templated\n\t.out_b    (dout_b_2[1:0]),         // Templated\n\t// Inputs\n\t.in_a    (din_a_2[1:0]),   // Templated\n\t.in_b    (din_b_2[1:0])    // Templated\n);\nendmodule\n//Local Variables:\n//verilog-library-directories:(\".\")\n//End:\n```\n\n## 获取模块路径\n\n现在我们可能会好奇，Verilog-Mode如何知道给定的模块声明的路径。\n\nverillog-mode首先在当前文件中查找，以防您在那里定义了多个模块。然后它在verilog-library-extensions中查找带有每个扩展名的模块名，通常是一个'.v'。最后，它在每个定义了在verilog-library-directories的目录中搜索。\n\n因此，如果我们有一个需要在子目录中查找子模块的顶级模块，我们需要告诉verilog-mode在子目录中查找。最好的方法是在每个需要库变量的Verilog文件的末尾定义它们：\n\n```verilog\n// Local Variables:\n// verilog-library-directories:(\".\" \"subdir\" \"subdir2\")\n// verilog-library-files:(\"/some/path/technology.v\" \"/some/path/tech2.v\")\n// verilog-library-extensions:(\".v\" \".h\")\n// End:\n```\n\n这三个变量的作用如下:\n`verilog-library-directories`\n变量`verilog-library-directories`包含了要在其中查找模块的目录列表，至少应包含当前目录。\n`verilog-library-extension`\n变量`verilog-library-extensions`包含一个文件扩展名列表，试图将其附加到模块名以生成文件名。通常只是“.v”。\n`verilog-library-files`\n变量`verilog-library-files`包含一个文件列表，这些文件将完整地搜索模块。这通常是到技术文件的完整路径，其中定义了许多标准单元。\n\n## 参考资料\n\nverilog-mode还有其他实用的功能，不过掌握其20%的知识足够应付80%的场景了。其余的功能还包括缩进对齐，自动补齐复位信号等。不过还是建议只在顶层连线使用verilog-mode功能，内部的IP设计还是需要各Designer仔细检查。\n\n[Verilog-Mode User Guide](https://veripool.org/verilog-mode/help/)\n\n[Verilog-Mode使用方法总结](https://www.cnblogs.com/Alfred-HOO/articles/16366743.html)","tags":["EDA"],"categories":["IC","EDA"]},{"title":"聊聊git的revert","url":"/2024/04/08/Git/聊聊git的revert/","content":"\n# Git的revert命令\n\ngit的revert命令用来取消某次特定的提交内容。\n\n当我们使用revert命令时，需要考虑两种情况。因为commit就分两种类型：一种是常规的commit，也就是使用`git commit`命令得到的commit；另一种是merge commit，在使用`git merge`合并两个分支后，我们会得到一个新的merge commit。\n\nmerge commit和普通commit的不同之处在于，merge commit包含两个parent commit，代表merge commit是从哪两个commit合并而来。\n\n![Snipaste_2024-04-07_21-58-15](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/Snipaste_2024-04-07_21-58-15.png)\n\n在上图所示的红框中有一个 merge commit，使用 `git show` 命令可以查看 commit 的详细信息\n\n```shell\n$ git show 422ecbc\ncommit 422ecbc384c9e091a4990789f890661055ae1c9e (HEAD -> master)\nMerge: 26407b4 3d0cd1e\n```\n\n这代表该 merge commit 是从 26407b4和 3d0cd1e两个 commit 合并过来的。\n\n而常规的commit则没有“Merge”行\n\n```shell\n$ git show b086f02\ncommit b086f02120d257965a0d340d5442ad83df4c591f\n```\n\n## revert常规commit\n\n使用`git revert <commit id>`即可，git 会生成一个新的 commit，将指定的 commit 内容从当前分支上撤销掉。\n\n## revert merge commit\n\nrevert merge commit 有一些不同，这时需要添加 `-m` 选项，用来表示这次 revert 的是一个merge commit\n\n但如果直接使用 git revert，git 也不知道到底要撤除哪一条分支上的内容，这时需要指定一个 parent number 标识出\"主线\"，主线的内容将会保留，而另一条分支的内容将被 revert。\n\n如上面的例子中，从 `git show` 命令的结果中可以看到，merge commit 的 parent 分别为 26407b4和 3d0cd1e，其中“26407b4”代表 master 分支（从图中可以看出），“3d0cd1e”代表DEV 分支。需要注意的是 -m 选项接收的参数是一个数字，数字取值为 1 和 2，也就是 Merge 行里面列出来的第一个还是第二个。\n\n我们要 revert DEV 分支上的内容，即 保留主分支，应该设置主分支为主线，操作如下：\n\n```shell\ngit revert -m 1 422ecbc\n```\n\n## revert之后重新上线\n\n假设我们在自己的分支 david/a-cool-feature 上开发了一个功能，并合并到了 master 上，之后 master 上又提交了一个修改 h，这时提交历史如下：\n\n```rust\na -> b -> c -> f -- g -> h (master)\n           \\      /\n            d -> e   (david/a-cool-feature)\n```\n\n突然，大家发现David的分支存在严重的 bug，需要 revert 掉，于是大家把 g 这个 merge commit revert 掉了，记为 G，如下：\n\n```rust\na -> b -> c -> f -- g -> h -> G (master)\n           \\      /\n            d -> e   (david/a-cool-feature)\n```\n\n然后David回到自己的分支进行 bugfix，修好之后想重新合并到 master，**直觉上**只需要再 merge 到 master 即可，像这样：\n\n```rust\na -> b -> c -> f -- g -> h -> G -> i (master)\n           \\      /               /\n            d -> e -> j -> k ----    (david/a-cool-feature)\n```\n\ni 是新的 merge commit。但需要注意的是，这 **不能** 得到我们期望的结果。因为现在的merge是基于G和k进行merge，又因为“d”和“e”两个提交曾经被“G”丢弃过，所以如此合并到 master 的代码，并不会重新包含“d”和“e”两个提交的内容，相当于只有 david/a-cool-feature 上的新 commit “j”和“k”被合并了进来，而 david/a-cool-feature 分支之前的内容，依然是被 revert 掉了。\n\n所以，如果想恢复整个 david/a-cool-feature 所做的修改，应该先把“G” revert 掉：\n\n```rust\na -> b -> c -> f -- g -> h -> G -> G' -> i (master)\n           \\      /                     /\n            d -> e -> j -> k ----------    (david/a-cool-feature)\n```\n\n其中 G' 是对 G 的 revert 操作生成的 commit，把之前撤销合并时丢弃的代码恢复了回来，然后再 merge david的分支，把解决 bug 写的新代码合并到 master 分支。","tags":["Git"],"categories":["Git"]},{"title":"Git常用命令","url":"/2024/04/01/Git/Git常用命令/","content":"\n## 学习网址\n\n[Git教程|菜鸟教程](https://www.runoob.com/git/git-tutorial.html)\n[Pro-Git](https://git-scm.com/book/en/v2)\n\n## 前言\n此处主要是记录一些有用但之前自己所用较少的命令，并不包括一些最基础的命令，入门的话可以去看菜鸟教程的Git教程。\n\n## 记录仓库变动\n### git rm\n要从 Git 中移除一个文件，必须先将其从跟踪文件中移除（更准确地说，是从暂存区域中移除），然后再提交。`git rm` 命令就能做到这一点，同时还能将文件从工作目录中移除，这样下次提交时就不会看到它是未跟踪文件了。\n```shell\n$ git rm PROJECTS.md\nrm 'PROJECTS.md'\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    deleted:    PROJECTS.md\n```\nTips：可认为是rm file + git add file的结合体。\n```shell\n$ git rm --cached README\n```\n`git rm --cached`命令的功能是将文件从 Git 的暂存区中移除，这样这些文件就不会被包含在下一次的提交中。然而，这些文件仍然会保留在你的工作目录中，这样你就可以继续对它们进行修改，而不会丢失文件的内容。\n\n```shell\n$ git rm log/\\*.log\n```\n注意 * 前面的反斜线 (\\)，这是通配符的表达方式。这条命令会删除 log/ 目录下所有扩展名为 .log 的文件。\n### git mv\n主要用于在仓库中重命名一个已跟踪的文件。\n```shell\ngit mv file_from file_to\n```\n等价于下面的代码\n```shell\n$ mv file_from file_to\n$ git rm file_from\n$ git add file_to\n```\n## 查看提交历史\n查看每次提交的简短统计信息，可以加上`--stat`选项；(常用)\n```shell\ngit log --stat\n```\n忽略所有merge的log，使用`--no-merges`选项；(常用)\n查看特定路径或者文件的提交log；(常用)\n\n```shell\ngit log file_name/location_name\n```\n还可以使用`--pretty=format`定制化内容的输出格式；\n或者使用`--pretty`选项搜寻满足特定条件的提交，可以包括对日期，作者，修改文件的约束；\n使用`--graph`选项在日志旁以图形化方式显示分支和合并历史；\n\n### git reflog\n`git reflog`是 Git 的一个命令，用于查看本地仓库中 HEAD 和分支的移动历史记录。它记录了本地仓库中的引用（reference）的变动情况，包括分支切换、提交、重置等操作，但不包括远程引用的变动。\n该命令主要的使用场景有：当你意外地删除分支、回退到错误的提交、或者执行了其他误操作时(如git reset --hard)，可以使用 git reflog 找回之前的引用状态，然后进行恢复操作。通过查看 reflog，你可以找到误操作之前的引用状态，并恢复到正确的状态。\n\n## 撤销动作\n### git commit --amend\n`git commit --amend`允许你修改最新的提交，举例说明：假设你已经提交了一个修改，但后来发现有些内容遗漏了或者需要进行修正。且你不想创建一个新的提交来修正这些问题，因为这会使你的提交历史变得混乱。这时候，你可以使用`git commit --amend`命令。\n```shell\ngit commit -m 'Initial commit'\ngit add forgotten_file\ngit commit --amend\n```\n这会将`Initial commit`提交的内容与forgotten_file的commit合并，但提交历史上只保留一条记录。综上，`git commit --amend`命令允许你修改最新的提交，同时保持提交历史的整洁性。\n有了该命令，我们就可以及时将工作区的修改内容进行commit，防止内容的丢失，后面都使用`--amend`选项保持提交历史的整洁，最后万事俱备再push上库。\n### git reset HEAD \\<file\\>\n取消暂存区文件的提交，或者使用下面的命令：\n```shell\ngit restore --staged <file>\n```\n### git checkout \\<file\\>\n撤销工作区对文件的修改；\n也可以使用下面的命令：\n```shell\ngit restore <file>\n```\n如此看来`git restore`命令更加统一好用，同时也会出现在git的提示消息中；\n### 撤销commit(慎用)\n1.撤销并保留修改：\n如果你想保留修改但是撤销最新的提交，可以使用以下命令：\n\n```shell\ngit reset --soft HEAD~1\n```\n这个命令会将 HEAD 移动到上一个提交，并将你的修改保留在工作目录和暂存区中，以便你可以继续修改并重新提交。\n2.撤销并丢弃修改：\n如果你想完全撤销最新的提交，并且不保留任何修改，可以使用以下命令：\n```shell\ngit reset --hard HEAD~1\n```\n这个命令会将 HEAD 移动到上一个提交，并且会丢弃你的修改，恢复到上一个提交的状态。\n也可以用具体的提交哈希值来代替 HEAD~1，比如 git reset --soft <commit_hash> 或 git reset --hard <commit_hash>。\n需要注意的是，如果你的提交已经被推送到了远程仓库，并且其他人已经基于该提交进行了工作，撤销提交可能会导致一些问题。在这种情况下，最好与团队成员讨论，以确保撤销提交不会对项目产生负面影响。(可以使用后面所说的`git revert`命令来解决)\n也就是说你可以修改没有push的commit，已经push的commit回退版本时要慎重，最好**通过提交新的更改来修复问题，而不是直接撤销提交**。这样可以保持提交历史的完整性，同时避免影响其他人的工作。\n## 远端仓库相关\n### git fetch\n\ngit fetch 命令用于从远程仓库下载最新的提交和数据到你的本地仓库，**但它不会合并这些改变到你的当前工作分支**。其作用包括：\n1. 更新远程跟踪分支： 执行 git fetch 后，Git 会下载远程仓库中的最新提交和数据，并将它们保存在本地仓库中。这些数据包括远程分支（如 origin/master）的引用，它们跟踪了远程仓库的状态。\n\n2. 获取最新提交： git fetch 会将远程仓库中的最新提交下载到本地，但不会修改你的工作目录或当前工作分支。这使得你可以查看远程仓库的最新状态，然后决定是否需要合并或拉取这些提交到你的工作分支。\n\n设想如下场景，你的同事新建了一分支，名为\"branch_a\"，并push到远端仓库。这时候你在本地，想直接拉取该分支，使用`git pull origin branch_a`命令时会报错，因为你没有将远端仓库的提交和数据下载到你的本地仓库，你的本地仓库中并没有“branch_a”的信息。要么你现在当前分支运行`git pull`命令获取远端仓库的最新提交和数据；要么先运行`git fetch`的命令，获取“branch_a\"的分支信息，再进行后续的分支切换与拉取。\n### git remote rename\n给远端仓库重命名：\n```shell\n$ git remote rename pb paul\n$ git remote\norigin\npaul\n```\n取消远端仓库重命名：\n```shell\n$ git remote remove paul\n$ git remote\norigin\n```\n## 标签相关\n### 查看标签\n列出仓库中所有的tag，还可以搜索特定pattern的标签：\n```shell\n$ git tag -l \"v1.8.5*\"\nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\n```\n### 创建标签\nGit 支持两种类型的标签：轻量级标签和注释标签。轻量级标签可以理解为给commit的hash值重命名，没有任何额外信息，而注释标签可以保存创建标签的作者，注释和日期等信息；\n下面是创建注释标签(Annotated Tags)的示例，在创建tag时需要增加`-a`的选项：\n```shell\n$ git tag -a v1.4 -m \"my version 1.4\"\n$ git tag\nv0.1\nv1.3\nv1.4\n```\n\n```shell\n$ git show v1.4\ntag v1.4\nTagger: Ben Straub <ben@straub.cc>\nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    Change version number\n```\n轻量级标签只需要在`git tag`后添加标签名即可：\n```shell\n$ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5\n```\n\n```shell\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    Change version number\n```\n如果我们要给之前的某个commit打标签的话，只需要在`git tag`后加入commit的hash值即可，如：\n```shell\ngit tag -a v1.2 -m \"my version 1.2\" 9fceb02\n```\n### 推送标签\n默认情况下，`git push`不会将tag信息push上库，除非显式地指定，与分支上库相同，将tag同步到远端仓库的命令为：`git push origin <tag_name>`\n```shell\n$ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -> v1.5\n```\n如果有许多tag要推送上库的话，可以使用`--tags`选项\n```shell\n$ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -> v1.4\n * [new tag]         v1.4-lw -> v1.4-lw\n```\n### 删除标签\n删除标签有如下命令，本地删除tag：\n```shell\n$ git tag -d v1.4-lw\nDeleted tag 'v1.4-lw' (was e7d5add)\n```\n删除远端仓库的tag：`git push origin --delete <tagname>`\n### 切换标签\n如果你想切换标签，可以使用`git checkout <tag_name>`即可。需要注意的是，在 \"分离 HEAD \"状态下，如果你做了修改，然后又创建了一个提交，tag将保持不变，但你的新提交将不属于任何分支，而且除了通过准确的提交哈希值访问外，将无法访问。因此，如果你需要进行修改，比如修复旧版本上的一个 bug，一般会先基于tag创建一个分支。\n```shell\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n```\n上述命令是基于tag v2.0.0创建分支version2并切换到version2分支，这样的话我们可以基于v2.0.0继续开发。\n## 分支相关\n将本地分支与远端分支相关联，下面的示例代码是将当前的工作分支与远端的serverfix相关联；\n```shell\ngit checkout --track origin/serverfix\n```\n新建分支并与远端分支相关联：\n```shell\ngit checkout -b <branch> <remote>/<branch>\n```\n> Tips：有上述命令的快捷方式，较为常用。如果你要检出的分支名称（a）不存在，（b）只与一个远程上的名称完全匹配，同时满足a和b条件的话，Git会自动帮你创建一个跟踪分支。\n\n查看已设置的跟踪分支，并列出本地分支的各种信息，包括跟踪的远端分支名，是ahead or behind；\n```shell\ngit branch -vv\n```\n删除远端分支：\n```shell\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n```\n### git rebase\n`git rebase`功能与`git merge`类似，区别在于log比较干净。适用于在推送之前进行rebase，确保log干净后再push上库，而不要对已推送的库上的内容进行rebase。\n```shell\ngit rebase <base_branch> <topic_branch>\n```\n一. 进行分支合并\n`git rebase` 主要用于将一个分支的提交移动到另一个分支上，常用于将一个分支的提交合并到另一个分支上。相较于`git merge`的优点在于commit log里没有\"merge xxx into xxx\"的日志，看着比较舒服。下面示例将演示如何使用 `git rebase` 将一个分支的提交合并到另一个分支上。\n\n假设我们有两个分支：`feature` 和 `master`。我们想要将 `feature` 分支上的提交合并到 `master` 分支上。\n\n1. 首先，我们需要切换到 `feature` 分支：\n\n```bash\ngit checkout feature\n```\n\n2. 然后，我们运行 `git rebase` 命令来将 `master` 分支上的提交移动到 `feature` 分支上，可以执行以下命令：\n\n```bash\ngit rebase -i master\n```\n\n3. 在执行上述命令后，Git 会将 `master` 分支上的提交逐个应用到 `feature` 分支上。如果在此过程中出现冲突，需要解决冲突并继续 rebase 过程。可以使用 `git status` 命令查看冲突的文件，并手动解决冲突。\n\n4. 解决完冲突后，使用以下命令继续 rebase 过程：\n```bash\ngit add <conflicted_file>\ngit rebase --continue\n```\n\n5. 重复步骤 3 和步骤 4，合并后进行merge完成feature的合并。\n```bash\ngit checkout master\ngit merge feature\n```\n\n通过以上步骤，我们使用 `git rebase` 将 `feature` 分支上的提交合并到了 `master` 分支上。这种方式可以使得提交历史保持线性，并且可以减少不必要的合并提交。**使用rebase命令时一定切记，我们是否会修改其他同事也能看到的已经存在的commit内容，如果是，则不要使用rebase，尽量使用merge。**\n\n如果远端仓库的分支名为master，在我们想push修改时，其他同事也在master上有修改，我们可以使用`git pull --rebase`，commit log是线性的，在rebase后再进行`git push`操作。需要注意的是使用`git pull --rebase`时，**仓库内不能有modified的文件**，我们可以在pull之前使用`git stash`命令。\n参考资料：\n[git pull --rebase的正确使用](https://juejin.cn/post/6844903895160881166)\n[merging vs. rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)\n\n二. 进行多次commit的合并\n设想我们在新分支上进行了对同一文件进行了多次commit，有较多的历史信息，为了log的整洁性，我们希望把这多次commit进行整合，合并为一次commit，并修改提交信息。比如我们希望将最近的三次commit修改为一次commit，依次进行下面操作。\n要使用 Git rebase 将最近的三个 commit 合并为一个 commit 并修改 commit 信息，你可以按照以下步骤进行操作：\n\n1. 执行 `git rebase -i HEAD~3` 命令来启动交互式 rebase。这将打开一个文本编辑器，列出了最近的三个 commit。\n2. 在编辑器中，你会看到一个包含了最近三个 commit 的列表，每个 commit 都有一个前缀为 \"pick\" 的行。将除了第一个 commit 之外的所有 \"pick\" 行的前缀改为 \"squash\" 或 \"s\"（表示合并），这样 Git 将会将它们合并到第一个 commit 中。\n3. 保存并关闭编辑器。Git 将会继续 rebase 操作，并在需要的时候打开另一个编辑器，以便你编辑合并后的 commit 信息。\n4. 在新的编辑器中，修改合并后的 commit 信息，以反映你所做的更改。保存并关闭编辑器。\n5. 完成 rebase 操作后，你可能需要解决任何可能出现的合并冲突。Git 会提示你在 rebase 过程中遇到的任何冲突，并提供解决冲突的指导。\n6. 最后，使用 `git log` 确认你的 commit 已经合并并修改成功。\n\n以下是一个简单的示例：\n\n```bash\ngit rebase -i HEAD~3\n```\n\n编辑器中的内容：(其中git会提供较多的选项，我们按需选择就行)\n\n```\npick 1234567 Commit message 1\nsquash abcdefg Commit message 2\nsquash hijklmn Commit message 3\n```\n\n编辑器中的内容：\n\n```\n# This is a combination of 3 commits.\n# This is the new commit message.\n```\n\n保存并关闭编辑器，然后解决可能出现的冲突，最后确认合并结果。\n## 工作流程\n### 空白行track\n在git commit之前，运行下面命令检查是否track了空白行：\n```shell\ngit diff --check\n```\n将开发分支合并到主分支上时，可以使用`git merge --squash`命令，它是 Git 中用于合并分支并压缩提交历史的命令。它的作用是**将一个分支上的所有提交压缩成一个提交**，并将这个提交合并到当前分支上，适用于需要保持提交历史清晰、整洁的情况。\n### 三点语法\n查看分支上(contrib)相对于主分支(master)的所有改动情况，可以使用`git diff master...contrib`来查看，该命令只显示当前主题分支与主分支的共同节点之后引入的工作。\n### 离线归档\n准备release版本时，可以使用`git archive`命令创建一个zip的归档文件，供那些不使用git的人查看或进行代码备份。\n使用`git log --no-merges master --not v1.0`查看master分支自tag v1.0后的所有改动，不包括merge的变动，可以整理查看所有的改动情况。\n### 两点语法\n设想如下场景，你的主分支名字叫master，为新开发特性，新建分支featureA，随后master和featureA分支各自并行进行。最后featureA开发完毕，准备合并进入master时，你想看一下哪些commit是仅在featureA上而不在master上(因为我们是基于master新建的分支featureA，所以它也继承了之前master分支上的log)，你可以使用下面命令：`git log master..featureA`。\n同理，想将本地push到远程，并查看有什么新的commit时，可以使用如下命令：`git log origin/master..HEAD`。其中下面两种写法与两点的语法同理：\n\n```shell\ngit log ^master featureA\ngit log featureA --not master\n```\n通过上面的语法，我们可以更进一步：\n```shell\ngit log refA refB ^refC\ngit log refA refB --not refC\n```\n---\n如果我们在一个文件中一次修改多个bug，但想分段进行commit，也就是分不同的修改部分进行commit，这时我们可以使用`git add -p`选项进行修改内容的选择跟踪。\n### git stash\n使用场景：当你正在进行一些修改，但需要切换到其他分支或者处理其他任务时，可以使用 git stash 临时保存当前工作目录的修改。这样可以避免将未完成的工作提交到版本库，保持工作目录的干净和整洁。使用`git stash`或者`git stash push`命令。使用`git stash list`查看stash列表，使用`git stash apply`将存储的状态取出来(取出来但还不会在list中删除，如果想取出随后就删除，请使用`git stash pop`命令)，默认取出的stash是**最新压栈**的。\n当你只想保存工作目录中的部分修改，而不是全部修改时，可以先将需要提交的修改添加到暂存区中，然后运行`git stash --keep-index`命令保存工作目录的修改。这样可以确保保存的修改不包含已经暂存的部分。\n`git stash -u`是 Git 中 git stash 命令的一个选项，它用于将当前工作目录的修改临时保存到存储中，并且**包括未跟踪的文件**。\n最后，如果我们增加“--patch”选项，git会交互式地与你确认哪些修改需要进行stash，而哪些不需要。\n\n### git clean\n如果我们想直接删除工作目录中untrack的文件，而不是把它压栈，可以使用`git clean`命令，为了安全起见，最好加上“-i”选项进行交互式删除。加上\"-d\"选项会自动删除untrack的空文件夹。\n### git搜寻\n使用下面命令查看特定字符串的提交或修改记录，其中`ZLIB_BUF_MAX`为我们想搜寻的字符，`--oneline`是输出的选项，以简易形式输出。\n```shell\ngit log -S ZLIB_BUF_MAX --oneline\n```\n使用`git blame file`查看file中每一行的最近改动，可以查看是谁引入了相关问题(所以是blame选项，找背锅的，哈哈哈)。`git blame -L 11,22 file`仅限查看file中11到22行的最近改动。\n\n---\n查看特定文件中某一函数的改动情况，可以使用如下的命令：\n```shell\ngit log -L :git_deflate_bound:zlib.c\n```\n如果我们想查看 zlib.c 文件中函数 git_deflate_bound 的每一次修改，可以运行上述命令，这将尝试找出该函数的边界，然后查看历史记录，以一系列补丁的形式向我们展示函数的每一次修改，直至函数首次创建。或者就在-L后面给出行数范围也可以。可以使用`git log --help`查看-L的使用方法。\n## 合并冲突\n在我们合并分支或者`git stash pop`时，很有可能出现冲突的情况，下面主要给出merge失败的解决方案，即如何解冲突。\n首先，如果我们目前没有时间去清除conflict，我们可以先使用`git merge --abort`命令，这样会回退到`git merge`或者`git stash pop`的状态之前，也就相当于撤销一次merge的操作。(如果没敲合并的命令不就没有合并冲突了，hhhhh)\n如果我们确实想解冲突，但只是想拿本地分支或者待合入分支的文件版本，我们可以简单操作如下：`git checkout --ours file`，这是取我们当前分支的文件状态作为merge后的结果，`git checkout --theirs file`这是取待合入分支的文件作为merge的结果。\n最后是常用的情况，我们确实想看文件中共同的改动在何处，并想仔细解冲突，可以先使用`diff3`来查看版本修改情况，这里“3”的含义是我们在解冲突时所需要的三份文件版本：1. 该文件在两分支上的共同祖先版本(BASE)；2. 本地分支的版本(LOCAL)；3. 待合入分支的版本(REMOTE)；\n我们使用`git checkout --conflict=diff3 file`，此后打开file，会发现文件中的冲突之处有如下的特征：\n\n```shell\n<<<<<<< ours\n  puts 'hola world'\n||||||| base\n  puts 'hello world'\n=======\n  puts 'hello mundo'\n>>>>>>> theirs\n```\n其中三部分内容以不同的分隔符进行分隔，其中ours是本地文件版本，base是共同祖先版本，theirs是待合入分支的文件版本，我们对其进行选择，随后将该段提示删除保存，即可完成解冲突操作。(解完冲突后进行`git add`+`git commit`操作)；还可以使用`git diff`查看尚未解完的冲突，适用于冲突较多的情况。\n也许发生冲突的修改已经距离当前很远了，我们可以使用`git log --oneline --left-right --merge`来查看与冲突相关的提交，通过当时的commit message信息来决定如何解冲突。\n\n## 撤销commit\n如果我们错误提交了一次commit，心里一定非常慌张。别急，git给你准备了补救手段。如果该commit还没有push上库，那么比较简单，直接`git reset --hard HEAD^`即可，回退到commit之前的版本。但如果上库了就没那么简单了，因为可能有其他同事基于你错误的版本已经在向前移动HEAD指针了，如果你强行reset可能会造成更严重的错误。其实想一下，每次查看git commit的log时，都会说此次commit修改了哪些哪些文件，那如果有一个命令让你逆向还原这些文件，不就一样实现了撤销commit的操作吗？这就是`git revert`的功能。该命令用起来很简单，`git revert commit-id`即可完成撤销，我们再进行`git add`和`git commit`即可。\n需要注意的是，如果撤销的commit是merge分支的操作，那么后续如果再继续merge该分支时，需要一些额外操作，详细操作流程请查看Pro_Git的7.8节。\n如果要处理大量重复的冲突，可以查阅`git rerere`工具。\n\n## Debug何时引入错误\n`git bisect` 是 Git 提供的一个用于二分查找的工具，用于定位代码中引入 bug 的具体提交。它的主要作用是帮助开发者在一个较大的提交历史中快速定位引入 bug 的具体提交，从而更容易地进行问题追踪和修复。(bisect：binary search commit)\n\n使用场景及示例说明如下：\n\n**场景：** 假设你的项目中出现了一个 bug，而你无法确定 bug 是在哪个具体的提交引入的，但你知道在项目的某个历史版本中是没有这个 bug 的。\n\n**步骤：**\n\n1. **开始 bisect：** 首先，你需要告诉 Git bug 的状态，即哪个提交是有 bug 的，哪个是没有 bug 的。你可以使用 `git bisect start` 命令开始 bisect 过程。\n```bash\ngit bisect start\n```\n我们可以使用`git bisect start HEAD commit-id`，其中commit-id为已知的正确的版本，HEAD为已发生错误的版本，或者使用两个commit-id表明范围也行。\n2. **标记 bad 和 good：** 接着，你需要标记一个已知是有 bug 的提交为 \"bad\"，另一个已知是没有 bug 的提交为 \"good\"。这可以通过 `git bisect bad` 和 `git bisect good` 命令来完成。\n\n```bash\ngit bisect bad           # 当前版本有 bug\ngit bisect good          # 当前版本没有 bug\n```\n\n3. **开始二分查找：** Git 现在将使用二分查找算法在两个标记的提交之间进行搜索，每次检出一个中间的提交，然后你需要测试该版本是否有 bug。如果有 bug，使用 `git bisect bad` 命令标记为 bad，否则标记为 good。\n\n4. **重复步骤：** 重复步骤 3，直到 Git 找到第一个引入 bug 的提交。此时，Git 将输出这个提交的信息，你就可以定位到引入 bug 的具体提交。\n\n5. **结束 bisect：** 当找到引入 bug 的提交后，使用 `git bisect reset` 命令结束 bisect 过程。\n\n```bash\ngit bisect reset\n```\n\n通过以上步骤，你可以利用 `git bisect` 工具快速定位代码中引入 bug 的具体提交，从而帮助进行问题追踪和修复。这在大型项目中特别有用，因为通常情况下可能存在大量的提交历史。\n## submodules\n### 添加submodules\n在main project里添加submodule：`git submodule add https://xxx`；\n之后会在main project中发现.gitmodules文件，里面记录了submodule的url，在main project中的路径以及其关联的分支名；这也是其它成员能知道submodule来源的配置文件；\n\n### clone含submodules的project\n```shell\n1. 第一种方法\ngit clone https://xxxxx\ngit submodule init\ngit submodule update\n2. 第二种方法\ngit clone --recurse-submodules https://xxxxx\n如果已经clone下来，还有补救方式：\ngit clone https://xxxxx\ngit submodule update --init --recursive\n```\n### 更新含有submodules的project\n```shell\n法一：\ngit pull\ngit submodule update --init --recursive(此时会将挂载在main project的当前分支上的submodule的更新merge进来)\n法二：\ngit pull(或者git fetch)\ngit submodule update --remote(此时会将.gitmodules配置文件中所记录的submodule的分支拉到最新，可能与main project的分支情况不一致，不推荐)\n特殊情况，如果main project在某次提交时修改了submodule的url，此时我们git submodule update就有可能失败，为解决该问题，我们可以使用git子模块同步命令：\ngit submodule sync --recursive\n```\n### push submodule\n1. 在main project里`git add submodule`，此时会将当前的提交点挂载在main project上；\n2. git push\n### merge submodule\n如果submodule发生冲突，解决流程：\n1. `git pull`获取最新submodule状态，并发现发生冲突；\n2. `git diff`查看local与remote的commit id差异；\n3. 基于远端commit id新建分支，`git branch try_merge remote-commit-id`；\n4. `git merge try_merge`；\n5. 然后就是正常的解冲突；\n6. `git add, git commit, git push`；\n### submodule tips\n可以通过`foreach`的子模块命令对所有的子模块进行操作，这在项目中拥有较多submodules时比较有用。\n```shell\ngit submodule foreach 'git stash'\ngit submodule foreach 'git checkout -b featureA'\ngit diff; git submodule foreach 'git diff'\n```\n使用alias将长命令缩短\n```shell\ngit config alias.sdiff '!'\"git diff && git submodule foreach 'git diff'\"\ngit config alias.spush 'push --recurse-submodules=on-demand'\ngit config alias.supdate 'submodule update --remote --merge'\n使用：\ngit spush\ngit supdate\n```\n如果在main project中，有的分支上有submodule，而有的分支上没有submodule，那么在切换main project的分支时，最好使用如下方式：`git checkout --recursive-submodules branch_name`。\n## bundle\n`git bundle` 是 Git 提供的一个功能，它可以将 Git 仓库的部分或全部历史打包成一个单独的文件。这个文件可以在不连接到网络的情况下传递给其他人，他们可以通过将其导入到自己的本地仓库来恢复提交历史。`git bundle` 的主要作用是在没有网络连接或网络速度较慢的情况下，仍然能够方便地共享和传输 Git 仓库的历史记录。\n\n使用场景包括但不限于：\n\n1. **离线协作：** 当你需要与其他人协作，但又无法连接到网络时，可以使用 `git bundle` 将你的本地仓库的提交历史打包成一个文件，并通过其他方式传递给他们，如 USB 磁盘或其他传输媒介。\n\n2. **备份和归档：** 将 Git 仓库的历史记录打包成一个 bundle 文件可以作为备份和归档的方式。你可以将 bundle 文件存档到云存储或外部硬盘中，以防止数据丢失。\n\n3. **快速克隆：** 当你需要在其他计算机上快速克隆 Git 仓库时，可以使用 bundle 文件代替从远程仓库克隆，特别是在网络速度较慢的情况下。\n\n下面是一个示例，演示了如何使用 `git bundle` 创建和使用 bundle 文件：\n\n```bash\n# 创建 bundle 文件\ngit bundle create repo.bundle master\n\n# 将 bundle 文件传递给其他人，如通过 USB 磁盘或其他传输媒介\n\n# 恢复提交历史到本地仓库\ngit clone repo.bundle repo\n\n# 更新现有仓库的提交历史\ngit pull repo.bundle master\n```\n\n在上面的示例中，首先我们使用 `git bundle create` 命令创建了一个名为 `repo.bundle` 的 bundle 文件，其中包含了 `master` 分支的提交历史。然后，我们可以将这个 bundle 文件传递给其他人。其他人可以通过 git clone 命令从 bundle 文件中恢复提交历史到本地仓库，或者通过 git pull 命令更新现有仓库的提交历史。可以进行checkout到特定commit id的操作；\n[Git-Tools-Bundling](https://git-scm.com/book/en/v2/Git-Tools-Bundling)","tags":["Git"],"categories":["Git"]},{"title":"DC优化的常用方法","url":"/2023/10/30/IC/EDA/DC优化的常用方法/","content":"\n优化是Design Compiler综合中的一个步骤，该步骤根据设计的功能、速度和面积要求，寻找特定目标逻辑库单元的最佳组合。DC提供了一些设计者能够自定义和控制优化的选项，本文将讨论这些选项。\nDC的优化过程需要基于设计者对Design的约束，其中约束又分为两类，Design Rule Constraint（DRC）和Optimization Constraint，其中DRC的优先级较高（优先保证满足DRC）。\n\n - Design Rule Constraint：Transition，Fanout，Capacitance；\n - Optimization Constraint：Timing，Area；\n## Automatic Ungrouping\nDC工具中，使用`compile_ultra`命令对设计进行编译时，会自动将设计的层次结构打散。Ungrouping就是将小模块打散直接合并到大模块中，移除了层次结构的边界可以让DC工具“放开手脚”，可以通过减少逻辑级数来改善时序，并通过逻辑共享来降低面积。\n![image-20231030213123779](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213123779.png)\n在Ungrouping时，部分小模块会在接口上进行一些时序约束，如multicycle或false path等。在对模块进行Ungrouping时，DC会对这些约束进行保留，将其重新分配给相邻的仍存在的引脚。\n对于设计者不想进行Ungrouping的模块，可以对该模块进行属性约束：`dont_touch`，`size_only`，`set_ungroup`等。\n\n## High-Level Optimizations and Datapath Optimization\n在数据路径的优化阶段，DC会根据时序和面积的约束，对资源进行合理的分配与共享。资源共享是指对多个操作使用同一硬件组件，通常可以减少面积。其他的优化包括算子优化以及通用的运算符共享在此阶段也会进行。\nDC的算子优化其实就是使用DC自带的DesignWare库对算子进行高性能映射，可以选择Area优先或者Speed优先，需要额外的licence，这里不再详述。\n\n### High-Level Optimizations\nDC工具还提供**优化树延迟和算子化简**的优化手段。举例来说，表达式`a+b+c+d`描述的是一个3级级联加法器，DC可以对计算的顺序进行优化，变成`(a+b)+(c+d)`，这样可以提高电路速度（2级级联加法器）。算子化简由`compile_ultra`进行提供，有以下的化简案例：“(a+b-a) => a”，“(aX3X5) => (aX15)”；\n### Resource Sharing\n**资源共享**减少了HDL中实现加法(+)等操作符所需的硬件数量。如果每个+操作符都构造一个加法器，则会大大增加设计的面积。有两种类型的资源共享:公共子表达式消除和互斥操作的共享。\n为理解公共子表达式消除类型的资源共享，以下例进行说明：\n\n```verilog\n//  Original RTL\nX = A > B;\nY = A > B && C;\n// After Common Subexpression Elimination\nTemp = A > B;\nX = Temp;\nY = Temp & C;\n```\n上述优化方式将比较器由2个降低到1个，降低了面积。DC默认会将下列的操作符进行上述资源共享操作：比较符（=, <, >, <=, >=, !=），移位符（<<, >>, <<<, >>>），算术运算（+, -, x, /, **, %）。\n此外，使用`compile_ultra`进行编译时，工具会自动识别公共子表达式，无需以相同的顺序对表达式进行书写。比如在表达式“A+B+C”和“B+A+D”中，\"A+B\"和“B+A”被识别为公共子表达式。\n另外，DC工具既可以共享公共子表达式，也可以根据约束进行反向共享。以下面的表达式为例，`Z1<=A+B+C`，`Z2<=B+C+D`，各信号的arrive time为`A<B<D<C`。下图展示了DC会根据约束决定资源共享或是反向共享。\n![image-20231030213224106](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213224106.png)\n下面介绍共享互斥操作，互斥在这里的含义就是操作不会被同时执行。下面的例子可以更好地帮助理解：\n\n```verilog\nmodule resources(A,B,C,SEL);\n\tinput A,B,C;D\n \tinput SEL;\n \toutput [1:0] Z;\n \treg [1:0] Z;\n\talways @(A or B or C or D or SEL) begin\n\t\tif(SEL)\n\t\t\tZ = B + A;\n\t\telse\n\t\t\tZ = C + D;\n\tend\nendmodule\n```\n使用资源共享后的综合结果如下：\n![image-20231030213256777](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213256777.png)\n与公共子表达式共享类似，DC会根据时序约束确定是共享还是反向共享。例如，当SEL信号到达较晚且，共享加法器会使QoR（Quality of Results)变差时，DC就不会共享加法器。\n\n### Datapath Optimization\nDC对Datapath的优化主要通过以下手段：\n\n - 使用Design Ware库；\n - 数据路径提取：如果数据的计算路径上有多级加法，可以使用多个树形结构的CSA（carry-save adders）加法器来提高加法的计算速度。使用该方式时有如下前提：1.各运算单元之间没有其他非算术逻辑；2.无法提取被例化的Design Ware模块；\n - 合理使用乘法分配律，如：(a x c + b x c)被优化为(a + b) x  c；\n - 比较器共享，比如a > b，a < b，a ≤ b会调用同一个减法器；\n - 操作数重排序；\n## Path Group\n默认情况下，DC根据时钟对path group进行划分，随后DC根据path group对时序进行收敛，默认是对path group中最差的路径进行优化。因此如果设计存在复杂的时钟或时序要求，用户可以将几条关键路径划分为一个path group，指定DC专注于该组路径的优化。\n此外，设计者可以对时钟分组设置权重，权重的值范围为0.0-100.0。例如：\n\n```shell\ngroup_path -name group0 -from in1 -to FF1/D -weight 2.5\n```\n## Optimizing near-critical paths\n默认情况下，DC只优化同一path group内的关键路径，即slack最差的路径。如果在关键路径附近指定一个范围，那么DC就会优化指定范围之内的所有路径。若指定范围较大，会增大DC运行时间，因此一般情况该范围设定为时钟周期的10%。例如：\n\n```shell\nset_critical_range 3.0 $current_design\n```\n## Perform high-effort compile\nHigh-effort compile能够使DC更加努力地达到约束目标，该选项在关键路径上进行重新综合，同时对关键路径周围的逻辑进行了restructure和remap。\n\n> restructure主要目的是重新组织和优化设计的逻辑结构，以改进性能、功耗、面积或其他关键指标。以一个32bit的加法器为例说明restructure：在restructure优化前，电路采用传统的级联加法器结构，逻辑门按顺序连接，逻辑的排列和布局可能不是最优的，导致延迟较大，功耗较高；在restructure优化后，DC使用更高级的加法器结构，如Carry Look-Ahead Adder（CLA），代替传统结构，并重新组织逻辑，将关键路径上的逻辑门优化排列，以减小延迟。\n\nhigh-effort的指令有两种：\n\n - compile_ultra附带两个option，-area_high_effort_script是面积优化，-timing_high_effort_script是时序优化。\n - compile附带一个option，`map_effort -high`\n\n## Perform high-effort incremental compile\n通常使用增量编译可以提高电路优化的性能。如果电路在初次compile之后不满足约束，通过增量编译对不满足时序要求的电路进行门级优化。增量编译会增加编译时间，但是时序收敛的有效方法。为了减少DC运算时间，可将那些已经满足时序要求的模块设置为`dont_touch`属性：\n\n```shell\ndont_touch noncritical_blocks\n```\n对于那些有很多违例逻辑模块的设计，增量编译通常是最有效的：\n\n```shell\ncompile -map_effort high -incremental_mapping\n```\n## Gate-level optimization\nDC工具内的门级优化主要是通过选择工艺库中合适的标准单元来对电路进行优化，主要有3个阶段。\n### Delay optimization\n在该阶段，DC通过对关键路径进行遍历来修复Delay的违例。\n改善电路的delay主要有以下的思路：\n\n 1. 打散关键路径上的层次结构，并使能boundary optimization；\n 2. 使用Path Group对关键路径进行分组，并在关键路径附近指定一个范围，那么DC就会优化指定范围之内的所有路径；\n 3. 在探索设计空间阶段，可以给设计的delay更高的优先级，探索设计能达到的最快速度（不一定满足DRC）；\n 4. 对于扇出较大的net使用`balance_buffer`命令；\n\n在Delay optimization阶段，有下面几种改善电路delay的方式：upsizing, load isolation and splitting.\n\"upsize\" 是一种优化技术，旨在通过增大某些逻辑门的规模来提高电路性能。将电路中的某些标准逻辑门替换成面积更大的逻辑门可以增强逻辑门的驱动能力，从而获得更低的传输延迟，但它会导致面积和功耗的增加，因此使用时需要注意。\n![image-20231030213405578](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213405578.png)\nload isolation and splitting旨在减小逻辑门的输出负载，来改善电路的性能指标。主要思想是将逻辑门的输出与输入负载隔离开，以减小输出驱动电流。这可以通过以下方式实现：1. 在输出端插入缓冲器，以减小输出电路的负载电容。这可以降低输出延迟，提高电路的时序性能。同时，缓冲器还可以提供更高的输出驱动能力；2. 重新组织电路逻辑，将一些逻辑元素拆分为多个阶段，以减小每个阶段的输出负载，这通常需要在逻辑层面进行重新设计。\n![image-20231030213426207](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213426207.png)\n需要注意的是，DC在此阶段已经开始考虑DRC。同样条件下，会选择DRC代价最小的方案。\n\n### Design Rule Fixing\n\n - DC主要通过Resize或者插Buffer等方式来满足DRC约束；\n - 一般不会影响时序和面积结果，但必要时会导致optimization consrtaints违例；\n### Area Recovery\n - 不会引起DRC和Delay的违例，一般只是对非关键路径进行优化，优化方式包括`Cell DownSize`和`buffer and inverter cleanup`；\n - 如果没有设置面积约束，那么优化幅度会很小；\n\n![image-20231030213449018](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213449018.png)\n## Adaptive Retiming\nAdaptive Retiming（自适应时序调整）是DC工具中的一种优化技术，旨在调整电路中寄存器的位置以改善电路性能。它可以动态地适应电路中的性能需求，以达到设计目标。这对于高性能数字电路设计非常重要，尤其是在面临时序违规、时序紧迫性和电路性能优化的情况下。\n![image-20231030213604445](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213604445.png)\n由上图可知，发现设计的流水线划分不平衡时，就可以使用retiming策略。retiming策略有两种，分别是Backward Move和Forward Move，可在时序路径上前后移动寄存器，以提高电路的时序性能。如果没有违例的路径，则可用来减少寄存器的数量。\nDC在移动寄存器的优化中，只有对有相同时序约束的寄存器进行调整，如果两个寄存器约束不同，则不能一起移动。\n移动后的寄存器在网表中，名字通常带有一个R的前缀，和一个系列号，如`R_xxx`。\nretime策略不能和compile_ultra的以下option一起使用：\n\n - top\n - only_design_rule\n\n除此之外其他option都可以同时使用。\n\n>\"Uniquify\" 在数字电路设计工具中的作用是确保设计中的信号名字（如寄存器、信号线等）在整个设计中是唯一的。把例化的多个模块转化成唯一的模块名字，这样优化时可以针对每个模块做优化而不影响其它模块。\n## Pipelined-Logic Retiming\n当设计者在综合之前描述RTL级别的电路时，很难找到最佳的寄存器放置位置并将其编码到HDL中。通过寄存器Retiming，时序逻辑中触发器的位置可以自动调整，以尽可能地平衡各阶段的延迟。\n流水线Retiming在输入输出处的逻辑保持不变，因此不用改变TB相关的配置。但是，Retiming会改变设计中寄存器的位置、内容和名称。此时不能使用内部寄存器的输入和输出作为验证的参考点。\n举一个比较夸张的例子，比如我们需要设计一个简单的IP，仅关注输入输出逻辑，验证时也仅看接口信号逻辑。此时IP内部我们可以全部用组合逻辑进行描述，然后进行打拍输出。再启用Pipelined-Logic Retiming对寄存器位置进行重排，如果不满足时序要求则继续增加输出的打拍数目。\nPipelined-Logic Retiming的示意图如下：\n![image-20231030213643298](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213643298.png)\n\n![image-20231030213655682](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231030213655682.png)\n\n\n\n## Verifying function equivalence\nDC中部分优化手段会引起网表和HDL不一致，因此需要使用formality工具进行一致性检查，确认不一致的地方是否由DC优化造成。因此，DC在综合过程中必须生成formality的setup文件（默认为default.svf），给formality进行后续验证。其中可能会导致网表和HDL不一致的原因如下：\n\n - 由ungroup、group、uniquify、rename_design等约束造成部分寄存器、端口名字改变；\n - 状态机的优化；\n - Retiming策略导致寄存器排布方式与HDL不一致；\n - 等效和相反的寄存器被优化，常量寄存器被优化；\n - 数据通路优化；\n\n## Partitioning for synthesis\n把一个设计分割成几个相对简单的部分，称为设计划分（Design Partition）。一般在编写HDL代码之前都需要对所要描述的系统做划分，根据功能或代码量的考虑将一个系统层次化地分成若干个子模块，这些子模块下面再进一步细分，模块（module）就是一个划分的单位。\n在运用DC作逻辑综合的过程中，默认情况下各个模块的层次关系是保留着的，保留着的层次关系会对DC综合造成一定的影响。比如在优化的过程中，各个模块的管脚必须保留，这势必影响到模块边界的优化效果。\n在HDL编写过程中，一般遵循如下的设计划分原则：\n - 避免让一个组合逻辑穿越过多模块；\n - 将同步逻辑与异步逻辑剥离；\n - 进行寄存输出；","tags":["EDA"],"categories":["IC","EDA"]},{"title":"DC入门","url":"/2023/10/23/IC/EDA/DC入门/","content":"\n## 前言\n\nDesign Compile是所有IC工程师的必备工具，之前在校期间受限于平台只是使用FPGA的开发平台Vivado完成综合流程。进入公司后发现DC比较陌生，最近啃了一下Design Compile的User Guide，特用博客做记录用。开发环境为Design Compiler 2016。\n## 综合概述\n之前跟FPGA打过交道的同学应该对综合这个概念不陌生，FPGA里的综合是将HDL映射到FPGA的固有器件上，如LUT，BRAM，DSP等。而芯片中的综合也是类似，只不过底层被映射的器件变了。Design Compiler（以下简称DC）是Synopsys公司用于做电路综合的核心工具，可以将HDL转换为基于工艺库的门级网表。\nDC工具中的综合主要分为以下三个阶段：\n\n - Translation（转译）：把电路转换为EDA内部数据库GTECH（Generic Technology），这个数据库跟工艺库是独立无关的；\n\n \t- analyze（分析）：对HDL进行语法检查；\n \t- elaborate（细化）：将HDL转换为GTECH；\n - Optimozation（优化）：根据工作频率、面积、功耗来对电路优化，来推断出满足设计指标要求的门级网表；\n - Mapping（映射）：将门级网表映射到晶圆厂给定的工艺库上，最终形成该工艺库对应的门级网表。\n\nDC在综合过程中会将电路划分为下列的处理对象：\n\n - Design：待综合的对象；\n - Port：Design最外部的端口；\n - Clock：时钟；\n - Cell：被例化的模块名；\n - Reference：例化的原电路；\n\n 举例说明：\n![DC的处理对象](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/image-20231023205816424.png)\n使用DC综合的流程如下图所示：\n![DC综合流程](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/DC%E7%BB%BC%E5%90%88%E6%B5%81%E7%A8%8B.png)\n我们对着上图进行说明。HDL文件不用多说，硬件设计的主要文件；首先经过Design Compiler将HDL转换为GTECH，完成了Translation，然后进行后续优化与映射工作；\n图中左侧有5个输入的“参考”文件。Constraints为设计约束文件，为sdc（Synopsys Design Constraint）文件，对设计进行面积，时钟等方面的约束；IP Designware Library为Synopsys设计的高性能算子库，对“+ - × >= <”等基础算子或其他高级的算术运算进行深度优化，并可根据设计目标选择面积优先或者速度优先的实现方式，但需要购买额外的License才可以使用；Technology Library为工艺库，又称Target Library，由Vendor提供，内部包含一些基本的电路模块，如与或非门，FF，Latch等，供HDL进行映射；Symbol Library为符号库，它定义了在GUI界面中综合后的电路如何显示，在需要查看和分析电路图时需要指定，不指定时默认都按方框显示电路模块；DEF（Design Exchange Format）文件是一种标准的电子设计交换格式，主要用于表示物理设计和布局信息。在进行FloorPlan与Place&Route后，对布局布线，版图信息等进行反标，提供给DC，用以更准确地对Timing，Area等进行评估与优化。\n图的右侧是对Design进行时序和功耗的分析，中间则是优化的主要过程，如Timing, Datapath, Power, Area Optimization，进行时序收敛并对DFT（Design For Test）进行综合，最终得到优化后的netlist。\n由于优化过程中的一些优化手段会改变原先的电路结构，因此在综合后需要对netlist与HDL进行一致性验证，也就是最右侧的Formal Verification（使用Formality工具)。最后我们将优化后的netlist提供给IC Compiler，完成Floorplan以及P&R等工作。\n\n## Design Compile的使用\n### 启动Design Compile\n一般使用命令行的方式来启动DC，启动方式为`dc_shell -f script.tcl`。DC在启动时会自动在启动目录下创建“command.log”和“view_command.log”两个文件，用于记录用户在使用DC时所执行的命令及设置的参数。\n### Translation\n首先DC需要读取HDL文件，有如下两种读取方式：\n - 使用read_file命令来读取文件；\n - 同时使用analyze和elaborate指令；\n\nread_file命令可以同时完成两件事：1. analyze the design；2. translate the design into GTECH；\n那它与（analyze+elaborate）有什么不同呢？\n\n| 比较         | read_file                                      | analyze+elaborate                                         |\n| ------------ | ---------------------------------------------- | --------------------------------------------------------- |\n| 输入文件类型 | 所有文件类型都支持，包括Verilog,VHDL,db文件等  | 仅支持Verilog和VHDL                                       |\n| 使用时机     | 用来对综合的网表，预编译的结果及代码等进行综合 | 对VHDL和Verilog代码进行综合                               |\n| 参数         | 不允许在命令中对参数进行修改                   | 可以通过elaborate修改设计中的Parameter                    |\n| Link Design  | 必须使用link命令来解析模块引用                 | elaborate自动执行了link命令来解析模块引用，无需再执行link |\n\nlink中使用elaborate命令来重新对parameter进行赋值的示例：\n\n```shell\nelaborate chip_top -parameter \"DATA_WIDTH = 8,ADDR_WIDTH = 8\"\n```\n### Link\n读取完所要综合的模块之后，需要用link命令将读到DC暂存区中的模块或实体连接起来。在tcl文件中需要添加link_library，告诉DC到哪去找这些模块。同时还要注意search_path中的路径是否指向该模块或单元电路所在的目录。\n\n> Tips：设置search_path后，DC会在search_path目录中自动查找指定的设计和库文件，无需指定其绝对路径，仅需指定其名字即可。search_path的作用范围不仅限于库文件，我们还可以将sdc，db等文件的路径放在其中，简化tcl文件的规模。\n## 标准工艺单元库\nDC需要工艺库文件来执行综合过程。工艺库文件是针对特定制造工艺的库文件，其中包含了对工艺的物理特性和约束信息进行建模。这些工艺库文件在综合过程中发挥着重要作用：\n\n- 基本元件库： 工艺库文件包括了各种基本元件（如标准单元、存储器单元、I/O单元等）的信息。这些元件是IC设计中的基本构建块，它们的特性和电气特性必须准确建模以便综合工具能够正确地生成电路。\n\n- 时序和电气特性模型： 工艺库文件中包含了不同元件的时序特性和电气特性的模型，例如延迟、功耗、面积、电压等。这些模型允许综合工具在生成电路时考虑这些关键性能参数。\n\n- 约束信息： 工艺库文件包括与制造工艺相关的约束信息，如晶体管尺寸、金属层规则、布线资源、最小间距、最小尺寸等。这些约束信息确保生成的电路在特定工艺下能够正确制造。\n\n- 优化和分析： 工艺库文件中的信息用于进行优化和分析。综合工具使用工艺库中的特性来选择最佳电路结构，以满足性能、功耗和面积等要求。\n\n- 工艺相关的约束： 工艺库文件还包含了与工艺相关的约束，如抖动、噪声、温度等。这些约束信息在特殊情况下，如高性能或低功耗设计时，起到关键作用。\n\n- 制造可行性： 工艺库文件确保综合工具生成的电路在实际工艺下是可制造的。这包括考虑工艺的限制，以避免制造上的问题。\n\nDC使用工艺库文件来将逻辑网表转化为物理电路，确保生成的电路在特定工艺下满足性能、功耗和面积等方面的要求。因此，工艺库文件是IC设计工具中至关重要的一部分，它们在整个设计流程中起着关键的作用。\n### 常见库文件\n\n 1. 目标库（target_library）：主要包含电路的标准单元；\n 2. 链接库（link_library）：包含付费IP、存储器、IO、PAD；\n 3. 符号库（symbol_library）：定义了在GUI界面中综合后的电路如何显示；\n 4. 算术运算库（synthetic_library）：对基本的算子进行映射，即Design Ware library；\n### 目标库\n目标库是综合后电路网表要最终映射到的库。\n读入的HDL代码首先由Synopsys自带的GTECH库转成DC内部交换的格式，然后经过映射到目标库，最后生成优化的门级网表。\n目标库一般是db格式，由lib格式转化而来。\n目标库包含了各个门级单元的行为、引脚、面积、时序信息等，有的还包含了功耗方面的参数。\nDC在综合时就是根据目标库中给出的信息来计算路径的延时，并根据各个单元的延时、面积和驱动能力的不同选择合适的单元来优化电路。\n\n### 链接库\n链接库是设置模块或单元电路的引用。\n对于所有DC可能用到的库，我们都需要在link_library中指定，也包括要用到的IP。\n**在link_library的设置中必须包含“*”，表示DC在引用实例化模块或者单元电路时首先搜索已经调进DC的模块和单元电路。**\n\n### 符号库\n符号库是定义了单元电路显示的原理图库，查看分析电路图时，需要设置sdb格式的符号库。\n### 算术运算库\n在初始化DC时，不需要设置标准的DesignWare库standard.sldb用于实现verilog描述的运算符，DC会把加法、乘法等运算综合成性能较差的电路。\n如果需要扩展DesignWare，需要在synthetic_library中设置，同时需要在link_library中设置相应的库以使得在链接的时候DC可以搜索到相应运算符的实现。（注意：DesignWare需要更高级的licence）\n\n## DC约束\n### DRC约束\nDRC（Design Rule Check）用于确保生成的电路与制造工艺的物理规则和限制相符，在综合过程中的主要作用是确保所生成的电路在制造时不会违反工艺规则，从而提高设计的可制造性，减少错误，确保电路性能和功耗在预期范围内，并支持工艺迁移。这些约束对于确保IC设计的成功和高质量至关重要。\n常见的DRC约束有以下三种：\n 1. set_max_transition：约束design中的信号、端口、net最大transition不能超过这个值，值越小越苛刻；net的transition time取决于net的负载（fanout），负载越大，transition time越大；\n2. set_max_fanout：对design、net、output port进行操作，该约束用于限制一个逻辑门（或一个寄存器）的输出信号驱动的负载数量。它规定了一个逻辑门的输出可以连接到多少个输入；（Max fanout load of net is max number of loads the net can drive. ）\n3. set_max_capacitance：该约束用于限制一个逻辑门（或一个寄存器）的输出信号所能驱动的总负载电容。它规定了一个输出信号的负载电容的上限。（Sets a maximum capacitance for the nets attached to the specified ports or to all the nets\nin a design.）\n上述约束的具体数值由工艺厂商提供，但在电路设计中可以进行过约。\n\n> transition time is the time needed to transition from one logic state to the other.\n\n`set_max_fanout`和`set_max_capacitance`都是对负载进行约束，它们的主要区别在于这两种约束的优化目标。`set_max_fanout` 约束主要关注电路的时序和延迟，而 `set_max_capacitance` 约束关注电路的功耗（电路的功耗与负载电容成正比）。\n### 面积约束\nDC中的面积约束用于规定电路的逻辑元件在芯片上的最大布局面积，有助于控制设计的复杂性。约束面积的命令示例如下：\n\n```shell\nset_max_area 100\n```\n上述命令中100的单位由库单元的面积单位决定，有以下三种单位：两输入与非门个数，晶体管个数，平方微米。\n**一般会在面积约束时，将最大面积设置为0**。因为在DC工具中，默认设置是Timing Constraints比Area Constraints的优先级高，因此DC会在首先保证时序收敛的同时，探索面积最小的综合结果。\n\n### 时序约束\n有很多学习资料将时序约束分析的非常透彻了，这里就暂时跳过了。后面可能会出关于时序约束分析的专题博客，给大家提供一个不错的学习网站，里面的STA分析的较为透彻。[VLSI Tutorials](https://vlsitutorials.com/)\n### 环境约束\n在对设计进行优化之前，我们必须定义Design预期运行的环境。通过指定操作条件、系统接口特征和线路负载模型来进行环境约束。操作条件包括温度、电压和工艺变化。系统接口特性包括输入驱动、输入输出负载和扇出负载。环境约束直接影响设计综合效果。\n#### 设置操作条件\n工艺库中一般提供了几种工作条件的模型以供选择：\n\n - 最好情况（best case）：用于对保持时间的时序分析；\n - 典型情况（typical case）：一般不考虑；\n - 最坏情况（worst case）：用于对建立时间的时序分析；\n#### 驱动强度\n为了准确评估输入接口的时序结果，DC工具需要知道输入接口的驱动强度。驱动强度为Driver阻抗的倒数，输入接口的transition delay为Driver阻抗×输入端口的电容负载。DC默认Driver阻抗为0，即驱动强度为无穷。可以通过`set_driving_cell`，`set_drive`，`set_input_transition`来对驱动强度进行设置。\n#### 线负载模型\n在DC综合的过程中，net延时是通过设置线负载模型（wire load model）确定的。线负载模型基于net的扇出，对net的电阻电容等寄生参数进行计算。线负载模型的计算函数也是由晶圆厂提供的，晶圆厂则是对使用该工艺流片的芯片的net延时进行统计，从而得到该经验值。\n设置线负载模型可以通过“set_wire_load_model”命令完成，也可以让DC自动根据综合出来的模块面积大小选择负载模型。默认情况下是DC自动选择。\n上面说的是模块内的线负载模型，对于模块间的线负载模型，存在一些跨模块的net，它们的wire_load_mode有以下三种决定方式：\n![线负载模型](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/%E7%BA%BF%E8%B4%9F%E8%BD%BD%E6%A8%A1%E5%9E%8B.png)\n\n - 顶层（top）：所有submodule的线负载模型都用顶层模块的线负载模型代替；\n - 围绕（enclosed）：net的负载模型用**完全包含该net的模块**的线负载模型代替；\n - 分段（segment）：根据net所在的模块，分段对其使用线负载模型进行估计；\n\n#### 输出负载\n为了更准确的估计模块输出的时序，除了要知道输出延时之外，还需要知道输出的负载大小。如果输出负载会影响电路的transition time，进而影响时序特性。如果DC默认输出负载为0，即相当于不接负载的情况，这样综合出来的电路时序显然过于乐观，不能反映实际工作情况。 \n我们可以使用set_load设定load值，例如：\n\n```shell\nset_load 30 [get_ports OUT1]\n```\n其中“30”的单位可以用`report_lib`命令进行查看，即Capacitive Load Unit对应的单位。\n### DC输出结果\n\n - 整个工程以ddc格式保存下来以供后续查看和修改；\n - 网表netlist，用于布局布线和仿真；\n - sdf文件，标注了用到的标准单元的延迟值，后仿真也需要用到；\n - 面积报告，包含时序电路、组合电路和总电路面积；\n - 约束报告，给出了综合过程中没有满足要求的约束；\n - 时序报告，包含建立时间和保持时间；\n - svf文件，包含了DFT和Formality所需的信息，供后续使用；","tags":["EDA"],"categories":["IC","EDA"]},{"title":"HLS入门简述","url":"/2023/03/29/FPGA/HLS入门简述/","content":"\n## What‘s HLS？\n\nHLS（High-Level Synthesis）高层次综合。何谓高层次？意味着我们可以使用高层次的语言来对设计进行描述，如C，C++，System C等；那何谓综合呢？HLS在其中起了重要的**转换**作用，将高层次的抽象语言转换为寄存器传输级语言（register transfer level，RTL），这样我们可以将其映射到FPGA的器件中，进行硬件实现，此谓综合。\n\n简单来说，我们通过HLS工具，可以将C，C++等高级语言描述的算法转换为可以进行硬件部署的代码，缩短我们的开发时间。那有同学就兴奋了：“硬件开发真简单，把算法思路拿C语言验证一下，再用HLS工具转换一下代码就ok了，我上我也行。”这种说法对，也不对。开发的流程是对的，先用高级语言对算法进行验证，再进行硬件实现，不对的地方在于没那么简单（手动狗头），或者说想要高效的硬件实现没那么简单。\n\n## Why HLS？\n\n讲完What就该讲Why了，说到Why其实就是说说HLS有哪些优势值得我们选择呢？在这里我搬运一下Xilinx官方文档里面“自夸”的部分：\n\n> High-level synthesis bridges hardware and software domains, providing the following primary benefits:\n>\n> Improved productivity for hardware designers：Hardware designers can work at a higher level of abstraction while creating high-performance hardware.\n> \n>Improved system performance for software designers：Software developers can accelerate the computationally intensive parts of their algorithms on a new compilation target, the FPGA.\n> \n>Using a high-level synthesis design methodology allows you to:\n> \n>Develop algorithms at the C-level：Work at a level that is abstract from the implementation details, which consume development time.\n> \n>Verify at the C-level：Validate the functional correctness of the design more quickly than with traditional hardware description languages.\n> \n>Control the C synthesis process through optimization directives：Create specific high-performance hardware  implementations.\n> \n>Create multiple implementations from the C source code using optimization directives：Explore the design space, which increases the likelihood of finding an optimal implementation.\n> \n>Create readable and portable C source code：Retarget the C source into different devices as well as incorporate the C source into new projects.\n\n我来给大家省流一下，HLS工具对硬件开发者的抽象程度更高，对于软件开发者而言，更方便把算法放FPGA上进行加速了。也就是硬件开发软件化，降低了软件工作者使用FPGA平台进行算法加速的门槛。\n\n那HLS的设计方法有哪些过人之处呢？1、设计的层次更高，不用过多关注设计细节；2、在C-Level就可以进行设计的验证工作；3、使用一些HLS的优化约束语句就可以控制综合结果的性能；4、基于同一套C Code，使用不同组合的优化约束可以生成性能不同的综合结果，来探索设计空间；5、同一套C Code可以映射到不同的硬件平台中，重塑性强。\n\n说了那么多，那HLS用起来方便不，又是C代码，又是约束的。我们看一下官方文档里对HLS输入输出的说明：\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303250915611.png)\n\n输入主要包括：用C、C++、SystemC编写的函数；设计约束，包括时钟频率、时钟不确定度、目标平台等信息；优化指示，来引导HLS工具做综合方面的优化，如面积优先or速度优先；C语言的testbench以及相关的测试文件；\n\n输出主要包括：使用HDL描述的设计；报告文件；\n\n其实各方向的知识基本都符合二八定律，即掌握20%的知识就可以解决80%的问题，其余80%的知识主要用来fix各种corner的情况，本文希望能把20%最重要的东西讲明白，让大家能对HLS有个初步印象，那我们开始吧。\n\n## Optimizing the Design\n\n本章主要介绍一些优化技巧，来指导HLS进行综合。通过了解如何对设计进行优化，来提升大家对HLS工具的兴趣。\n\n> NOTE：后续所述知识需要同学具有如下基础：了解FPGA基本组成结构，了解 BRAM 资源特性，了解 真双口/伪双口 RAM 的区别，有一定的 C 语言基础，了解指针等基础概念。\n\n### 时钟、复位和RTL输出\n\n#### 指定时钟频率\n\n<u>对于 C 和 C++ 设计，仅支持单一时钟。</u>对设计中的所有函数将应用同一个时钟。\n\n对于 SystemC 语言设计，每个 SC_MODULE 都必须使用不同时钟来指定。要在 SystemC 语言设计中指定多个时钟，需要使用 create_clock 命令的 -name 选项来创建多个指定时钟，并使用 CLOCK 指令或编译指示来指定哪个函数包含将以指定时钟进行综合的 SC_MODULE。\n\n时钟周期（以 ns 为单位）在“Solutions” → “Solutions Setting”中设置。Vivado HLS 使用时钟不确定性概念来提供用户定义的时序裕度。通过使用时钟频率和器件目标信息，Vivado HLS 可估算设计中的操作时序，但无法确定最终组件布局和信号线布线：这些操作由输出 RTL 的逻辑综合来执行。\n\n为计算用于综合的时钟周期，Vivado HLS 会从时钟周期减去时钟不确定性，如下图所示。\n\n![image-20230325111459414](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251114447.png)\n\n这样可为用户提供指定裕度以确保下游进程（例如，逻辑综合与布局布线）具有足够的时序裕度来完成其操作。如果FPGA 器件利用率过高，那么单元的布局以及用于连接单元的信号线的布线可能无法达成理想状态，并且可能导致设计的时序延迟大于期望值。对于此类情况，增加时序裕度可避免 Vivado HLS 所创建的设计在每个时钟周期内综合过多的逻辑运算，并在布局布线选项不太理想的情况下使 RTL 综合仍能满足时序。默认时钟不确定性为周期时间的 12.5%，设计者可以在时钟周期设置的旁边显式指定该值。\n\n> NOTE：综合后复查约束的报告至关重要：实际上虽然 Vivado HLS 可生成输出设计，但并不能保证设计满足所有性能约束。请复查设计报告的“性能估算 (Performance Estimates)”部分。\n\n#### 指定复位\n\n通常 RTL 配置中最重要的操作即选择复位行为。对于复位行为，重要的是理解初始化与复位之间的差异。\n\n初始化行为，指在 C 中，以静态限定符定义的变量，以及全局作用域中定义的变量默认都初始化为 0。对于这些变量，可赋予特定初始值。对于这两种类型的变量，C 语言代码中的初始值在编译时（时序为 0 时）进行赋值，并且不再进行赋值。上述两种情况下，在 RTL 中实现的初始值相同。\n\n- 在 RTL 仿真期间，为这些变量设置的初始值与 C 语言代码中相同。\n- 在用于对 FPGA 进行编程的比特流中同样会对这些变量进行初始化。当器件上电时，变量将以其初始状态启动。\n\n变量启动时的初始状态与 C 语言代码中相同，<u>但无法强制返回此初始状态</u>。要返回初始状态，必须通过复位来实现。\n\n那么我们如何控制复位行为呢？复位端口在 FPGA 中用于在应用复位信号时，立即将连接到复位端口的寄存器和 BRAM 还原为初始值。config_rtl 配置可用于控制 RTL 复位端口是否存在及其行为，如下图所示。要访问此配置，请选择“Solution” → “Solution Settings” → “General” → “Add” → “config_rtl”。\n\n![image-20230325112128090](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251121143.png)\n\n复位设置包含设置复位极性以及使用同步复位还是异步复位的功能，但更重要的是，它可通过“reset”选项来控制应用复位信号时要复位的寄存器。“reset”选项包含 4 项设置：\n\n- “none”：不向设计添加任何复位。\n- “control”：这是默认设置，用于确保将所有控制寄存器复位。控制寄存器即状态机中使用的寄存器，用于生成 I/O 协议信号。此设置可确保设计可立即启动其操作状态。\n- “state”：该选项可为控制寄存器添加复位（与“control”设置相同），并且还可为衍生自 C 语言代码中的静态变量和全局变量的任意寄存器或memory添加复位。此设置可确保应用复位后，C 语言代码中初始化的**静态变量和全局变量**均复位为其初始值。\n- “all”：为设计中的所有寄存器和memory添加复位。\n\n通过 RESET 指令可提供更精细的复位控制。对于静态变量或全局变量，RESET 指令可用于为其显式添加复位，或者可将该变量从使用 RESET 指令的 off 选项复位的变量中移除。当设计中存在静态数组或全局数组时，该选项非常实用。\n\n> NOTE：当在设计上使用 AXI4 接口时，复位极性会自动更改为低电平有效，而与 config_rtl 配置中的设置无关。这与 AXI4 标准的要求有关。\n\n对数组而言，其通常定义为静态变量，这表明所有元素都将初始化为 0，且数组通常使用 BRAM 来实现。使用复位选项 state 或 all 时，会强制将用 BRAM 实现的所有数组在复位后都返回初始化状态。这可能导致 RTL 设计中出现不好的现象：\n\n- 不同于上电初始化，显式复位要求 RTL 设计对 BRAM 中的每个地址进行迭代以设置值：如果 N 较大，这可能导致复位所需的时钟周期数量显著增加，并增加资源占用。\n- 设计中的每个数组中都有复位信号。\n\n为防止在此类 BRAM 上都放置复位逻辑，并避免因复位 BRAM 中的所有元素而产生的周期开销，建议执行以下操作：\n\n- 使用默认 control 复位模式，并使用 RESET 指令来指定要复位的每个静态变量或全局变量。\n- 或者，使用 state 复位模式，并使用 RESET 指令的 off 选项从特定静态变量或全局变量中移除复位。\n\n#### RTL输出\n\n可使用 config_rtl 配置来控制 Vivado HLS 的各种 RTL 输出特性：\n\n- 指定 RTL 状态机中使用的 FSM 编码类型。\n- 使用 -header 选项可向所有 RTL 文件添加任意注释字符串（例如，版权声明）。\n- 使用 prefix 选项可指定要添加到所有 RTL 输出文件名的唯一名称。\n- 强制 RTL 端口使用小写名称。\n\n默认 FSM 编码样式为 onehot。其它可用选项包括 auto、binary 和 gray。如果选择 auto，Vivado HLS 可使用onehot 默认设置来实现编码样式，但 Vivado Design Suite 可在逻辑综合期间提取并重新实现 FSM 样式。\n\n### 最优化设计的吞吐量\n\n使用以下约束来提高吞吐量，或降低函数的启动时间间隔。首先对于函数和循环，可以进行流水线设计，提高数据的吞吐率；其次对于内存读写端口受限的场景，设计者通过对数组进行合适的分区，来将其分布到不同的 BRAM 中，解决读写端口受限的问题；然后对于数据依赖的问题，要仔细分析是否为假性的数据依赖；最后对循环进行适当的展开以改善流水线性能，并在任务级别进行并行化处理。\n\n#### 函数与循环流水线化\n\n流水线化允许并行执行操作：每个执行步骤无需等待完成所有操作后再开始下一项操作。流水线化适用于函数和循环。下图显示了通过函数流水线化实现的吞吐量提升。\n\n![image-20230325113130389](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251131428.png)\n\n如果不使用流水线化，上述示例中的函数将每隔 3 个时钟周期读取一次输入，并在 2 个时钟周期后输出值。该函数启动时间间隔 (Initiation Interval，II) 为 3，时延为 3。使用流水线化后，对于此示例，每个周期都会读取 1 次新输入 (II=1)，且不更改输出时延。\n\n循环流水线化支持以重叠方式来实现循环中的操作。在下图中，(A) 显示了默认顺序操作，每次输入读操作间存在 3 个时钟周期 (II=3)，需要经过 8 个时钟周期才会执行最后一次输出写操作。\n\n在 (B) 所示的循环的流水线版本中，每个周期都会读取一次新输入样本 (II=1)，仅需 4 个时钟周期后即可写入最终输出，在使用相同硬件资源的前提下显著改善 II 和时延。\n\n![image-20230325113338843](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251133878.png)\n\n函数或循环使用 PIPELINE 指令来实现流水线化。该指令需要在函数或循环主体区域中进行指定。启动时间间隔如果不指定，则默认为 1，但也可设置为其它值。\n\n流水线化仅应用于指定区域，而不应用于下层层级。但**下层层级内所有循环都会自动展开**。指定函数的下层层级内的所有子函数都必须单独流水线化。如果将子函数流水线化，其上层的已流水线化的函数即可充分发挥流水线性能。反之，<u>已流水线化的顶层函数下层的任意子函数如果不采用流水线化，则可能限制流水线性能。</u>\n\n已流水线化的函数与已流水线化的循环之间行为存在差异。对于函数，流水线将永久运行，永不终止。对于循环，流水线将持续执行直至循环的所有迭代完成为止。在下图中总结了行为差异。\n\n![image-20230325113606339](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251136380.png)\n\n行为差异会影响流水线输入和输出的处理方式。如上图所示，已流水线化的函数将持续读取新输入和写入新输出。相比之下，由于循环必须首先完成循环中的所有操作，然后才能启动下一次循环，已流水线化的循环会导致数据流传输中出现“气泡”；即，当循环完成最终迭代后不读取任何输入数据的时间点，以及当开始新循环迭代时没有输出数据的时间点。\n\n##### Rewind已流水线化的循环以保障性能\n\n为避免前图中所示的问题，PIPELINE 编译指示具有可选 rewind 命令。此命令支持将后续调用的迭代进行重叠执行，前提是此循环为数据流进程顶层函数的最外层的构造（并且多次调用数据流区域）。\n\n下图显示了对循环进行流水线化时使用 rewind 选项的操作。循环迭代计数结束时，循环将开始重新执行。虽然一般情况下它立即重新执行，但也可能出现延迟。\n\n![image-20230325113921563](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303251139601.png)\n\n> NOTE：如果在 DATAFLOW 区域周围使用循环，Vivado HLS 会自动将其实现以允许后续迭代进行重叠。\n\n##### 自动循环流水线化\n\nconfig_compile 配置支持根据迭代计数对循环进行自动流水线化。此配置可通过菜单“Solution” → “Solution Setting” → “General” → “Add” → “config_compile”访问。\n\npipeline_loops 选项可用于设置循环边界的限制。低于此限制的单一迭代计数内的所有循环都将自动流水线化。默认值为0：不执行自动循环流水线化。\n\n给定以下示例代码：\n\n```c\nfor (y = 0; y < 480; y++) {\n\tfor (x = 0; x < 640; x++) {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\t// do something 5 times\n\t\t\t...\n\t\t}\n\t}\n}\n```\n\n如果 pipeline_loops 选项设置为 6，那么以上代码片段中最内层的 for 循环将自动流水线化。这等同于以下代码片段：\n\n```c\nfor (y = 0; y < 480; y++) {\n\tfor (x = 0; x < 640; x++) {\n\t\tfor (i = 0; i < 5; i++) {\n#pragma HLS PIPELINE II=1\n\t\t\t// do something 5 times\n\t\t\t...\n\t\t}\n\t}\n}\n```\n\n如果设计中有部分无需使用自动流水线化的循环，请对此类循环应用含 off 选项的 PIPELINE 指令。off 选项可阻止自动循环流水线化。\n\n> NOTE：Vivado HLS 会在执行所有用户指定的指令后应用 config_compile pipeline_loops 选项。例如，如果 Vivado HLS 向循环应用用户指定的 UNROLL 指令，那么将首先展开该循环，但无法应用自动循环流水线化。\n\n##### 流水线化失败的问题\n\n将函数流水线化时，下层层级内所有循环都会自动展开。这是继续执行流水线化的前提。如果循环的边界是一个变量，则无法展开。这将导致无法对函数进行流水线化。\n\n其次是数据依赖的问题，静态变量用于在循环迭代间保留数据，这通常在导致最终实现时生成寄存器。如果在用流水线实现的函数中遇到此变量，vivado_hls 可能无法对设计进行充分最优化，这可能导致启动时间间隔超过所需的时间。下面给出代码示例：\n\n```c\nfunction_foo()\n{\n\tstatic bool change = 0\n\tif (condition_xyz){\n\t\tchange = x; // store\n\t}\n\ty = change; // load\n}\n```\n\n如果 vivado_hls 无法最优化此代码，则存储操作需要 1 个周期，加载操作也需要 1 个周期。如果此函数包含在流水线中，那么流水线必须以最小启动时间间隔 2 来实现，因为数据间存在依赖关系。\n\n用户可通过重写代码来避免此问题，如下例所示。它可确保在循环的每次迭代中仅存在读操作或写操作，这样即可以II=1 来调度设计。\n\n```c\nfunction_readstream()\n{\n    static bool change = 0\n    bool change_temp = 0;\n    if (condition_xyz)\n    {\n        change = x; // store\n        change_temp = x;\n    }\n    else\n    {\n    \tchange_temp = change; // load\n    }\n    y = change_temp;\n}\n```\n\n#### 通过数组分区来改善流水线化\n\n以下消息显示了对函数进行流水线化时常见的问题：\n\n```c\nINFO: [SCHED 204-61] Pipelining loop 'SUM_LOOP'.\nWARNING: [SCHED 204-69] Unable to schedule 'load' operation ('mem_load_2',bottleneck.c:62) on array 'mem' due to limited memory ports.\nWARNING: [SCHED 204-69] The resource limit of core:RAM:mem:p0 is 1, current assignments:\nWARNING: [SCHED 204-69] 'load' operation ('mem_load', bottleneck.c:62) on array 'mem',\nWARNING: [SCHED 204-69] The resource limit of core:RAM:mem:p1 is 1, current assignments:\nWARNING: [SCHED 204-69] 'load' operation ('mem_load_1', bottleneck.c:62) on array 'mem',\nINFO: [SCHED 204-61] Pipelining result: Target II: 1, Final II: 2, Depth: 3.\n```\n\n在此示例中，Vivado HLS 声明它无法达成指定的初始时间间隔 (II) 值 1，因为<u>它受内存端口所限</u>，无法在内存上调度 load（读取）操作 (mem_load_2)。以上消息指出了第 62 行上的 mem_load 操作所使用的“core:RAM:mem:p0 is 1”的资源限制。BRAM 的第 2 个端口同样仅含 1 项资源，该资源同样供 mem_load_1 操作使用。由于存在此内存端口争用，Vivado HLS 报告的最终 II 为 2，而不是所期望的值 1。\n\n此问题通常是由数组所导致的。数组作为最多只含有 2 个数据端口的 BRAM 来实现。这可能限制读写（或加载/存储）密集型算法的吞吐量。通过将该数组（单一 BRAM 资源）拆分为多个更小的数组（多个 BRAM）从而有效增加端口数量，即可改善带宽。\n\n数组可使用 ARRAY_PARTITION 指令来进行分区。Vivado HLS 可提供 3 种类型的数组分区，如下图所示。这 3 种分区样式分别是：\n\n- block：原始数组分割为原始数组的连续元素块（大小相同）。\n- cyclic：原始数组分割多个大小相同的块，这些块交织成原始数组的元素。\n- complete：默认操作是将数组按其独立元素进行拆分。这对应于将内存解析为寄存器。\n\n![image-20230328143809185](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281438234.png)\n\n对于 block 和 cyclic 分区，factor 选项可指定要创建的数组数量。在前图中，使用因子 2，即将数组分割为 2 个更小的数字。如果数组的元素数量并非该因子的整数倍，那么最后一个数组所含元素数量较少。\n\n对多维数组进行分区时，dimension 选项可用于指定对哪个维度进行分区。下图显示了使用 dimension 选项对以下代码示例进行分区的方式：\n\n```c\nvoid foo (...) {\n    int my_array[10][6][4];\n    ...\n}\n```\n\n此图中的示例演示了如何通过对 dimension 3 进行分区来生成 4 个独立数组，以及如何对 dimension 1 进行分组以生成 10 个独立分区。如果针对 dimension 指定 0，则将对所有维度进行分区。\n\n![image-20230328144017300](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281440335.png)\n\n##### 自动数组分区\n\nconfig_array_partition 配置可根据元素数量判定数组的自动分区方式。此配置可通过菜单“Solution” →“Solution Settings” → “General” → “Add” → “config_array_partition”访问。\n\n通过 throughput_driven 选项可对分区阈值进行调整，并且可完全实现自动分区。选中 throughput_driven 选项时，<u>Vivado HLS 会自动对数组进行分区以实现指定的吞吐量。</u>\n\n#### 与Vivado HLS之间的依赖关系\n\nVivado HLS 会构造对应于 C 语言源代码的硬件数据路径。\n\n如果没有流水线指令，将按顺序执行，并且不考虑任何依赖关系。但对设计进行流水线时，该工具仍需对 Vivado HLS生成的硬件的处理器架构中发现的依赖关系进行处理。\n\n数据依赖关系或内存依赖关系的典型用例是在完成上一次读操作或写操作后再次发生读操作或写操作。\n\n- 先写后读 (RAW) 操作也称为真性依赖关系，它表示指令（及其读取/使用的数据）从属于前一次操作的结果。\n\n  - I1: t = a * b;\n  - I2: c = t + 1;\n\n  语句 I2 中的读操作取决于语句 I1 中的 t 的写操作。如果对指令进行重新排序，它会使用 t 的前一个值，导致结果错误。\n\n- 先读后写 (WAR) 操作也称为反依赖关系，它表示当前一条指令完成数据读取后，下一条指令才能更新寄存器或内存（通过写操作）。\n\n  - I1: b = t + a;\n  - I2: t = 3;\n\n  语句 I2 中的写操作无法在语句 I1 之前执行，否则 b 的结果无效。\n\n- 先写后写 (WAW) 依赖关系表示必须按特定顺序写入寄存器或内存，否则可能破坏其它指令。\n\n  - I1: t = a * b;\n  - I2: c = t + 1;\n  - I3: t = 1;\n\n  语句 I3 中的写操作必须晚于语句 I1 中的写操作。否则，语句 I2 结果将出错。\n\n- 先读后读不含任何依赖关系，因为只要变量未声明为volatile，即可随意对指令进行重新排序。如果变量声明为volatile，则必须保留指令顺序不变。\n\n例如，生成流水线时，工具需确保后续阶段读取的寄存器或内存位置没有被之前的写操作修改。这属于真性依赖关系或先写后读 (RAW) 依赖关系。具体示例如下：\n\n```c\nint top(int a, int b) {\n    int t,c;\n    I1: t = a * b;\n    I2: c = t + 1;\n    return c;\n}\n```\n\n在语句 I1 完成前，无法对语句 I2 求值，因为与 t 变量之间存在依赖关系。在硬件中，如果乘法需耗时 3 个时钟周期，那么 I2 将发生等同于此时间量的延迟。如果对以上函数进行流水线化，那么 HLS 会将其检测为真性依赖关系，并对操作进行相应调度，因此函数可按 II =1 来运行，但Latency无法进行优化。\n\n当此示例应用于数组而不仅是变量时，就会出现内存依赖关系。\n\n```c\nint top(int a) {\n    int r=1,rnext,m,i,out;\n    static int mem[256];\n    L1: for(i=0;i<=254;i++) {\n#pragma HLS PIPELINE II=1\n        I1: m = r * a; mem[i+1] = m; // line 7\n        I2: rnext = mem[i]; r = rnext; // line 8\n    }\n    return r;\n}\n```\n\n在以上示例中，L1 循环的调度导致出现调度警告消息：\n\n```\nWARNING: [SCHED 204-68] Unable to enforce a carried dependency constraint (II = 1, distance = 1) between 'store' operation (top.cpp:7) of variable 'm', top.cpp:7 on array 'mem' and 'load' operation ('rnext', top.cpp:8) on array 'mem'.\nINFO: [SCHED 204-61] Pipelining result: Target II: 1, Final II: 2, Depth: 3.\n```\n\n只要写入的索引不同于读取的索引，那么循环的同一次迭代内就不会发生任何问题。而 2 条指令可同时并行执行。但请观测多次迭代中的读写操作：\n\n```c\n// Iteration for i=0\nI1: m = r * a; mem[1] = m; // line 7\nI2: rnext = mem[0]; r = rnext; // line 8\n// Iteration for i=1\nI1: m = r * a; mem[2] = m; // line 7\nI2: rnext = mem[1]; r = rnext; // line 8\n// Iteration for i=2\nI1: m = r * a; mem[3] = m; // line 7\nI2: rnext = mem[2]; r = rnext; // line 8\n```\n\n当考虑到 2 次连续迭代时，来自 I1 语句的乘法结果 m（时延 = 2）将写入某一位置，而循环的下一次迭代的 I2 语句将把位于该位置的结果读取到 rnext 中。在此情况下，存在 RAW 依赖关系，因为上一次计算的写操作完成后，下一次循环迭代才能开始读取 mem[i]。\n\n![image-20230328145952611](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281459662.png)\n\n请注意，如果增大时钟频率，那么乘法器将需要更多流水线阶段，从而导致时延增加。这也将迫使 II 增大。\n\n请注意以下代码，其中操作已发生交换，导致功能发生更改。\n\n```c\nint top(int a) {\n    int r,m,i;\n    static int mem[256];\n    L1: for(i=0;i<=254;i++) {\n#pragma HLS PIPELINE II=1\n        I1: r = mem[i]; // line 7\n        I2: m = r * a , mem[i+1]=m; // line 8\n    }\n    return r;\n}\n```\n\n调度警告为：\n\n```c\nINFO: [SCHED 204-61] Pipelining loop 'L1'.\nWARNING: [SCHED 204-68] Unable to enforce a carried dependency constraint (II = 1, distance = 1) between 'store' operation (top.cpp:8) of variable 'm', top.cpp:8 on array 'mem' and 'load' operation ('r', top.cpp:7) on array 'mem'.\nWARNING: [SCHED 204-68] Unable to enforce a carried dependency constraint (II = 2, distance = 1) between 'store' operation (top.cpp:8) of variable 'm', top.cpp:8 on array 'mem' and 'load' operation ('r', top.cpp:7) on array 'mem'.\nWARNING: [SCHED 204-68] Unable to enforce a carried dependency constraint (II = 3, distance = 1) between 'store' operation (top.cpp:8) of variable 'm', top.cpp:8 on array 'mem' and 'load' operation ('r', top.cpp:7) on array 'mem'.\nINFO: [SCHED 204-61] Pipelining result: Target II: 1, Final II: 4, Depth: 4.\n```\n\n请观测多次迭代中的连续读写操作：\n\n```c\nIteration with i=0\nI1: r = mem[0]; // line 7\nI2: m = r * a , mem[1]=m; // line 8\nIteration with i=1\nI1: r = mem[1]; // line 7\nI2: m = r * a , mem[2]=m; // line 8\nIteration with i=2\nI1: r = mem[2]; // line 7\nI2: m = r * a , mem[3]=m; // line 8\n```\n\n所需 II 延长，因为存在如下 RAW 依赖关系，从 mem[i] 读取 r、执行乘法并写入 mem[i+1]。\n\n#### 移除假性依赖关系以改善循环流水线化\n\n假性依赖关系，即编译器过于保守时出现的依赖关系。这些依赖关系在真实代码中并不存在，但无法由编译器来判定。这些依赖关系可能阻碍循环流水线化。\n\n假性依赖关系如下示例所示。在此示例中，针对相同循环迭代内的 2 个不同地址执行读写访问。这 2 个地址均依赖于输入数据，可指向 hist 数组中的任一元素。有鉴于此，Vivado HLS 假定这 2 个地址可访问同一个位置。因此，它安排按交替周期对数组执行读写操作，导致循环 II 为 2。<u>但代码显示 hist[old] 和 hist[val] 永远无法访问相同地址，因为这两者包含在 if(old == val) 条件的 else 分支中。</u>\n\n```c\nvoid histogram(int in[INPUT SIZE], int hist[VALUE SIZE]) f\n    int acc = 0;\n    int i, val;\n    int old = in[0];\n    for(i = 0; i < INPUT SIZE; i++)\n    {\n        #pragma HLS PIPELINE II=1\n        val = in[i];\n        if(old == val)\n        {\n        \tacc = acc + 1;\n        }\n        else\n        {\n            hist[old] = acc;\n            acc = hist[val] + 1;\n        }\n        old = val;\n    }\n    hist[old] = acc;\n```\n\n为克服这一缺陷，我们可以使用 DEPENDENCE 指令，为 Vivado HLS 提供这些依赖关系的附加信息。\n\n```c\nvoid histogram(int in[INPUT SIZE], int hist[VALUE SIZE]) {\n    int acc = 0;\n    int i, val;\n    int old = in[0];\n    #pragma HLS DEPENDENCE variable=hist intra RAW false\n    for(i = 0; i < INPUT SIZE; i++)\n    {\n        #pragma HLS PIPELINE II=1\n        val = in[i];\n        if(old == val)\n        {\n        \tacc = acc + 1;\n        }\n        else\n        {\n            hist[old] = acc;\n            acc = hist[val] + 1;\n        }\n        old = val;\n    }\n    hist[old] = acc;\n```\n\n> NOTE：在实际上依赖关系并非 FALSE 的情况下指定 FALSE 依赖关系可能导致硬件错误。指定依赖关系前，请确认它是否正确（TRUE 或 FALSE）。\n\n指定依赖关系时，有 2 种主要类型：\n\n- Inter：指定相同循环的不同迭代之间的依赖关系。\n\n  如指定为 FALSE，则当循环已流水线化、已展开或已部分展开时，允许 Vivado HLS 并行执行运算，指定为 TRUE 时则阻止此类并行运算。\n\n- Intra：指定循环的相同迭代内的依赖关系，例如，在相同迭代开始和结束时访问的数组。\n\n  当 intra 依赖关系指定为 FALSE 时，Vivado HLS 可在循环内自由移动运算、提升运算移动性，从而可能改善性能或面积。当此依赖关系指定为 TRUE 时，必须按指定顺序执行运算。\n\n#### 标量依赖关系\n\n部分标量依赖关系较难以解析，且通常需要更改源代码。标量数据依赖关系如下所示：\n\n```c\nwhile (a != b) {\n    if (a > b) a -= b;\n    else b -= a;\n}\n```\n\n此循环的当前迭代完成 a 和 b 的更新值计算后才能启动下一次迭代，如下图所示。\n\n![image-20230328150950867](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281509897.png)\n\n如果必须得到上一次循环迭代结果后才能开始当前迭代，则无法进行循环流水线化。如果 Vivado HLS 无法以指定的启动时间间隔进行流水线化，那么它会增加启动时间间隔。如果完全无法流水线化，则它会停止流水线化并继续输出非流水线化设计。\n\n#### 最优化循环展开以改善流水线\n\n默认情况下，在 Vivado HLS 中循环保持处于收起状态。这些收起的循环会生成硬件资源，供循环的每次迭代使用。虽然这样可以节省硬件资源，但有时可能导致性能瓶颈。\n\nVivado HLS 可提供使用 UNROLL 指令来展开或部分展开 for 循环的功能。\n\n下图显示了循环展开的优势以及展开循环时必须考量的影响。此示例假定 a[i]、b[i] 和 c[i] 数组已映射到 BRAM 。此示例显示只需直接应用UNROLL约束即可同时创建大批不同的实现方式。\n\n![image-20230328151501979](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281515036.png)\n\n- 循环未展开：当循环未展开时，每次迭代都在单独的时钟周期内执行。此实现需耗时 4 个时钟周期，只需 1 个乘法器并且每个 BRAM 均可为单端口 BRAM。\n- 循环部分展开：在此示例中，循环已按因子 2 进行展开。此实现需 2 个乘法器和双端口 RAM ，以支持在同一个时钟周期内读取或写入每个 RAM。但此实现只需 2 个时钟周期即可完成：相比于循环未展开的版本，启动时间间隔和时延均减半。\n- 循环全部展开：在完全展开的版本中，可在单一时钟周期内执行所有循环操作。但此实现需 4 个乘法器。更重要的是，此实现需在同一个时钟周期内执行 4 次读操作和 4 次写操作的功能。由于 BRAM 最多仅有 2 个端口，因此该实现方式需对数组进行分区。\n\n要执行循环展开，可向设计中的每个循环应用 UNROLL 指令。或者，可向函数应用 UNROLL 指令，以展开函数作用域内的所有循环。\n\n如果循环已完全展开，那么只要数据依赖关系和资源允许，即可并行执行所有操作。<u>如果某一循环迭代中的操作需要上一次循环的结果，则这两次迭代无法并行执行，但一旦数据可用即可立即执行。</u>\n\n以下示例演示了如何使用循环展开来创建最优化的设计。在此示例中，数据作为交织式通道存储在数组中。如果按 II=1 来对循环进行流水线化，则每经过 8 个时钟周期才会对<u>每个通道</u>执行依次读取和写入。\n\n```c\n// Array Order : 0 1 2 3 4 5 6 7 8 9 10 etc. 16\netc...\n// Sample Order: A0 B0 C0 D0 E0 F0 G0 H0 A1 B1 C1 etc. A2\netc...\n// Output Order: A0 B0 C0 D0 E0 F0 G0 H0 A0+A1 B0+B1 C0+C1 etc. A0+A1+A2\netc...\n#define CHANNELS 8\n#define SAMPLES 400\n#define N CHANNELS * SAMPLES\nvoid foo (dout_t d_out[N], din_t d_in[N]) {\n    int i, rem;\n    // Store accumulated data\n    static dacc_t acc[CHANNELS];\n    // Accumulate each channel\n    For_Loop: for (i=0;i<N;i++) {\n        rem=i%CHANNELS;\n        acc[rem] = acc[rem] + d_in[i];\n        d_out[i] = acc[rem];\n    }\n}\n```\n\n按 factor 为 8 来对循环进行部分展开将允许并行处理每个通道（每 8 个样本为一组），前提是输入数组和输出数组同样按 cyclic 方式进行分区，以便在每个时钟周期内进行多次访问。如果此循环同时采用 rewind 选项来进行流水线化，<u>那么此设计将持续并行处理全部 8 个通道</u>，前提是要以流水线方式（即在顶层或者在数据流区域中）调用这些通道。\n\n```c\nvoid foo (dout_t d_out[N], din_t d_in[N]) {\n#pragma HLS ARRAY_PARTITION variable=d_i cyclic factor=8 dim=1 partition\n#pragma HLS ARRAY_PARTITION variable=d_o cyclic factor=8 dim=1 partition\n\tint i, rem;\n    // Store accumulated data\n    static dacc_t acc[CHANNELS];\n    // Accumulate each channel\n    For_Loop: for (i=0;i<N;i++) {\n        #pragma HLS PIPELINE rewind\n        #pragma HLS UNROLL factor=8\n        rem=i%CHANNELS;\n        acc[rem] = acc[rem] + d_in[i];\n        d_out[i] = acc[rem];\n    }\n}\n```\n\n部分循环展开不要求展开因子为最大迭代计数的整数倍。Vivado HLS 会添加出口检查以确保部分展开的循环的功能与原始循环相同。例如，给定以下代码：\n\n```c\nfor(int i = 0; i < N; i++) {\n    a[i] = b[i] + c[i];\n}\n```\n\n按因子 2 展开的循环可将代码有效变换为如下示例所示形式，其中 break 构造器用于确保功能保持不变：\n\n```c\nfor(int i = 0; i < N; i += 2) {\n    a[i] = b[i] + c[i];\n    if (i+1 >= N) break;\n    a[i+1] = b[i+1] + c[i+1];\n}\n```\n\n由于 N 为变量，Vivado HLS 可能无法判定其最大值（它可能受输入端口驱动）。<u>如果展开因子（在此例中为 2）是最大迭代计数 N 的整数因子，那么 skip_exit_check 选项会移除出口检查和关联的逻辑。</u>展开的效果现在可表示为：\n\n```c\nfor(int i = 0; i < N; i += 2) {\n    a[i] = b[i] + c[i];\n    a[i+1] = b[i+1] + c[i+1];\n}\n```\n\n这有助于最大限度降低面积并简化控制逻辑。\n\n#### 利用任务级别并行化：数据流最优化\n\n数据流最优化对于一系列顺序任务（例如，函数或循环）很实用，如下图所示。\n\n![image-20230328153113527](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281531566.png)\n\n上图显示了连续 3 个任务的特定情况，但通信结构比所示情况可能更复杂。\n\n通过使用这一系列顺序任务，数据流最优化可以创建并发进程架构，如下所示。数据流最优化是可用于改进设计吞吐量和时延的强大方法。\n\n![image-20230328153145851](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281531888.png)\n\n下图显示了数据流最优化允许重叠执行任务的方式，由此可提升总体设计吞吐量并降低时延。\n\n在以下图示和示例中，(A) 表示无数据流最优化的情况。实现需经历 8 个周期后，func_A 才能处理新输入，还需要 8 个周期后 func_C 才能写入输出。\n\n对于同样的示例，(B) 表示应用数据流最优化的情况。func_A 每隔 3 个时钟周期即可开始处理新输入（启动时间间隔更低），只需 5 个时钟即可输出最终值（时延更短）。\n\n![image-20230328153243077](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281532126.png)\n\n这种类型的并行化势必伴随着硬件开销。将某个特定区域（例如，函数主体或循环主体）识别为要应用数据流最优化的区域时，Vivado HLS 会分析此函数主体或循环主体，并创建独立通道以对数据流进行建模，用于将每项任务的结果存储在数据流区域中。这些通道对于标量变量而言可能只是简单的 FIFO，而对于数组之类非标量变量，则可能是乒乓缓存。其中每个通道还都包含用于指示 FIFO 或乒乓缓存已满或已空的信号。这些信号表示完全数据驱动的握手接口。通过采用独立 FIFO 和/或乒乓缓存，Vivado HLS 可使每项任务按其自己的步调执行，吞吐量仅受输入和输出缓存的可用性限制。由此实现的任务执行交织比正常流水线化实现更好，但导致增加 FIFO 或 BRAM 寄存器（用于乒乓缓存）成本。前图所示的数据流区域实现的结构与下图中相同示例所示结构相同。\n\n![image-20230328153521883](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281535923.png)\n\n数据流最优化的性能可能比静态流水线化解决方案的性能更好。它将严格集中控制的流水线停滞理念替换为更灵活的分布式握手架构，后者使用 FIFO 或乒乓缓存。\n\n### 时延最优化\n\n主要思路如下：首先使用时延约束指明HLS工具的优化方向，然后针对循环进行优化，是否可以对循环进行合并以减少时延，是否可以将嵌套的循环扁平化，避免进出循环的时延。\n\n#### 使用时延约束\n\nVivado HLS 支持对任意作用域使用时延约束。时延约束是使用 LATENCY 指令来指定的。\n\n对作用域施加最大和/或最小 LATENCY 约束时，Vivado HLS 会尝试确保函数内的所有运算都在指定的时钟周期范围内完成。\n\n应用于循环的时延指令可指定单次循环迭代所需的时延：它指定循环主体的时延，如以下示例所示：\n\n```c\nLoop_A: for (i=0; i<N; i++) {\n    #pragma HLS latency max=10\n    ..Loop Body...\n}\n```\n\n如果要限制所有循环迭代的总时延，应将时延指令应用于包含整个循环的区域，如以下示例所示：\n\n```c\nRegion_All_Loop_A: {\n#pragma HLS latency max=10\n    Loop_A: for (i=0; i<N; i++)\n    {\n        ..Loop Body...\n    }\n}\n```\n\n在此情况下，即使展开循环，时延指令仍会对所有循环操作设置最大限制。\n\n如果 Vivado HLS 无法满足最大时延约束，它会放宽时延约束，并尝试尽可能实现最佳结果。\n\n如果设置最小时延约束，并且 Vivado HLS 生成的设计时延低于所需的最小值，它会插入虚拟时钟周期以满足最小时延（笔者理解这边就是强行打拍）。\n\n#### 合并顺序循环以减少时延\n\n所有收起的循环都在设计 FSM 中指明并创建至少一种状态。当存在多个顺序循环时，它可能会创建其它不必要的时钟周期，并阻止进一步的最优化。\n\n下图显示了一个简单的示例，其中看似直观的编码样式对 RTL 设计的性能产生了负面影响。\n\n![image-20230328154214397](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281542447.png)\n\n在上图中，(A) 显示了默认情况下设计中的每个收起的循环如何在 FSM 中创建至少一种状态。在这些状态之间移动需耗费多个时钟周期：假设每个循环迭代需要 1 个时钟周期，则执行两个循环总共需要 11 个周期：\n\n- 需要 1 个时钟周期进入 ADD 循环。\n- 需要 4 个时钟周期执行加法循环。\n- 需要 1 个时钟周期退出 ADD 并进入 SUB。\n- 需要 4 个时钟周期执行 SUB 循环。\n- 需要 1 个时钟周期退出 SUB 循环。\n- 总共 11 个时钟周期。\n\n在这个简单的示例中，很明显，ADD 循环中的 else 分支也可以解决该问题，但是在更复杂的示例中，它可能不那么明显，更直观的编码方式可能具有更大的优势。\n\nLOOP_MERGE 最优化指令用于自动合并循环。LOOP_MERGE 指令将尝试合并应用范围内的所有循环。在上面的示例中，合并循环将创建类似于上图 (B) 所示的控制结构，完成它只需要 6 个时钟周期。\n\n合并循环允许将循环内的逻辑组合在一起进行最优化。在上面的示例中，使用真双口 BRAM 可以并行执行加减运算。\n\n当前在 Vivado HLS 中合并循环具有以下限制：\n\n- 如果循环边界都是变量，则它们必须具有相同的值。\n- 如果循环边界为常量，那么最大常量值用作为合并循环的边界。\n- 具有变量边界和常量边界的循环无法合并。\n- 要合并的循环之间的代码不得产生不同结果：多次执行此代码应生成相同的结果（允许使用 a = b，不允许使用 a = a + 1）。\n- 包含 FIFO 访问的循环无法合并：合并将更改 FIFO 上的读写顺序：这些循环必须始终按顺序进行。\n\n#### 将嵌套循环扁平化以改善时延\n\n已展开的嵌套循环之间的移动需要额外的时钟周期，这与前述章节中所述的连续循环间移动方式相似。从外层循环移至内层循环需要一个时钟周期，从内层循环移至外层循环同样如此。\n\n在此处所示小型示例中，这暗示执行 Outer 循环需 200 个额外时钟周期。\n\n```c\nvoid foo_top { a, b, c, d} {\n    ...\n    Outer: while(j<100){\n        Inner: while(i<6){ // 1 cycle to enter inner\n            ...\n            LOOP_BODY\n            ...\n        } // 1 cycle to exit inner\n    }\n    ...\n}\n```\n\nVivado HLS 提供的 set_directive_loop_flatten 命令允许将已标记为完美和半完美的嵌套循环扁平化，这样就无需重新编码来提升硬件性能，并且还可减少执行循环中的运算所需的周期数。\n\n- 完美循环嵌套：仅限最内层的循环才有循环主体内容，逻辑语句之间未指定任何逻辑，所有循环边界均为常量。\n- 半完美循环嵌套：仅限最内层的循环才有循环主体内容，逻辑语句之间未指定任何逻辑，<u>除最外层循环外</u>所有循环边界均为常量。\n\n对于非完美循环嵌套，即内层循环具有变量边界或者循环主体未完全包含在内层循环内，设计人员应尝试重构代码或者将循环主体中的循环展开以创建完美循环嵌套。\n\n将该指令应用于一组嵌套循环时，应将其应用于最内层循环。\n\n```c\nset_directive_loop_flatten top/Inner\n```\n\n循环扁平化还可使用 GUI 中的“Vivado HLS Directive Editor”选项执行，可将其单独应用于各循环，或者通过在函数级别应用该指令来将其应用于函数中的所有循环。\n\n### 面积最优化\n\n主要可以从下面几个角度考虑：更精准地对数据的类型和位宽进行设置，避免资源的浪费；通过函数的内联来复用模块；通过对函数进行精准的例化来减少函数的通用性，降低资源占用；对于数组而言，首先考虑数据的存取需求，在满足吞吐率的情况下考虑是否可以对数据进行合并，节省存储的 BRAM 资源；此外，对一些复杂运算而言，通过显式制定硬件核可以节省较多的片上逻辑资源，并改善性能。\n\n#### 数据类型和位宽\n\nC 语言函数中的变量位宽会直接影响 RTL 实现中使用的存储元素和运算符。如果变量只需 12 位但指定为整数类型（32 位），这会导致HLS使用更大且运算更慢的 32 位运算符，从而减少一个时钟周期内可执行的运算数量，并可能增大启动时间间隔和时延。为此请特别注意如下几点：\n\n- 使用适合数据类型的相应精度。\n- 确认要使用 RAM 还是寄存器来实现数组。任何过大的元素都会影响面积，从而导致硬件资源浪费。\n- 请特别注意乘法、除法、取模或其它复杂算术运算。如果这些变量过大，则会对面积和性能都产生负面影响。\n\n#### 函数内联\n\n函数内联会移除函数层级。函数可使用 INLINE 指令进行内联。内联函数可以支持函数中的逻辑共享，以更高效的方式调用函数中的逻辑，从而改善面积。Vivado HLS 也会自动执行此类型的函数内联。小型函数可自动内联。\n\n内联支持对函数共享进行更有效的控制。对于要共享的函数，必须在相同层级内使用。在此代码示例中，foo_top 函数会对 foo 进行 2 次调用，并调用 foo_sub 函数。\n\n```c\nfoo_sub (p, q) {\n    int q1 = q + 10;\n    foo(p1,q); // foo_3\n    ...\n}\nvoid foo_top { a, b, c, d} {\n    ...\n    foo(a,b); //foo_1\n    foo(a,c); //foo_2\n    foo_sub(a,d);\n    ...\n}\n```\n\n将函数 foo_sub 内联并使用 ALLOCATION 指令指定仅使用 foo 函数的 1 个实例，这样生成的设计仅含 1 个 foo 函数的实例：面积为以上示例的三分之一。\n\n```c\nfoo_sub (p, q) {\n    #pragma HLS INLINE\n    int q1 = q + 10;\n    foo(p1,q); // foo_3\n    ...\n}\nvoid foo_top { a, b, c, d} {\n#pragma HLS ALLOCATION instances=foo limit=1 function\n    ...\n    foo(a,b); //foo_1\n    foo(a,c); //foo_2\n    foo_sub(a,d);\n    ...\n}\n```\n\nINLINE 指令可选择使用 recursive 选项来<u>允许位于指定函数下层的所有函数以递归方式进行内联</u>。如果对顶层函数使用 recursive 选项，那么将移除设计中的所有函数层级。\n\n可选择对函数应用 INLINE off 选项以阻止对这些函数进行内联。该选项可用于阻止 Vivado HLS 自动进行函数内联。\n\nINLINE 指令是大幅修改代码结构而不对源代码执行任何实际修改的强大方法，并可提供强大的架构探索方法。\n\n#### 将大量数组映射到单一大型数组\n\n当 C 语言代码中存在大量小型数组时，将其映射到单一大型数组通常可减少所需的 BRAM 数量。\n\n受器件支持的前提下，每个数组都映射到 1 个块 RAM 或 UltraRAM。任一 FPGA 中提供的基本块 RAM 单元为 18K。如有大量小型数组且占用资源不足 18K，那么为了更有效地利用 BRAM 资源，可将大量小型数组映射到单一大型数组。如果 BRAM 大于 18K，则会自动将其映射到多个 18K 单元。在综合报告中，请复查“Utilization Report” →“Details” → “Memory”，以便详细了解设计中 BRAM 的使用情况。\n\nARRAY_MAP 指令支持通过 2 种方式将多个小型数组映射到单一大型数组：\n\n- 水平映射：从数组的深度方向进行合并，通过并置原始数组来创建新阵列。实际上，这作为含更多元素的单一数组来实现。\n- 垂直映射：从数组的位宽方向进行合并，通过并置数组中的字词来创建新阵列。实际上，这作为含较大位宽的单一数组来实现。\n\n##### 水平数组映射\n\n以下代码示例包含 2 个数组，这些数组将生成 2 个 RAM 组件。\n\n```c\nvoid foo (...) {\n    int8 array1[M];\n    int12 array2[N];\n    ...\n    loop_1: for(i=0;i<M;i++) {\n        array1[i] = ...;\n        array2[i] = ...;\n        ...\n    }\n    ...\n}\n```\n\n数组 array1 和 array2 可组合为单一数组，在以下示例中指定为 array3：\n\n```c\nvoid foo (...) {\n    int8 array1[M];\n    int12 array2[N];\n    #pragma HLS ARRAY_MAP variable=array1 instance=array3 horizontal\n    #pragma HLS ARRAY_MAP variable=array2 instance=array3 horizontal\n    ...\n    loop_1: for(i=0;i<M;i++) {\n        array1[i] = ...;\n        array2[i] = ...;\n        ...\n    }\n    ...\n}\n```\n\n在此示例中，ARRAY_MAP 指令按下图所示方式对数组进行变换。\n\n![image-20230328160927354](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281609395.png)\n\n使用水平映射时，多个较小的数组将映射到单一较大的数组。映射从较大的数组中的位置 0 开始，并遵循指定命令的顺序执行映射。\n\n使用下图所示的水平映射时，BRAM 中的实现如下图所示。\n\n![image-20230328161038533](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281610573.png)\n\nARRAY_MAP 指令的 offset 选项用于指定使用 horizontal 选项时后续数组添加到的位置。重复先前示例，但反转命令顺序（先指定 array2，然后指定 array1）并添加 offset，如下所示：\n\n```c\nvoid foo (...) {\n    int8 array1[M];\n    int12 array2[N];\n#pragma HLS ARRAY_MAP variable=array2 instance=array3 horizontal\n#pragma HLS ARRAY_MAP variable=array1 instance=array3 horizontal offset=2\n...\nloop_1: for(i=0;i<M;i++) {\n    array1[i] = ...;\n    array2[i] = ...;\n    ...\n}\n...\n}\n```\n\n这将导致如下图所示的变换。\n\n![image-20230328161332982](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281613028.png)\n\n映射后，新构成的数组（即以上示例中的 array3）可通过向映射到新实例的任意变量应用 RESOURCE 指令来定向到特定 BRAM 或 UltraRAM。\n\n虽然水平映射可能导致使用的块 RAM 组件数量减少从而改善面积，但<u>它确实会影响吞吐量和性能</u>，因为当前 BRAM端口数量有所减少。为克服此限制，Vivado HLS 还提供了垂直映射。\n\n##### 映射垂直数组\n\n在垂直映射中，通过并置多个数组来生成位宽更高的单个数组。下图显示了应用垂直映射模式时，前述示例所发生的变化。\n\n```c\nvoid foo (...) {\n    int8 array1[M];\n    int12 array2[N];\n    #pragma HLS ARRAY_MAP variable=array2 instance=array3 vertical\n    #pragma HLS ARRAY_MAP variable=array1 instance=array3 vertical\n    ...\n    loop_1: for(i=0;i<M;i++) {\n        array1[i] = ...;\n        array2[i] = ...;\n        ...\n    }\n    ...\n}\n```\n\n![image-20230328161554312](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281615357.png)\n\n在垂直映射中，按命令指定顺序并置各数组，指定的数组排序顺序为从 LSB 开始到 MSB 结束。完成垂直映射后，新组成的数组将在单一BRAM 组件内实现，如下图所示。\n\n![image-20230328161631412](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281616450.png)\n\n#### 数组映射以及注意事项\n\n> NOTE：数组变换的优化指令在代码中放置的位置必须先于其它任何与数组相关的优化指令。\n\n要将元素从已分区的数组映射到含 horizontal 映射的单一数组中，必须在 ARRAY_MAP 指令中指定数组的每个要分区的元素。例如，以下 Tcl 命令用于对 accum 数组进行分区，并将生成的元素重新映射到一起。\n\n```c\n#pragma HLS array_partition variable=m_accum cyclic factor=2 dim=1\n#pragma HLS array_partition variable=v_accum cyclic factor=2 dim=1\n#pragma HLS array_map variable=m_accum[0] instance=mv_accum horizontal\n#pragma HLS array_map variable=v_accum[0] instance=mv_accum horizontal\n#pragma HLS array_map variable=m_accum[1] instance=mv_accum_1 horizontal\n#pragma HLS array_map variable=v_accum[1] instance=mv_accum_1 horizontal\n```\n\n可对全局数组进行映射。但生成的数组实例为全局实例，映射到该数组实例的任何局部数组都会变为全局数组。当不同函数的局部数组映射到同一目标数组时，目标数组实例就会变为全局实例。\n\n#### 数组重塑\n\nARRAY_RESHAPE 指令将 ARRAY_PARTITIONING 与 ARRAY_MAP 的垂直模式相结合，用于减少 BRAM 数量，同时仍支持分区的有利特性：并行访问数据。\n\n给定以下示例代码：\n\n```c\nvoid foo (...) {\n    int array1[N];\n    int array2[N];\n    int array3[N];\n    #pragma HLS ARRAY_RESHAPE variable=array1 block factor=2 dim=1\n    #pragma HLS ARRAY_RESHAPE variable=array2 cycle factor=2 dim=1\n    #pragma HLS ARRAY_RESHAPE variable=array3 complete dim=1\n    ...\n}\n```\n\nARRAY_RESHAPE 指令可将数组转换为下图所示形式。\n\n![image-20230328162456971](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281624025.png)\n\nARRAY_RESHAPE 指令支持在单一时钟周期内访问更多数据。只要能在单一时钟周期内访问更多数据，Vivado HLS 即可自动展开使用此数据的所有循环，前提是这样有助于提升吞吐量。循环可全部或部分展开以提高数据的吞吐率。此功能可使用 config_unroll 命令和 tripcount_threshold 选项来加以控制。在以下示例中，循环次数小于 16 的任何循环都将自动展开（前提是可提高吞吐量）。\n\n```c\nconfig_unroll -tripcount_threshold 16\n```\n\n#### 函数例化\n\n函数例化是一种最优化技巧，不仅具有维持函数层级的面积优势，还可提供另一个强大的选项：在函数的特定实例上执行针对性局部最优化。这样可以简化围绕函数调用的控制逻辑，也可能改进时延和吞吐量。\n\n鉴于调用函数时部分函数输入可能是常量，FUNCTION_INSTANTIATE 指令可借此简化周围控制结构，并生成进一步优化的、更小的函数块。这可通过示例来细化解释。\n\n给定如下代码：\n\n```c\nvoid foo_sub(bool mode){\n#pragma HLS FUNCTION_INSTANTIATE variable=mode\n    if (mode) {\n    \t// code segment 1\n    } else {\n    \t// code segment 2\n    }\n}\nvoid foo(){\n#pragma HLS FUNCTION_INSTANTIATE variable=select\n    foo_sub(true);\n    foo_sub(false);\n}\n```\n\n很明显，函数 foo_sub 的功能为执行单一重复性运算（根据 mode 是否为 true）。函数 foo_sub 的每个实例均以相同方式实现：这非常适合函数复用和面积最优化，但也意味着函数内部的控制逻辑必须更加复杂。\n\nFUNCTION_INSTANTIATE 最优化允许对每个实例进行独立最优化，从而减少功能和面积。完成FUNCTION_INSTANTIATE 最优化后，以上代码可有效转换为 2 个独立函数，每个函数都针对模式的不同可能值来完成最优化，如下所示：\n\n```c\nvoid foo_sub1() {\n\t// code segment 1\n}\nvoid foo_sub2() {\n\t// code segment 2\n}\nvoid A(){\n    foo_sub1();\n    foo_sub2();\n}\n```\n\n在不进行大幅内联或代码修改的情况下，在不同层级使用该函数会导致函数难以共享，那么函数例化约束可提供改进面积的最佳方法：大量小型局部最优化的函数副本比大量无法共享的大型函数副本更有效。\n\n#### 控制硬件资源\n\n综合期间，Vivado HLS 会执行以下基本任务：\n\n- 首先，将 C、C++ 或 SystemC 语言源代码细化为包含运算符的内部数据库。\n\n  运算符表示 C 语言代码中的运算，如加法、乘法、数组读取和写入等。\n\n- 然后，将运算符映射到实现硬件操作的核上。\n\n​\t\t核为用于创建设计的特定硬件组件（例如，加法器、乘法器、流水线化的乘法器和 BRAM）。\n\n作为设计者，我们可以控制其中每个步骤，从而对硬件实现进行精细化的控制。\n\n##### 限制运算符数量\n\n显式限制运算符的数量以减小某些情况下所需的面积：Vivado HLS 的默认操作是首先最大限度提升性能。限制设计中的运算符数量是一项减小面积的实用技巧：<u>它通过强制共享运算来减小面积。</u>\n\nALLOCATION 指令允许设计者限制设计中使用的运算符、核或函数数量。例如，名为 foo 的设计包含 317 次乘法，但FPGA 仅有 256 项乘法器资源 (DSP48)。以下所示 ALLOCATION 指令可指示 Vivado HLS 创建含最多 256 个乘法 (mul) 运算符的设计：\n\n```c\ndout_t array_arith (dio_t d[317]) {\n    static int acc;\n    int i;\n#pragma HLS ALLOCATION instances=mul limit=256 operation\n    for (i=0;i<317;i++) {\n#pragma HLS UNROLL\n        acc += acc * d[i];\n    }\n\treturn acc;\n}\n```\n\n> NOTE：如果指定的 ALLOCATION 限制超出所需数量，Vivado HLS 会尝试使用此项限制指定的资源数量，导致减少共享量。\n\n设计者可使用 type 选项来指定 ALLOCATION 指令是否限制运算、核和函数数量。下表列出了可使用 ALLOCATION 指令控制的所有运算。\n\n![image-20230328163850809](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281638870.png)\n\n\n\n##### 全局最大限度减少运算符\n\nALLOCATION 指令与所有其它指令一样，都是在某一作用域内指定的：函数、循环或区域。config_bind 配置允许在整个设计中最大限度减少运算符。\n\n在设计中要最大限度减少运算符，可执行 config_bind 配置中的 min_op 选项。前表中列出的任意运算符均可按此方式加以限制。\n\n应用配置后，它将应用于解决方案中执行的所有综合操作：如果关闭再重新打开解决方案，那么指定的配置仍适用于所有新综合运算。\n\n随 config_bind 配置一起应用的任意配置均可使用 reset 选项来移除，或者使用 open_solution -reset 以打开解决方案。\n\n##### 控制硬件核\n\n执行综合时，Vivado HLS 会使用由时钟指定的时序约束、由目标器件指定的延迟以及由您指定的任意指令来判定使用哪个核来实现运算符。例如，要实现乘法运算，Vivado HLS 可使用组合乘法器核或使用流水线乘法器核。\n\n综合期间映射到运算符的核可采用与运算符相同的方式来加以限制。您无需限制乘法运算总数，而可改为选择限制组合乘法器核的数量以强制使用流水线化乘法器来执行所有剩余乘法（或反之亦然）。这是通过将 ALLOCATION 指令 type 选项指定为 core 来实现的。\n\nRESOURCE 指令用于显式指定要用于特定操作的核。在以下示例中指定使用 2 阶流水线化乘法器以实现变量的乘法运算。以下命令会告知 Vivado HLS 针对变量 c 使用 2 阶流水线化乘法器。由 Vivado HLS 判定用于变量 d 的核。\n\n```c\nint foo (int a, int b) {\n    int c, d;\n    #pragma HLS RESOURCE variable=c latency=2\n    c = a*b;\n    d = a*c;\n    return d;\n}\n```\n\n在以下示例中，RESOURCE 指令指定变量 temp 的加法运算，并使用 AddSub_DSP 核来实现。这样可确保在最终设计中使用 DSP48 原语来实现此运算 - 默认情况下加法运算是使用 LUT 来实现的。\n\n```c\nvoid apint_arith(dinA_t inA, dinB_t inB, dout1_t *out1) {\n    dout2_t temp;\n#pragma HLS RESOURCE variable=temp core=AddSub_DSP\n    temp = inB + inA;\n    *out1 = temp;\n}\n```\n\nlist_core 命令用于获取有关库中可用的核的详细信息。list_core 只能在 Tcl 命令界面中使用，并且必须使用set_part 命令指定器件。如果未选中器件，此命令将无效。list_core 命令的 -operation 选项列出了库中可通过指定运算实现的所有核。下表列出了用于实现标准 RTL 逻辑运算（例如，加法、乘法和比较）的核。\n\n![image-20230328164345838](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281643899.png)\n\n除标准核外，当运算使用浮点类型时还可使用以下浮点核。请参阅每个器件的文档以判定在器件中是否支持浮点核。\n\n![image-20230328164551072](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281645137.png)\n\n![image-20230328164610631](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281646688.png)\n\n下表列出了用于实现存储元素的核。\n\n![image-20230328164649608](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281646677.png)\n\n![image-20230328164703103](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281647149.png)\n\nRESOURCE 指令使用已赋值的变量作为资源目标。给定代码的情况下，RESOURCE 指令可指定 out1 的乘法使用 3 阶流水线化乘法器来实现。\n\n```c\nvoid foo(...) {\n#pragma HLS RESOURCE variable=out1 latency=3\n    // Basic arithmetic operations\n    *out1 = inA * inB;\n    *out2 = inB + inA;\n    *out3 = inC / inA;\n    *out4 = inD % inA;\n}\n```\n\n如果赋值指定多个相同的运算符，则必须修改此代码以<u>确保针对要控制的每个运算符都存在单一变量</u>。例如，此示例中，如果仅使用流水线化乘法器来实现首个乘法 (inA * inB)：\n\n```c\n*out1 = inA * inB * inC;\n```\n\n那么应使用 Result_tmp 变量上指定的指令来将代码更改为：\n\n```c\n#pragma HLS RESOURCE variable=Result_tmp latency=3\nResult_tmp = inA * inB;\n*out1 = Result_tmp * inC;\n```\n\n##### 全局最优化硬件核\n\nconfig_bind 配置项使开发者能改变将核与运算符绑定时所需的工作量。默认情况下，Vivado HLS 会选择能在时序与面积间实现最佳平衡的核。config_bind 能影响所使用的运算符。\n\n```c\nconfig_bind -effort [low | medium | high] -min_op <list>\n```\n\nconfig_bind 命令只能在处于活动状态的解决方案内发出。绑定运算的默认运行策略是 medium。\n\n- low 工作量：减少共享时间，运行时间更短，但最终 RTL 占用的资源可能更大。适用案例为设计人员已知几乎不可能存在运算共享或者几乎没有符合期望的运算共享，并且不希望将 CPU 周期浪费在探寻运算共享可能性上。\n- medium 工作量：默认设置，Vivado HLS 会尝试共享运算，但尽力在合理时间内完成运算。\n- high 工作量：尝试最大限度共享运算，不限制运行时间。Vivado HLS 不断尝试直至完成所有可能的运算共享组合为止。\n\n### 最优化逻辑\n\n主要考虑运算符的流水线以及是否可以进行表达式平衡的工作。\n\n#### 控制运算符流水线化\n\nVivado HLS 会自动判定用于内部运算的流水线化级别。设计者可将 RESOURCE 指令与 -latency 选项配合使用，以显式指定流水线阶段的数量，并覆盖由 Vivado HLS 判定的数量。\n\nRTL 综合可使用多个额外流水线寄存器来帮助改善布局布线后可能导致的时序问题。在模块的输出信号中添加寄存器通常有助于改善输出数据路径中的时序。在模块的输入信号中添加寄存器通常有助于改善输入数据路径和来自 FSM 的控制逻辑中的时序。\n\n添加这些额外的流水线阶段的规则是：\n\n- 如果指定的时延比由 Vivado HLS 判定的时延多 1 个周期，Vivado HLS 会向运算输出添加新的输出寄存器。\n- 如果指定的时延比由 Vivado HLS 判定的时延多 2 个周期，Vivado HLS 会向运算输出以及运算的输入侧添加寄存器。\n- 如果指定的时延比由 Vivado HLS 判定的时延多 3 个或 3 个以上周期，Vivado HLS 会向运算的输出以及运算的输入侧添加寄存器。Vivado HLS 会自动判定任何附加的寄存器的位置。\n\n您可使用 config_core 配置对设计中特定核的具有相同流水线深度的所有实例进行流水线化。要设置此配置，请执行以下操作：\n\n1. 选择“Solutions” → “Solution Settings”。\n\n2. 在“解决方案设置 (Solution Settings)”对话框中，选择“General”类别，然后单击“Add”。\n\n3. 在“添加命令 (Add Command)”对话框中，选择 config_core 命令，并指定参数。\n\n   例如，以下配置指定使用 DSP48 核实现的所有运算均采用流水线化，且时延设置为 3，这是该核允许的最大时延：\n\n   ```c\n   config_core DSP48 -latency 3\n   ```\n\n   以下配置指定随 RAM_1P_BRAM 核实现的所有 BRAM 均采用流水线化，且时延设置为 3：\n\n   ```c\n   config_core RAM_1P_BRAM -latency 3\n   ```\n\n   > NOTE：Vivado HLS 仅将此核配置应用于含显式 RESOURCE 指令的 BRAM，该指令可指定用于实现数组的核。如果使用默认核来实现数组，那么核配置不影响 BRAM。\n\n#### 最优化逻辑表达式\n\n在综合期间会执行多次最优化（例如，强度折减和位宽最小化）。在自动最优化列表中也包括表达式平衡。\n\n> NOTE：强度折减个人理解是用简单的算子来实现复杂的算子。下面把维基百科的解释搬运一下：\n>\n> In compiler construction, **strength reduction** is a compiler optimization where expensive operations are replaced with equivalent but less expensive operations. The classic example of strength reduction converts \"strong\" multiplications inside a loop into \"weaker\" additions – something that frequently occurs in array addressing. \n>\n> Examples of strength reduction include:\n>\n> - replacing a multiplication within a loop with an addition\n> - replacing an exponentiation within a loop with a multiplication\n\n表达式平衡会重新排列运算符以构造平衡的树结构并降低时延。\n\n- 对于整数运算，默认情况下表达式平衡处于开启状态，但可将其禁用。\n- 对于浮点运算，默认情况下表达式平衡处于关闭状态，但可将其启用。\n\n对于使用如下示例所示的 += 和 *= 之类的赋值运算符的高度循序代码：\n\n```c\ndata_t foo_top (data_t a, data_t b, data_t c, data_t d)\n{\n    data_t sum;\n    sum = 0;\n    sum += a;\n    sum += b;\n    sum += c;\n    sum += d;\n    return sum;\n}\n```\n\n如果不使用表达式平衡并且假定每个加法都需要 1 个时钟周期，那么完整计算 sum 需要 4 个时钟周期，如下图所示。\n\n![image-20230328170612023](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281706060.png)\n\n但加法 a+b 和 c+d 可并行执行以缩减时延。经过平衡后，计算可在 2 个时钟周期内完成，如下图所示。\n\n![image-20230328170642852](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281706887.png)\n\n对于整数，您可使用 EXPRESSION_BALANCE 最优化指令配合 off 选项来禁用表达式平衡。默认情况下，Vivado HLS 对于 float 类型或 double 类型的运算不执行 EXPRESSION_BALANCE 最优化。对 float 和 double 类型进行综合时，Vivado HLS 会保留 C 语言代码中执行的运算顺序，以确保结果与 C 语言仿真相同。例如，在以下代码示例中，所有变量类型均为 float 或 double。O1 和 O2 即使看似执行相同的基本操作，其值也并不同。\n\n![image-20230328170804005](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281708041.png)\n\n该行为是 C 语言标准中执行 float 或 double 类型的运算时饱和和舍入所导致的结果。因此，存在类型为 float 或 double 的函数时，Vivado HLS 始终保留运算顺序不变，并且默认不执行表达式平衡。\n\n您可使用 config_compile 配置选项对 float 和 double 类型启用表达式平衡，如下所示：\n\n1. 选择“Solution” → “Solution Settings”。\n2. 在“解决方案设置 (Solution Settings)”对话框中，单击“General”类别，然后单击“Add”。\n3. 在“添加命令 (Add Command)”对话框中，选择“config_compile”，并启用“unsafe_math_operations”。\n\n启用此设置后，Vivado HLS 即可更改运算顺序，以生成更优化的设计。但 C/RTL 协同仿真的结果可能与 C 语言仿真不同。\n\nunsafe_math_operations 功能还支持 no_signed_zeros 最优化。no_signed_zeros 最优化可确保以下表达式配合浮点类型和双精度类型使用时结果完全相同：\n\n```c\nx - 0.0 = x;\nx + 0.0 = x;\n0.0 - x = -x;\nx - x = 0.0;\nx*0.0 = 0.0;\n```\n\n如果不使用 no_signed_zeros 最优化，由于舍入，以上表达式结果将不同。通过在 config_compile 配置中仅选中该选项，即可选择在不使用表达式平衡的情况下执行此最优化。\n\n> NOTE：使用 unsafe_math_operations 和 no_signed_zero 最优化时，RTL 实现结果将不同于 C 语言仿真。测试激励文件应可忽略结果中的轻微差异：检查范围，不执行精确比对。\n\n## Managing Interfaces\n\n在基于 C 语言的设计中，通过函数实参即可立即执行所有输入和输出操作。在 RTL 设计中，同样这些输入和输出操作必须通过设计接口中的端口来执行，并且通常使用特定 I/O（输入/输出）协议来进行操作。\n\nVivado HLS 支持使用以下解决方案来指定要使用的 I/O 协议类型：\n\n- 接口综合，其中端口接口基于高效的业界标准接口来创建。\n\n### 接口综合\n\n对顶层函数进行综合时，函数的实参（或参数）将综合到 RTL 端口中。此流程称为“接口综合 (interface synthesis)”。\n\n#### 接口综合概述\n\n以下代码提供了接口综合的完整概述。\n\n```c\n#include \"sum_io.h\"\ndout_t sum_io(din_t in1, din_t in2, dio_t *sum) {\n    dout_t temp;\n    *sum = in1 + in2 + *sum;\n    temp = in1 + in2;\n    return temp;\n}\n```\n\n以上代码示例包括：\n\n- 2 个输入：in1 和 in2。\n- 可供读取和写入的指针 sum。\n- return 函数，值为 temp。\n\n通过默认接口综合设置，设计将综合到含端口的 RTL 块中，如下图所示。\n\n![image-20230328173920377](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281739415.png)\n\nVivado HLS 会在 RTL 设计上创建 3 种类型的端口：\n\n- 时钟和复位端口：ap_clk 和 ap_rst。\n- 块级接口协议。在前图中已显示并展开这些端口：ap_start、ap_done、ap_ready 和 ap_idle。\n- 端口级接口协议。这些端口是针对顶层函数和函数返回（如果函数有返回值）中的每个实参创建的。在此示例中，这些端口包括：in1、in2、sum_i、sum_o、sum_o_ap_vld 和 ap_return。\n\n**时钟和复位端口**\n\n如果设计耗时超过 1 个周期才能完成操作，则会引入时钟与复位端口。\n\n（可选）可使用“Solution” → “Solution Settings” → “General”和 config_interface 配置将芯片使能端口添加到整个块中。\n\n复位操作由 config_rtl 配置控制。\n\n**块级接口协议**\n\n默认情况下，块级接口协议会添加到设计中。这些信号用于控制模块，与任意端口级 I/O 协议无关。这些端口用于控制模块开始处理数据的时间 (ap_start)、指示它是否已准备好开始接受新输入 (ap_ready) 以及指示设计是处于空闲状态(ap_idle) 还是已完成操作 (ap_done)。\n\n**端口级接口协议**\n\n最后一组信号是数据端口。创建的 I/O 协议取决于 C 语言实参的类型和默认值。使用块级协议启动块操作后，端口级 I/O 协议用于对进出模块的数据进行排序。\n\n默认情况下，输入按值传递 (pass-by-value) 实参和指针作为简单的线型端口来实现，无需关联的握手信号。因此在以上示例中，实现的输入端口不含 I/O 协议，仅为数据端口。如果此端口不含默认或按设计指定的 I/O 协议，那么输入数据必须保持稳定直至读取为止。\n\n默认输出指针实现时含关联的输出有效信号，用于指示何时输出数据有效。在上述示例中，输出端口实现时含关联的输出有效端口 (sum_o_ap_vld) 以指示何时端口上的数据有效并且可供读取。如果不存在与输出端口关联的 I/O 协议，那么将难以确定何时读取数据。最好始终在输出上使用 I/O 协议。\n\n同时支持读取和写入的函数实参将拆分为独立的输入端口和输出端口。在以上示例中，sum 作为输出端口 sum_i 和输出端口 sum_o 来实现，并具有关联的 I/O 协议端口 sum_o_ap_vld。\n\n如果函数具有返回值，则实现输出端口 ap_return 以提供返回值。当设计完成 1 项传输事务时（等同于执行 1 次 C 语言函数），块级协议会以 ap_done 信号来表明函数已完成。这也表示 ap_return 端口上的数据有效且可读。\n\n<!--返回顶层函数的值不能为指针。-->\n\n对于所示的示例代码，时序行为如下图所示（假定目标技术和时钟频率允许每个时钟周期执行一次加法）。\n\n![image-20230328174332182](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281743233.png)\n\n- 当 ap_start 断言为 High 时，即模块开始工作。\n- ap_idle 信号断言为 Low 以表示设计正在运行。\n- 输入数据可在首个周期后的任意时钟内读取。Vivado HLS 会调度读取发生的时间。读取所有输入后，ap_ready信号即断言为高位有效 (high)。\n- 计算输出 sum 时，关联的输出握手 (sum_o_ap_vld) 表示数据有效。\n- 当函数完成时，即断言 ap_done 有效。这也表示 ap_return 上的数据有效。\n- 端口 ap_idle 断言为 High 以表示设计正在等待再次启动。\n\n#### 接口综合I/O协议\n\n由接口综合所创建的接口类型取决于 C 语言实参的类型、默认接口模式以及 INTERFACE 最优化指令。下图显示了设计者可在每一种 C 语言实参类型上指定的接口协议模式。此图使用以下首字母缩略词：\n\n- D：每一种类型的默认接口模式。\n\n  <!--如果指定非法接口，Vivado HLS 会发出 1 条消息，并实现默认接口模式。-->\n\n- I：输入实参（只读）。\n- O：输出实参（只写）。\n- I/O：输入/输出实参（可读写）。\n\n![image-20230328174916295](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281749345.png)\n\n在接口综合参考章节中包含有关接口协议的完整信息（包括波形图），下面提供每个接口模式的概述。\n\n##### 块级接口协议\n\n块级接口协议包括 ap_ctrl_none、ap_ctrl_hs 和 ap_ctrl_chain。这些协议只能在函数或函数返回值处指定。在 GUI 中指定该指令时，会将这些协议应用于函数返回值。即使函数没有返回值，也可在函数返回值处指定块级协议。\n\n前述示例中所述的 ap_ctrl_hs 模式是默认协议。ap_ctrl_chain 协议类似于 ap_ctrl_hs，但具有额外的输入端口 ap_continue 以提供数据回压功能。如果函数完成时 ap_continue 端口为逻辑 0，此模块将停止操作，并且不会继续执行下一项传输事务。仅当 ap_continue 断言为逻辑 1 时，才会继续执行下一项传输事务。\n\nap_ctrl_none 模式用于实现不含任何块级 I/O 协议的设计。\n\n如果函数返回值同时指定为 AXI4-Lite 接口 (s_axilite)，<u>那么块级接口中的所有端口都将分组到此 AXI4-Lite 接口中。</u>我们在使用其它器件（如 CPU）来配置和控制模块的开始和停止操作时间时，常用此方法。\n\n##### 端口级接口协议：AXI4协议\n\nVivado HLS 支持的 AXI4 接口包括 AXI4-Stream 接口 (axis)、AXI4-Lite 从接口 (s_axilite) 和 AXI4 主接口 (m_axi)，这些接口可按以下方式指定：\n\n- AXI4-Stream 接口：仅在input实参或output实参上指定，而不在inout实参上指定。\n- AXI4-Lite 接口，在任何类型的实参上指定，但是array类型除外。设计者可以将多个实参分组到同一 AXI4-Lite 接口中。\n- AXI4 主接口：仅在数组和指针（以及 C++ 中的引用）上指定。设计者可以将多个实参分组到同一 AXI4 接口中。\n\n##### 端口级接口协议：无I/O协议\n\nap_none 和 ap_stable 模式可指定不向端口添加任何 I/O 协议。指定这些模式时，实参作为不含任何其它关联信号的数据端口来实现。ap_none 模式是标量输入的默认模式。<u>ap_stable 模式用于仅当器件处于复位模式时才可更改的配置输入。</u>\n\n##### 端口级接口协议：握手协议\n\n接口模式 ap_hs 包含与数据端口的双向握手信号。此握手属于业界标准的有效和确认握手。ap_vld 模式同样如此，但仅含有效端口，ap_ack 仅含确认端口。\n\nap_ovld 模式用于inout参数。将inout数据类型拆分为独立输入端口和输出端口时，ap_none 模式适用于其中的输入端口，ap_vld 适用于其中的输出端口。这是支持读写的指针实参的默认类型。\n\nap_hs 模式<u>可应用于按顺序读写的数组。</u>如果 Vivado HLS 可判定读访问或写访问为无序访问，它将停止综合并报错。如果无法判定访问顺序，Vivado HLS 将发出警告。\n\n##### 端口级接口协议：内存接口\n\n默认情况下，数组实参作为 ap_memory 接口来实现。这是含数据、地址、芯片使能和写使能端口的标准 BRAM 接口。\n\nap_memory 接口可作为单端口接口或双端口接口来实现。如果 Vivado HLS 可判定使用双端口接口可以缩短启动时间间隔，那么它将自动实现双端口接口。RESOURCE 指令用于指定内存资源，如果在含单端口 BRAM 的数组上指定该指令，那么将实现单端口接口。相反，如果使用 RESOURCE 指令指定双端口接口，并且 Vivado HLS 判定此接口并无益处，那么它将自动实现单端口接口。\n\nbram 接口模式的运作方式与 ap_memory 接口相同。唯一差异是在 Vivado IP integrator 中使用设计时，端口的实现方式。\n\n- ap_memory 接口显示为多个独立端口。\n- bram 接口显示为单个组合端口，可使用单一点对点连接来连接到赛灵思 BRAM。\n\n如果按顺序访问数组，可使用 ap_fifo 接口。就像 ap_hs 接口一样，如果 Vivado HLS 判定未按顺序进行数据访问，那么它将停止；如果无法判定是否采用顺序访问，则将发出警告；如果判定已采用顺序方式访问，则不发出任何消息。ap_fifo 接口只能用于读取或写入，不能用于同时读写。\n\nap_bus 接口可与总线网桥进行通信。此接口不遵循任何特定总线标准，但鉴于其泛用性，可配合总线网桥一起使用，从而与系统总线进行仲裁。<u>总线网桥必须能够将所有突发写操作进行缓存。</u>\n\n#### 接口综合和多次访问指针\n\n使用多次访问的指针可能会在综合后引发意外行为。在以下示例中，对指针 d_i 执行了 4 次读取，对指针 d_o 执行了 2 次写入：指针执行了多次访问。\n\n```c\n#include \"pointer_stream_bad.h\"\nvoid pointer_stream_bad ( dout_t *d_o, din_t *d_i) {\n\tdin_t acc = 0;\n\t\n    acc += *d_i;\n    acc += *d_i;\n    *d_o = acc;\n    acc += *d_i;\n    acc += *d_i;\n    *d_o = acc;\n}\n```\n\n综合后，此代码产生的 RTL 设计将读取 1 次输入端口，写入 1 次输出端口。与任何标准 C 语言编译器一样，Vivado HLS 将优化掉多余的指针访问。要按“预期”实现上述代码，即对 d_i 读取 4 次，对 d_o 写入 2 次，必须将指针指定为 volatile，如以下示例所示。\n\n```c\n#include \"pointer_stream_better.h\"\nvoid pointer_stream_better ( volatile dout_t *d_o, volatile din_t *d_i) {\n\tdin_t acc = 0;\n\t\n    acc += *d_i;\n    acc += *d_i;\n    *d_o = acc;\n    acc += *d_i;\n    acc += *d_i;\n    *d_o = acc;\n}\n```\n\n即使此段 C 语言代码也有问题。实际上，在测试激励文件上，除了为 d_i 提供一个值之外，无法执行任何其它操作，或者除了最终写入之外，也不能验证任何对 d_o 的写入。尽管支持多次访问指针，但Xilinx官方还是强烈建议使用 hls::stream 类实现所需的行为。\n\n#### 指定接口\n\n接口综合可通过 INTERFACE 指令或使用配置设置来加以控制。要在端口上指定接口模式，请在 GUI 的“Directives”选项卡中选择端口，右键单击并选择“Insert Directive”以打开“Vivado HLS Directive Editor”，如下图所示。\n\n![image-20230329104527503](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303291045565.png)\n\n在“Vivado HLS Directives Editor”中，设置以下选项：\n\n- “mode”\n\n  从下拉菜单中选择接口模式。\n\n- “register”\n\n  如果选择该选项，对输入数据会使用register进行暂存，对于输出端口，“register”选项可保证对输出进行寄存。设计者可将“register”选项应用于设计中的任意函数。对于内存、FIFO 和 AXI4 接口，“register”选项无效。\n\n- “depth”\n\n  该选项用于指定测试激励文件向设计提供的样本数量以及测试激励文件必须存储的输出值数量。以更大的数值为准。（与综合无关）\n\n  <!--：对于在单一传输事务内多次读取或写入的指针，需选中 “depth” 选项才能执行 C/RTL 协同仿真。对于数组而言或者使用 hls::stream 构造时，“depth”选项并不是必需的。 仅当在接口上使用指针时，才需选中该选项。-->\n\n  如果“depth”选项设置过小，那么 C/RTL 协同仿真可能出现死锁，如下所示：\n\n  1. 读取输入数据的操作可能停滞并等待数据，而测试激励文件无法提供这些数据。\n  2. 在尝试写出输出数据时可能停滞，因为存储空间已满。\n\n- “port”\n\n  该选项为必需，指明约束的目标。默认情况下，Vivado HLS 不对端口进行寄存。\n\n  <!--要指定块级 I/O 协议，请在 Vivado HLS GUI 中选择顶层函数，并指定函数返回的端口。-->\n\n- “offset”\n\n  该选项适用于 AXI4 接口，指明地址偏移量。\n\n要设置接口配置，请选择“Solution” → “Solution Settings” → “General” → “config_interface”。您可使用配置设置来执行如下操作：\n\n- 向 RTL 设计添加全局时钟使能。\n- 移除无关联的端口，例如，由设计中不使用的元素所创建的端口。\n- 为任意全局变量创建 RTL 端口。\n\n任何 C 语言函数均可使用全局变量：即定义的作用域超出任意函数作用域的变量。默认情况下，全局变量不会导致创建 RTL 端口：Vivado HLS 假定全局变量位于最终设计内。config_interface 配置设置 expose_global 会指示Vivado HLS 为全局变量创建端口。\n\n### 使用AXI接口\n\n这边就不展开说了，AMBA AXI可以单独写一篇文章来细说了。需要的同学可以自行去ARM官网查阅AXI的协议，并结合UG902查看各配置项的含义。\n\n## Interface Synthesis Reference\n\n此参考部分对每一种 Vivado HLS 接口模式进行了解释。\n\n### 块级I/O协议\n\nVivado HLS 使用接口类型 ap_ctrl_none、ap_ctrl_hs 和 ap_ctrl_chain 来指定是否使用块级握手信号实现RTL。块级握手信号可指定：\n\n- 设计何时开始执行操作\n- 操作何时终止\n- 设计何时处于空闲状态以及何时准备好处理新输入\n\n设计者可在函数上或函数返回时指定块级 I/O 协议。如果 C 语言代码不返回值，您仍可在函数返回时指定块级 I/O 协议。如果 C 语言代码使用函数返回，那么 Vivado HLS 会为返回值创建 ap_return 输出端口。\n\n在块级 I/O 协议中 ap_ctrl_hs (handshake) 为默认协议。下图显示了 Vivado HLS 对函数实现 ap_ctrl_hs 时生成的 RTL 端口和行为。在此示例中，函数使用 return 语句返回值，Vivado HLS 在 RTL 设计中创建 ap_return 输出端口。如果在 C 语言代码中不包含函数 return 语句，则不会创建此端口。\n\n![image-20230328175917838](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281759879.png)\n\nap_ctrl_chain 接口模式类似于 ap_ctrl_hs，但可提供额外的 ap_continue 输入信号以应用反压。赛灵思建议使用 ap_ctrl_chain 块级 I/O 协议将 Vivado HLS IP链接在一起。\n\n#### ap_ctrl_none\n\n如果指定 ap_ctrl_none 块级 I/O 协议，则不创建块级 I/O 协议中所示的握手信号端口（ap_start、ap_idle、ap_ready 和 ap_done）。如果在设计上不指定块级 I/O 协议，那么使用 C/RTL 协同仿真来验证 RTL 设计时，必须遵守接口综合要求中所述条件。\n\n#### ap_ctrl_hs\n\n下图显示了由 ap_ctrl_hs I/O 协议为非流水线化设计创建的块级握手信号的行为。\n\n![image-20230328180122623](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303281801678.png)\n\n复位后，将执行以下操作：\n\n1. 此模块会等待 ap_start 达到高电平，然后再开始操作。\n\n2. ap_idle 输出会立即变为低电平，以指示设计不再处于空闲状态。\n\n3. ap_start 信号必须保持处于高电平状态，直至 ap_ready 达到高电平状态。当 ap_ready 达到高电平状态后：\n\n   - 如果 ap_start 保持高电平，设计将启动下一项传输事务。\n   - 如果 ap_start 变为低电平，设计将完成当前传输事务，然后停止操作。\n\n4. 可读取输入端口上的数据。\n\n   <!--输入端口可使用独立于此块级 I/O 协议的端口级 I/O 协议。-->\n\n5. 可将数据写入输出端口。\n\n   <!--输出端口可使用独立于此块级 I/O 协议的端口级 I/O 协议。-->\n\n6. 当模块完成操作后，ap_done 输出会变为高电平状态。\n\n   <!--如果存在 ap_return 端口，那么当 ap_done 处于高电平状态时，此端口上的数据将变为有效。因此，ap_done 信号还用于指示 ap_return 输出上的数据有效。-->\n\n7. 当模块准备好接受新输入后，ap_ready 信号会变为高电平状态。以下是有关 ap_ready 信号的其它信息：\n\n   - ap_ready 信号处于不活动状态，直至模块开始操作为止。\n   - 在非流水线化设计中，ap_ready 信号与 ap_done 同时断言有效。\n   - 在流水线化设计中，当 ap_start 采样结果为高电平后，ap_ready 信号可能在任意周期变为高电平状态。这取决于设计流水线化的启动间隔。\n   - 如果 ap_start 信号为低电平状态，而 ap_ready 为高电平状态，那么设计将持续执行操作，直至 ap_done变为高电平状态后停止操作。\n   - 如果 ap_start 信号为高电平状态，且 ap_ready 为高电平状态，那么下一项传输事务将立即启动，且模块将继续操作。\n\n8. ap_idle 信号可用于指示设计何时处于空闲且不执行操作状态。以下是有关 ap_idle 信号的其它信息：\n\n   - 如果 ap_start 信号为低电平状态，而 ap_ready 为高电平状态，那么设计将停止操作，而 ap_idle 信号将在达成 ap_done 后，再经过 1 个周期后变为高电平状态。\n   - 如果 ap_start 信号为高电平状态，且 ap_ready 为高电平状态，那么设计将继续操作，且 ap_idle 信号保持处于低电平状态。\n\n#### ap_ctrl_chain\n\n下面介绍 ap_ctrl_chain 的接口协议。该块级 I/O 协议类似于 ap_ctrl_hs 协议，<u>但可提供 1 个额外输入端口</u>，名为 ap_continue。处于高电平有效状态的 ap_continue 信号，可指示使用输出数据的下游块已准备好处理新的数据输入。如果下游块无法使用新数据输入，那么 ap_continue 信号处于低电平状态，这将阻止上游块生成更多数据。\n\n下游块的 ap_ready 端口可直接驱动 ap_continue 端口。以下是有关 ap_continue 端口的其它信息：\n\n- 如果 ap_continue 信号为高电平状态，且 ap_done 为高电平状态，那么设计将继续操作。其它块级 I/O 信号的行为与 ap_ctrl_hs 块级 I/O 协议中描述的行为相同。\n- 如果 ap_continue 信号为低电平状态，而 ap_done 为高电平状态，那么设计将停止操作，ap_done 信号将保持高电平状态，并且如果存在 ap_return 端口，那么 ap_return 端口上的数据将保持有效。\n\n在下图中，第 1 项传输事务已完成，第 2 项传输事务立即启动，因为 ap_continue 为高电平状态，且 ap_done 为高电平状态。但设计在第 2 项传输事务结束后将暂停，直至 ap_continue 断言为高电平有效为止。\n\n![image-20230328221037464](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282210604.png)\n\n### 端口级I/O协议\n\n#### ap_none\n\nap_none 端口级 I/O 协议是最简单的接口类型，没有与之关联的其它信号。输入和输出数据信号都没有关联的控制端口以指示何时读取或写入数据。RTL 设计中仅有的端口是源代码中指定的端口。\n\nap_none 接口无需额外硬件开销。但是，ap_none 接口需满足以下条件：\n\n- 生产者模块执行以下操作之一：\n  - 在正确的时间向输入端口提供数据\n  - 在执行传输事务期间保留数据，直到设计完成\n- 使用者模块在正确的时间读取输出端口\n\n<!--ap_none 接口不能与数组实参一起使用。-->\n\n#### ap_stable\n\n与 ap_none 一样，ap_stable 端口级 I/O 协议不会向设计添加任何接口控制端口。<u>ap_stable 类型通常用于可更改但在正常操作期间保持稳定的数据</u>，例如提供配置数据的端口。ap_stable 类型向 Vivado HLS 发送下列通知：\n\n- 应用于端口的数据在正常操作期间应保持稳定，但不是可以被优化掉的常量值。\n- 此端口的扇出无需寄存。\n\n<!--ap_stable 类型只能应用于输入端口。当应用于输入输出 (inout) 端口时，仅端口的输入被视为稳定。-->\n\n#### ap_hs（ap_ack、ap_vld和ap_ovld）\n\nap_hs 端口级 I/O 协议在开发过程中提供了最大的灵活性，允许采用自下而上和自上而下的设计流程。双向握手可安全执行所有模块间通信，无需人为干预或假设即可正确执行。ap_hs 端口级 I/O 协议提供以下信号：\n\n- 数据端口\n- 用于指示何时使用数据的确认信号\n- 用于指示何时读取数据的 valid 信号\n\n下图显示了 ap_hs 接口对应输入和输出端口的行为。在此示例中，输入端口名为 in，输出端口名为 out。\n\n<!--控制信号名称基于原始端口名称。例如，用于数据输入 in 的 valid 端口名为 in_vld。-->\n\n![image-20230328222020173](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282220319.png)\n\n对于输入，将执行以下操作：\n\n- 应用 start 后，该模块开始正常操作。\n\n- 如果设计已准备好输入数据，但输入 valid 处于低电平状态，则设计将停滞并等待断言输入 valid 有效以指示存在新的输入值。\n\n  <!--上图显示了此行为。在此示例中，设计已准备好在时钟周期 4 上读取数据输入 in、停滞并等待输入valid，然后再读取数据。-->\n\n- 当输入 valid 断言为高电平有效 (High) 时，in_ack 将断言为高电平有效 (High)，表明已读取数据。\n\n对于输出，将执行以下操作：\n\n- 应用 start 后，该模块开始正常操作。\n- 写入输出端口时，将同时断言其关联的输出 valid 信号有效，以指示端口上存在 valid 数据。\n- 如果关联的 out_ack 为低电平，则设计将停滞并等待断言 out_ack 有效。\n- 当 out_ack 确认有效后，将在下一个时钟沿断言 out_valid 无效。\n\n#### ap_ack\n\nap_ack 端口级 I/O 协议是 ap_hs 接口类型的**子集**。ap_ack 端口级 I/O 协议提供以下信号：\n\n- 数据端口\n\n- 用于指示何时使用数据的ack信号（删去了ap_hs中的in_vld和out_vld信号，仅保留input和output端口的ack信号）\n\n  - 对于输入实参，设计会在读取输入的周期中生成高电平ack信号进行确认。\n\n  - 对于输出实参，Vivado HLS 会实现ack端口来确认已读取输出。\n\n    <!--写入操作之后，设计将停滞并等待，直到输入确认断言为高电平有效为止，这表明使用者块已读取输出。但是，不存在可用于指示何时可以使用数据的关联输出端口。-->\n\n#### ap_vld\n\nap_vld 是 ap_hs 接口类型的子集。ap_vld 端口级 I/O 协议提供以下信号：\n\n- 数据端口\n- 用于指示何时读取数据的 valid 信号（删去了ap_hs中的ack信号，仅保留vld信号）\n  - 对于输入实参，模块在 valid 端口有效后立即读取数据端口。即使模块尚未准备好读取新数据，也会对数据端口进行采样并在内部保留数据，直到需要时为止。\n  - 对于输出实参，Vivado HLS 会实现输出 valid 端口以指示输出端口上的数据何时为 valid。\n\n#### ap_ovld\n\nap_ovld 是 ap_hs 接口类型的子集。ap_ovld 端口级 I/O 协议提供以下信号：\n\n- 数据端口\n- 用于指示何时读取数据的 valid 信号\n  - 对于输入实参和inout类型参数中的输入部分，设计默认为 ap_none 类型。\n  - 对于输出实参和inout类型参数中的输出部分，设计实现 ap_vld 类型。\n\n#### ap_memory, bram\n\nap_memory 和 bram 接口端口级 I/O 协议用于<u>实现数组实参</u>。当实现要求随机访问内存地址位置时，这种类型的端口级 I/O 协议可以与内存元件（例如，RAM 和 ROM）通信。\n\n<!--如果只需顺序访问内存元件，请改用 ap_fifo 接口。ap_fifo 接口可以减少硬件开销，因为不执行地址生成。-->\n\nap_memory 和 bram 接口端口级 I/O 协议相同。唯一的区别是 Vivado IP integrator 显示模块的方式：\n\n- ap_memory 接口显示为离散端口。\n- bram 接口显示为单一端口（已组合）。在 IP integrator 中，可使用单一连接来创建到所有端口的连接。\n\n使用 ap_memory 接口时，请使用 RESOURCE 指令指定数组目标。如果没有为数组指定目标，则 Vivado HLS 会决定是使用单端口还是双端口 RAM 接口。\n\n<!--运行综合前，请使用 RESOURCE 指令确保将数组实参定向到正确的内存类型。使用更正后的内存进行重新综合可能会导致生成的 RTL 不同。-->\n\n下图显示了一个名为 d 的数组，该数组指定为单端口 BRAM。端口名称基于 C 语言函数实参。例如，如果 C 语言实参为 d，则根据 BRAM 的 output/q 端口，芯片使能为 d_ce，输入数据为 d_q0。\n\n![image-20230328230531655](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282305814.png)\n\n复位后，将执行以下操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n\n- 通过在断言输出信号 d_ce 有效的同时在输出地址端口上应用地址来执行读取。\n\n  <!--对于默认的 BRAM，设计期望在下一个时钟周期中，输入数据 d_q0 可用。您可以使用 RESOURCE 指令来指示 RAM 具有更长的读取时延。-->\n\n- 通过断言输出端口 d_ce 和 d_we 有效并同时应用地址和输出数据 d_d0 来执行写操作。\n\n#### ap_fifo\n\n写入输出端口时，当设计需要访问内存元件<u>并且访问始终以顺序方式执行时</u>，即不需要随机访问，则ap_fifo接口是最节省资源的方法。ap_fifo 端口级 I/O 协议支持以下操作：\n\n- 允许端口连接到 FIFO\n- 启用完整的双向 empty-full 通信\n- 适用于数组、指针和按引用传递实参类型\n\n在下图示例中，in1 是一个指针，该指针访问当前地址，然后访问当前地址上面的两个地址，最后访问下面的一个地址。\n\n```c\nvoid foo(int* in1, ...) {\n    int data1, data2, data3;\n    ...\n    data1= *in1;\n    data2= *(in1+2);\n    data3= *(in1-1);\n    ...\n}\n```\n\n如果将 in1 指定为 ap_fifo 接口，则 Vivado HLS 会检查访问、判定访问并非按顺序进行，随即发出错误消息并中止。要从非顺序地址读取，请使用 ap_memory 或 bram 接口。\n\n<u>不能在同时支持读取和写入的实参上指定 ap_fifo 接口</u>。您只能在输入或输出实参上指定 ap_fifo 接口。含输入实参 in 和输出实参 out（指定为 ap_fifo 接口）的设计的行为如下图所示。\n\n![image-20230328231130875](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282311023.png)\n\n对于输入，将执行以下操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n- 如果输入端口已准备好读取，但输入端口 in_empty_n 处于低电平状态，指示 FIFO 为空，则设计将停滞并等待数据可用。\n- 当输入端口 in_empty_n 处于高电平状态，指示 FIFO 包含数据时，将断言输出确认 in_read 为高电平有效以指示当前周期中已读取数据。\n\n对于输出，将执行以下操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n- 如果输出端口已准备好写入，但 out_full_n 处于低电平状态，指示 FIFO 已满，则数据将置于输出端口上，但设计将停滞并等待 FIFO 中的空间可用。\n- 当 out_full_n 处于高电平状态，指示 FIFO 中有可用空间时，将断言输出确认信号 out_write 有效以指示输出数据为 valid。\n\n- 如果顶层函数或顶层循环已使用 -rewind 选项进行流水线化，则 Vivado HLS 将创建另一个后缀为 lwr 的输出端口。当最后一次写入 FIFO 接口完成时，lwr 端口将变为高电平有效。\n\n#### ap_bus\n\nap_bus 接口可以与总线桥通信。由于 ap_bus 接口未遵循特定的总线标准，因此可将此接口用于与系统总线进行通信的总线桥。<u>总线桥必须能够对所有突发写入进行高速缓存。</u>\n\n设计者可以通过以下方式使用 ap_bus 接口：\n\n- 标准模式：此模式执行单独的读操作和写操作，并为每项操作指定地址。\n\n- 突发模式：如果在 C 语言源代码中使用了 C 语言函数 memcpy，则此模式将执行数据传输。在突发模式下，该接口指示基址和传输大小。然后以连续的周期传输数据样本。\n\n  <!--memcpy 函数访问的数组不能partitioned到寄存器中。-->\n\n以下示例显示了将 ap_bus 接口应用于实参 d 时，标准模式下的读写操作的行为。\n\n```c\nvoid foo (int *d) {\n    static int acc = 0;\n    int i;\n    for (i=0;i<4;i++) {\n        acc += d[i+1];\n        d[i] = acc;\n    }\n}\n```\n\n以下示例显示了使用 C memcpy 函数和突发模式时的行为。\n\n```c\nvoid bus (int *d) {\n    int buf1[4], buf2[4];\n    int i;\n    \n\tmemcpy(buf1,d,4*sizeof(int));\n    \n    for (i=0;i<4;i++) {\n    \tbuf2[i] += buf1[1+i];\n    }\n    \n\tmemcpy(d,buf2,4*sizeof(int));\n}\n```\n\nap_bus标准读取和写入的时序图如下所示：\n\n![image-20230328232306226](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282323381.png)\n\n对于ap_bus的标准读过程，在复位后将执行下列操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n\n- 如果执行读取时 d_rsp_empty_n 为低电平，指示总线桥 FIFO 中没有数据，则会执行以下操作：\n\n  - 断言输出端口 d_write_req 有效，并断言端口 r_req_in 无效，以指示读取操作。\n  - 输出地址。\n  - 设计停滞并等待数据可用。\n\n- 当数据可用于读取输出信号时，立即断言 d_rsp_read 有效并在下一个时钟沿读取数据。\n\n- 如果执行读取时 d_rsp_empty_n 为高电平，指示总线桥 FIFO 中有可用数据，则会执行以下操作：\n\n  - 断言输出端口 d_write_req 有效，并断言端口 r_req_in 无效，以指示读取操作。\n\n  - 输出地址。\n\n  - 在下一个时钟周期断言输出信号 d_rsp_read 有效，并在下一个时钟沿读取数据。\n\n    ![image-20230328232317782](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282323936.png)\n\n对于ap_bus的标准写过程，在复位后将执行下列操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n- 如果执行写入时 d_req_full_n 为低电平，指示总线桥 FIFO 中没有空间可用，则会执行以下操作：\n  - 输出地址和数据。\n  - 设计停滞并等待空间可用。\n- 当有空间可用于写入时，将执行以下操作：\n  - 断言输出端口 req_write 和 d_req_din 有效，以指示写操作。\n  - 立即断言输出信号 d_req_din 有效以指示该数据在下一个时钟沿有效。\n- 如果执行写入时d_req_full_n 为高电平，指示总线桥 FIFO 中有可用空间，则会执行以下操作：\n  - 断言输出端口 req_write 和 d_req_din 有效，以指示写操作。\n  - 输出地址和数据。\n  - 断言输出信号 d_req_din 有效以指示该数据在下一时钟沿有效。\n\nap_bus突发读取和写入的时序图如下所示：\n\n![image-20230328233347839](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282333994.png)\n\n对于ap_bus的突发读过程，在复位后将执行下列操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n- 如果执行读取时 d_rsp_empty_n 为低电平，指示总线桥 FIFO 中没有数据，则会执行以下操作：\n  - 断言输出端口 d_req_write 有效，并断言端口 d_req_din 无效，以指示读取操作。\n  - 输出传输的基地址和传输长度。\n  - 设计停滞并等待数据可用。\n- 当数据可用于读取输出信号时，立即断言 d_rsp_read 有效，并在接下来的 N 个时钟沿读取数据，其中 N 是d_size的值。\n- 如果总线桥 FIFO 的值已清空，数据传输将立即停止，并等待数据可用后再继续。\n\n![image-20230328233703018](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303282337164.png)\n\n对于ap_bus的突发写过程，在复位后将执行下列操作：\n\n- 断言 ap_start 后，该模块开始正常操作。\n- 如果执行写入时d_req_full_n 为低电平，指示总线桥 FIFO 中没有空间可用，则会执行以下操作：\n  - 输出基址、传输大小和数据。\n  - 设计停滞并等待空间可用。\n- 当有空间可用于写入时，将执行以下操作：\n  - 断言输出端口 d_req_write 和 d_req_din 有效，以指示写操作。\n  - 立即断言输出信号 d_req_din 有效以指示该数据在下一个时钟沿有效。\n  - 如果 FIFO 已满，则会立即断言输出信号 d_req_din 无效，并在空间可用时重新断言。\n  - 传输于完成 N 个数据值后停止，其中 N 是d_size的值。\n- 如果执行写入时 d_rsp_full_n 为高电平，指示总线桥 FIFO 中有可用空间，则传输开始，设计停滞并等待直到 FIFO 已满。\n\n#### axi_s\n\naxis 模式指定 AXI4-Stream I/O 协议。\n\n#### s_axilite\n\ns_axilite 模式指定 AXI4-Lite **从接口** I/O 协议。\n\n#### m_axi\n\nm_axi 模式指定 AXI4 **主接口** I/O 协议。\n\n## How to use HLS?\n\n这边本文不展开说了，本文主要目的是带大家熟悉HLS中基本的约束情况。工具的详细使用教程请大家参考官方例程文档[UG871](https://docs.xilinx.com/v/u/en-US/ug871-vivado-high-level-synthesis-tutorial)，跟着教程做完实验基本就可以熟悉HLS的设计、验证以及后续导出RTL设计的流程了，其中与结果分析相关的实验需要好好学习，在后续实际使用中遇到问题时才有调试的思路。\n\n## What's more?\n\n虽然我们思考问题尽量要从源头出发，但解决问题时如果有一些前人的成果可以参考的话那就再好不过了，本章简要介绍一下HLS中自带的各种算法库，其中有些笔者使用过，有些并没有用过。只能对着官方文档\"省流\"一波，更多细节的内容大家可以去UG902自行查阅。\n\n1、Arbitrary Precision Data Types Library：顾名思义，扩展了数据的类型。Then，Why？原生的基于C的数据类型都是字节对齐的，如8,16,32,64bits。但RTL的数据类型是支持任意宽度的，所以HLS需要设计一种机制来满足任意位宽的数据的声明，而不能像C语言一样有Byte对齐的要求。假设如果没有该库，我们需要用HLS实现一个17bit的乘法器，那么HLS会将其强制实现为32bit的乘法器。总而言之，该库可以让我们更高效地利用硬件资源，以bit为单位给数据设置位宽。\n\n2、HLS Stream Library：Stream是一种数据类型，Stream中的数据都是依序采样后发送，没有地址的概念，可以借助FIFO的概念来辅助理解。在C语言中对Stream类型的数据进行建模比较困难，C中一般是基于指针对数据进行存取，因此使用HLS Stream Lib对构建Stream数据类型的设计与仿真贡献较大。\n\n3、HLS Math Library：顾名思义，可以实现一些高效的数学运算，如指数、对数、三角、幂函数、取整、乘除、比较等等函数。\n\n4、其余的笔者目前没怎么用到过，还有HLS Video Library，HLS IP Libraries，HLS Linear Algebra Library，HLS DSP Library等，大家需要的话可以自行查阅原文档。\n\n## Reference\n\n> [UG902-Vivado Design Suite User Guide: High-Level Synthesis](https://docs.xilinx.com/v/u/en-US/ug902-vivado-high-level-synthesis)\n>\n> [UG871-Vivado Design Suite Tutorial: High-Level Synthesis](https://docs.xilinx.com/v/u/en-US/ug871-vivado-high-level-synthesis-tutorial)\n>\n> [UG1197-UltraFast Vivado HLS Methodology Guide](https://www.xilinx.com/content/dam/xilinx/support/documents/sw_manuals/ug1197-vivado-high-level-productivity.pdf)","tags":["FPGA_Tools"],"categories":["FPGA","FPGA_Tools"]},{"title":"低功耗设计简述","url":"/2023/03/24/IC/Basic/低功耗设计/","content":"\n# 低功耗设计\n\n芯片的整体功耗从根本上可以分为静态功耗和动态功耗；\n\n静态功耗，又称漏电流功耗，是器件特性，和晶体管的阈值电压及其自身特性有关；\n\n动态功耗，主要是芯片中的寄生RC电路的充放电引起的。换言之，当芯片中的电路出现任何信号翻转，都会产生动态功耗，其中所占最大比例的是时钟信号的翻转。\n\n动态功耗还可以分为翻转功耗和短路功耗。翻转功耗和电压、翻转率和负载电容有关，所以降翻转功耗的措施就是降压、降翻转率和减负载电容；\n\n短路功耗是指在晶体管翻转时，nMOS和pMOS会存在同时导通的情况，这时候产生的功耗称为短路功耗。\n\n现代SoC的功耗主要集中在：时钟树功耗(40%)、CPU、GPU、存储器等；\n功耗的整体计算公式为：\n\n$$P=(C{\\times}V^2{\\times}f)+(t{\\times}V{\\times}I{\\times}f)$$\n\n前面的部分是翻转功耗，后面的部分是短路功耗；\n\n## 静态低功耗技术\n\n**电源门控**是直接切断电源来减少漏电流；\n\n而**多阈值工艺**和**体偏置**则是通过改变CMOS管的阈值电压来减少静态功耗；\n\n### 电源门控\n\n指直接关掉某一不用模块的电源，这样可以直接关闭动态和静态功耗；\n\n局限：会引入额外的开销；模块的唤醒需要时间，功耗达到最终的power gating功耗(即使power gating仍然会有少量的漏电流)也需要时间。如果芯片一直在工作，则power gating的收益就有些小。总结而言就是需要考虑唤醒开销和power gating节省的功耗哪个大。\n\n实际做法：\n1、两个电源域，每个电源域引出单独的物理管脚，直接物理关断；适合长时间的关断；\n2、内部关断：在片上实现一个电源控制器，类似于一个开关，进行电压切换；\n\n为了关断power，我们可以把Vdd换成Vss，也可以将Vss换成Vdd。但一般情况下最好把Vdd换成Vss，因为多电源域一般共地，但Vdd各不相同。\n(注，Vdd中d=device，指器件的工作电压；Vss中s=series表示公共连接的意思，也就是公共接地端)\n\n需添加专用的隔离单元(isolation cell)，如特殊处理的与门(输出与隔离信号相与，输出低电平)，隔离单元处于源模块，但电源一般不关；或者需要给出主电源和备用电源，保证在power down的时候隔离单元还能继续工作；\n\n典型的门控电源的过程：\n1、关闭时钟；\n2、打开隔离信号；\n3、发出save脉冲，提示保存好相关寄存器；\n4、拉低rst_n；\n5、关闭电源；\n6、打开该电源域时，在复位信号拉高后发出恢复信号脉冲；\n\n对于门控电源，具体的实现是在后端，对于架构来讲需要分清楚有几个电压域，有几种低功耗模式；对于前端来讲，要搞清楚接口信号，同时需要实现一个控制器来断电和唤醒电源域，且加上隔离模块；\n\n### 多阈值工艺\n\n为了满足工作频率越来越高的要求，厂商逐渐降低晶体管的阈值电压Vt，使得晶体管能高速翻转；但是如果阈值电压Vt太低，则晶体管不能完全关断，这将产生很大的静态功耗；\n\n相关名词：\nHVT(High V threshold) 高电压阈值\nLVT (Low V threshold)  低电压阈值\nSVT(Standard V threshold) 标准电压阈值\n\n阈值电压与器件速度和泄露功率的关系：\n阈值电压↓ => 器件速度↑ 泄露功率↑\n阈值电压↑ => 器件速度↓ 泄露功率↓\n\n总结：在设计中可以在关键路径上使用低阈值的标准逻辑单元来优化时序；在非关键路径上使用高阈值标准逻辑单元来优化漏电流；\n\n优点：\n大大减少系统的静态功耗；\n没有任何面积开销，工艺库设计是将两种阈值库中的相应单元的面积设计成一样的，这样可以方便替换；\n\n### 体偏置\n\n对同一晶体管而言，阈值电压也会发生变化。晶体管的阈值电压随着CMOS管衬底的偏置电压变化而变化，而阈值电压影响我们的静态功耗，所以我们可以通过改变偏置电压来改变阈值电压。\n在工作模式下，MOS管的体偏置为0，MOS管处于低阈值状态，翻转速度快；\n在等待模式下，MOS管的体偏置为反向偏置，处于高阈值状态，漏电流小；\n\n注意：MOS管的体偏置需要时间，电路由等待模式转为工作模式的时间较长；\n\n## 动态低功耗技术\n\n### 多电压域\n\n动态功耗的主要组成部分—翻转功耗，是Vdd的平方，静态功耗中的主要组成部分漏电流和Vdd成正比，所以降功耗最有效的方法就是降电压。\n但降电压会增加延时，降低门单元的性能，所以很多低功耗技术就是在满足芯片性能要求的前提下，尽可能地降低芯片的工作电压Vdd。\n如果不同电压域之间的驱动信号与接收信号距离很远，则需插入特殊的驱动单元(Repenter)来增强信号的驱动能力；如果不同的电压域可以单独断电，则需要考虑添加保持寄存器和电压隔离单元；\n\n代价：\n需要变压器；因为你拿0.7v的电压域信号去驱动1.0v的电压域很容易导致1.0v的晶体管时时刻刻在漏电，且变压器会造成延时；\n时序分析不好做；\n布局时电源网络更加复杂；\n上电断电顺序可能是有要求的；\n对于架构设计者而言，主要就是搞清楚电压是影响时序的，确保不会因为多电源域影响系统功能就好；\n\n多电压域技术可以分为四种：\n静态多电压技术(MSV)，对不同的模块固定为不同的电压；\n动态电压频率缩放技术(DVFS)，对于该模块可以选择几种不同的电压配置，同时电压调整一般会同时调整频率，所以就称为动态电压频率缩放技术；\n自适应电压频率缩放技术(AVFS)，DVFS需要软件根据不同的应用场景选择不同的电压频率配置，如果更进一步，对改模块的电压频率能够自适应地调整，那么就是自适应电压频率缩放技术；\n电压关断技术(PSO)，如果某个模块在有些情况下不使用了，我们可以关掉这个模块的电压，需要的时候再打开，又称为电源门控，本质上是一种电压调节的特例；\n\n### 门控时钟\n\n直接停掉时钟，这样可以减少动态功耗。实际上在数字芯片中时钟网络占用了很大功耗，可能超过50%。\n\n举例说明门控时钟的概念：比如寄存器，当EN信号有效的时候才进行寄存，不如用EN信号将时钟信号进行屏蔽。\n注意！门控时钟虽然是很直接的办法，但一般来说不用自己RTL层面写门控时钟，工具会自动优化，自己写的门控时钟有可能产生毛刺影响性能；\n\n如果仅将时钟信号和时钟使能信号相与之后的输出作为模块的时钟输入，则可能存在毛刺；避免毛刺的方式有两种：\n采用锁存门控；若锁存器和与门相差很远，则延迟差别较大，仍可能存在毛刺；若时钟使能信号距离锁存器关断信号很近，可能会不满足锁存器的建立时间从而出现亚稳态；\n采用寄存门控；用寄存器来寄存EN信号再与上时钟信号得到门控时钟信号；此时需要寄存EN信号的寄存器满足建立时间要求；\n\n实际中看起来寄存结构的门控时钟问题要少，但在实际的SoC中，使用最多的还是锁存结构的门控时钟；\n最主要的原因是节省面积！一个DFF由两个锁存器组成，当大量的门控时钟插入到SoC芯片中时，这个节省的面积就相当可观了。\n当然，这里说的是SoC芯片中使用的标准库单元。如果是FPGA或者用RTL实现，个人认为还是使用寄存器门控+setup约束来实现比较稳妥；\n\n那在SoC中锁存门控的问题如何解决呢？在实际的SoC芯片中，要使用大量的门控时钟单元，所以通常会把门控时钟做成一个标准单元，由工艺厂商来提供。所以锁存器结构中线延时带来的问题就不存在了，因为是做成一个单元，线延时是可控和不变的，而且还可以通过挑选锁存器和增加延时，总是能满足锁存器的建立时间。这样通过工艺厂预先把门控时钟做成标准单元，这些问题都解决了。\n\n做门控时钟的时候需要注意以下两点：\n通常在位宽较大的寄存器上加时钟门控，因为加门控时钟本身也会增加面积和功耗，所以要综合考虑；\n加了门控时钟之后要保证原本的电路功能不变；\n\nTips：\nRTL编码中，将不用的数据设置成0并不能减少功耗，保持数据不变才能减少翻转，降低功耗。\n\n## RTL级低功耗技术\n\n对于前端RTL设计而言，**降低功耗无非两点**：\n对于寄存器，不工作的时候关闭时钟；\n对于组合逻辑，减少无效的跳变；\n\n设计中可以考虑的点：\n\n1. **状态机的编解码**：在各种状态机的编码中，格雷码是最适合低功耗设计的。因为它在状态转换过程中每次只有一个触发器变化，同时，格雷码编码的状态机也消除了依赖于状态组合等式中存在毛刺的风险；\n2. **门控时钟**：编码方式   if（~rst_n） else if（en_load）；\n3. **独热码多路器**：将多输入MUX采用独热码编码方式，可以综合为与门和或门，降低功耗；\n4. **操作数隔离**，操作数隔离就是增加一些选择器件，如果这个操作数不需要的话就不选择它以及不进行这个操作数所需要的相应计算。在sel信号之前通过将sel和数据信号相与可以降低mux前端信号的翻转率；\n5. **资源共享**，将相同的处理使用组合逻辑预先产生，在调用的时候直接调用，不需要把相同的操作复制；\n6. **总线翻转编码**，在当前数据和下一个数据之间的汉明距离（汉明距离指的是两个数中不相同位的数量）大于N/2的时，将下一个数据取反后再传输，以减少总线上出现转换的位数量，即总线反转编码；该技术的缺点是需要传输一个额外的控制位，用以表征总线数据是否进行了翻转编码，消耗了系统总线的带宽；\n\n当模块在某段时间完全不工作的时候，你可以：1、在这段时间里关掉这个模块的时钟；2、检查这个模块的输入，对于还在跳变的输入，将其全部固定为恒定值，这样才能根除这个模块的动态功耗；\n\n## 门级优化技术\n\n个人感觉节省的功耗比较鸡肋，仅做了解即可；\n\n### 毛刺的消除\n\n毛刺指由于电路中信号的传输延迟引起的不必要的翻转；通过插入缓冲器改变信号的传输延迟从而消除信号的毛刺；\n\n### 逻辑级优化\n\n引脚的重分配：对同一个门而言，有可能各Pin的功耗不一致，我们将变化率低的信号连接到低功耗的Pin上就有好处。用负载电容低的引脚去连接快速翻转的信号，降低系统的动态功耗；\n重排序操作：通过对门级电路的重排序，使得其驱动的门数量降低，从而降低系统的动态功耗；\n\n### 物理级优化\n\n使用低功耗的库；\n使用低功耗的布局规划；\n通过布局布线来减少毛刺；\n在优化布局的时候调整缓冲器和连线的大小；\n调整晶体管的大小减少负载电容；\n\n### 控制输入向量\n\n系统在睡眠状态下，控制输入向量可以明显减少系统的漏电流。（选择最小漏电流的向量作为组合逻辑的输入）\n\n# 以反相器为例解释静态/动态功耗\n\n反相器的结构如下图所示，由一个PMOS和一个NMOS串联而成，负载电容记为$C_L$。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241657743.png)\n\n## 动态功耗\n\n### 电容充放电引起的动态功耗\n\n当$C_L$通过PMOS充电时，$V_{C_L}$从0V上升至$V_{DD}$，电路从电源$V_{DD}$上抽取一定的能量，一部分消耗在PMOS上，另一部分被电容$C_L$存储。$V_{out}$由高至低进行电平翻转时，$C_L$通过NMOS放电，之前存储在$C_L$中的能量被NMOS消耗。\n\n下面计算$V_{out}$由低至高电平翻转的过程从电源上抽走的能量，假设$V_{in}$的电平上升和下降时间为零，即NMOS和PMOS不可能同时导通，此时CMOS反相器可以等效为下图所示的电路。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241704535.png)\n\n$i_{VDD}$和$V_{out}$是随时间变化的，可以看做是时间的函数，在0—dt时间范围内从电源上抽取的能量微元为：\n\n$$dE_{VDD}=i_{VDD}V_{DD}dt$$\n\n理论上$C_L$充电至$V_{DD}$所用的时间为无穷大，因此$C_L$充电过程中从电源上抽取的总能量为：\n$$\nE_{VDD}=\\int_{0}^{\\infty}i_{VDD}(t)V_{DD}\\,dt=V_{DD}\\int_{0}^{\\infty}C_L\\frac{d_{V_{out}(t)}}{dt}\\,dt=C_LV_{DD}\\int_{0}^{\\infty}\\,dV_{out}=C_LV_{DD}^2\n$$\n电容$C_L$在0—dt时间范围内存储的能量微元为：\n$$\nd_{E_C}=i_{VDD}(t)V_{out}(t)dt\n$$\n电容$C_L$充电至$V_{DD}$存储的能量为：\n$$\nE_C=\\int_{0}^{\\infty}i_{VDD}(t)V_{out}(t)\\,dt=\\int_{0}^{\\infty}V_{out}(t)C_L\\frac{dV_{out}}{dt}\\,dt=C_L\\int_{0}^{V_{DD}}V_{out}\\,dV_{out}=\\frac{1}{2}C_LV_{DD}^2\n$$\n由$E_{VDD}$和$E_{C}$可以看出，电容$C_L$充电期间从电源抽取的能量只有一半存储到$C_L$中了，另一半被PMOS消耗，而存储到电容$C_L$中的这一半能量将在电容放电期间被NMOS消耗掉，也就是说CMOS反相器每经过一次开关周期（“0”→“1”→“0”）所消耗的能量为$C_LV_{DD}^2$，如果一个反相器每秒开关f次，则功耗为：\n$$\nP_{dyn}=\\frac{E_{VDD}}{T}=C_LV_{DD}^2f\n$$\n其中，T为开关周期，f为开关频率。\n\n### NMOS和PMOS同时导通（过渡区）引起的功耗\n\n前面假假设了输入波形的上升、下降时间为零，这是个理想状态，实际上$V_{in}$的上升、下降时间不可能为零，当CMOS反相器处于两个管子同时导通的过渡区时，电源对地有一条直流通路，如下图所示：\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241728158.png)\n\n当直流脉冲可近似看做三角形以及输入电平上升与下降时间相等时，每经过一个开关周期（“0” →“1” →“0”）所消耗的能量为：\n$$\nE_{dp}=E_{dpr}+E_{dpf}\n$$\n$E_{dpr}$即$V_{in}$电平上升期间的直流通路能耗，通过上图(b)可以发现，$0{\\sim}{\\frac{t_{sc}}{2}}$这段时间的瞬时电流$i(t)=2\\frac{I_{peak}}{t_{sc}}t$，在$\\frac{t_{sc}}{2}{\\sim}t_{sc}$的这段时间瞬时电流$i(t)=-2\\frac{I_{peak}}{t_{sc}}t$，$V_{in}$从低至高电平转换期间的能耗为：\n$$\nE_{dpr}=\\int_{0}^{t_{sc}}i(t)V_{DD}\\,dt=2\\int_{0}^{\\frac{t_{sc}}{2}}i(t)V_{DD}\\,dt=4V_{DD}\\frac{I_{peak}}{t_{sc}}\\int_{0}^{\\frac{t_{sc}}{2}}t\\,dt=\\frac{1}{2}V_{DD}I_{peak}t_{sc}\n$$\n同理可得$V_{in}$从高至低电平转换期间的能耗为：\n$$\nE_{dpf}=\\frac{1}{2}V_{DD}I_{peak}t_{sc}\n$$\n由此可知电路在过渡区的总能耗为：\n$$\nE_{dp}=E_{dpr}+E_{dpf}=V_{DD}I_{peak}t_{sc}\n$$\n所以$V_{in}$一个周期内的平均功耗为：\n$$\nP_{dp}=\\frac{E_{dp}}{T}=E_{dp}f=V_{DD}I_{peak}t_{sc}f=C_{sc}V_{DD}^2f\n$$\n从平均功耗的表达式可以看出过渡区的动态功耗是一个类电容功耗，$C_{sc}$为过渡区的等效电容，$t_{sc}$为过渡区时长，f为$V_{in}$的电平跳变频率。\n\n## 静态功耗\n\n理想情况下，CMOS反相器在稳态工作时PMOS与NMOS不会同时导通，这就意味着稳态时电源与地之间没有通路，不会形成通路电流，静态功耗为零，可实际电路里总有一些微弱的泄漏电流$I_{stat}$流过源或漏与衬底之间的反偏二极管，如下图所示，此时的静态功耗为：\n$$\nP_{stat}=V_{DD}I_{stat}\n$$\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303242223033.png)\n\n## 总功耗\n\n显然，CMOS反相器的总功耗可以表示成三个部分的和，即:\n$$\nP_{total}=P_{dyn}+P_{dp}+P_{stat}=(C_LV_{DD}^2+V_{DD}I_{peak}t_{sc})f+V_{DD}I_{stat}\n$$\n最主要的功耗是等效电容的充放电造成的$P_{dyn}$，过渡区的功耗$P_{dp}$可以通过调整过渡区宽度控制在限定范围内，静态功耗目前可忽略。\n\n> Reference\n>\n> Jan M. Rabaey, Anantha Chandrakasan, Borivoje Nikolic, 2004. Digital Integrated Circuits :A Design Perspective ,Second Edition.\n","tags":["Basics"],"categories":["IC","Basics"]},{"title":"FPGA与ASIC的区别","url":"/2023/03/24/IC/Basic/FPGA与ASIC的区别/","content":"\n# FPGA与ASIC的区别\n\n- **测试逻辑**：ASIC要考虑SCAN测试和BIST的问题；（DFT：Design For Test）\n\n- **存储资源**：一般而言，ASIC设计中使用的memory是SRAM与Flop/Latch Array，前端工程师可以根据不同的存储规模选择合适的类型；而FPGA中memory的种类较多且资源受限，一般有Distributed RAM/Block RAM/Ultra RAM等，FPGA设计者一般会在微架构设计中根据存储规模更细致地考虑好各memory使用的资源类型；\n\n- **计算资源**：ASIC设计的计算资源主要采用**synopsys designware**、其他vendor或者自主设计的IP；而FPGA设计则主要使用片上的**DSP单元**，DSP单元在FPGA上是hardwired，时序比较好，但功能相对也比较固定，所以FPGA设计者一般会充分DSP单元中固定位宽的乘法器与加法器。在ASIC设计中，累加一般采用加法树设计，而FPGA中则更倾向于使用级联设计，这样可以利用DSP单元间专用的进位布线资源，提高设计的时序；\n\n- **逻辑资源**：ASIC设计中的逻辑资源是标准单元库中的logic cell，而FPGA设计中的逻辑资源是CLB中的LUT（4/5/6输入LUT，具体看FPGA型号）与MUX。**这里就体现了ASIC和FPGA一个最大区别**：估算逻辑深度的方法不同：FPGA没有逻辑深度，就是一个查找表，查找表的深度仅和输入信号的数目有关；而ASIC是有逻辑深度的，在RTL Coding的时候，需要预估逻辑综合出来的级数，哪怕输入信号不多，但逻辑复杂度大的话，也需要拆成2拍；\n\n- **低功耗设计**：ASIC的低功耗设计可以采用clock gating与power gating，但FPGA无法做到power gating，clock信号在FPGA中有专用的布线资源，因此也不建议使用clock gating的方式，但可以用clock enable的方式替代；\n\n- **时钟复位**：clock信号在FPGA中有专用的布线资源，而ASIC内的时钟为了更小的skew会专门进行CTS；ASIC设计中一般使用异步复位，由后端负责处理复位树，FPGA设计中则建议使用同步复位；\n\n## FPGA与ASIC在代码层面的区别\n\n- ASIC更趋于保守，对逻辑的任何改动都要三思，并要做备选的选择，以防改错，RTL的任何修改几乎都是增量修改；\n\n- ASIC对coding style的要求更高，所有模块的coding风格要求一致，这样有利于后端以及后续的check；\n\n- ASIC要考虑SCAN测试和BIST的问题，所以设计的时候需要为SRAM做BIST插入，需要为SCAN预留接口；虽然大部分都是工具干的，但是RTL作者也需要手动做一些顶层工作，比如SCAN时钟的来源等逻辑；\n\n- ASIC时序预见性更好，可调整度高，所以可以写很大的逻辑；\n\n  **关键词：保守改动、代码风格、测试逻辑、逻辑级数**","tags":["Basics"],"categories":["IC","Basics"]},{"title":"芯片设计流程简述","url":"/2023/03/24/IC/Basic/芯片设计流程简述/","content":"\n# 芯片设计流程简述\n\n### 1、需求分析\n\n分析用户或市场的需求，并将其翻译成对芯片产品的技术要求；\n\n### 2、算法/架构设计\n\n- 算法设计：设计和优化芯片中所使用的算法；这一阶段一般使用高级编程语言(如C、C++)，利用算法级建模和仿真工具(如MATLAB)进行浮点和定点的仿真，进而对算法进行评估和优化；\n- 架构设计：根据设计的功能需求和算法分析的结果，设计芯片的架构，并对不同的方案进行比较，选择性能价格最优的方案。这一阶段可以用SystemC语言对芯片架构进行模拟和分析；\n\n### 3、RTL设计\n\n使用HDL语言(Verilog、VHDL)完成对设计实体的RTL级描述。\n\n### 4、RTL验证(功能仿真/前仿)\n\n使用仿真工具或者其他RTL代码分析工具，验证RTL代码的质量和性能；\n\n### 5、综合\n\n从RTL代码生成描述实际电路的门级网表文件；\n\n### 6、门级验证(后仿)\n\n对综合产生的门级网表进行验证，这一阶段通常会使用仿真、静态时序分析和形式验证等工具；\n\n### 7、布局布线\n\n后端对综合产生的门级网表进行布局规划(FloorPlanning)、布局(Placement)、布线(Routing)，生成生产用的版图；\n\n### 8、电路参数提取\n\n确定芯片中互连线的寄生参数，从而获得门级的延时信息；用于更准确地后仿以及静态时序分析；\n\n### 9、版图后验证\n\n根据后端设计后取得的新的延时信息，再次验证设计能否可以实现所有的功能、是否达到所有的性能指标；\n\n### 10、芯片生产\n\n在特定的芯片工艺线上制造出芯片；\n\n### 11、芯片测试\n\n对制造好的芯片进行测试，检测生产中产生的缺陷和问题；","tags":["Basics"],"categories":["IC","Basics"]},{"title":"修Timing Violation的若干方法","url":"/2023/03/23/IC/Basic/修Timing Violation的若干方法/","content":"\n> 本文转载自[探STA|修timing violation的二十一种方法](https://mp.weixin.qq.com/s/DCMRXW-bF8Z7r7SPnRC5jQ)\n>\n> 如有任何版权问题请联系博主。\n\n其实修setup violation和hold violation是对立统一的，例如我们通过insert buffer修一个setup violation，那么有时我们也可以通过remove buffer修一个hold violation。\n\n# Fix setup violation\n\nSetup violation的本质是一个时钟周期内上一级寄存器锁存的数据无法正确地传输到下一级寄存器并被正确地锁存，也就是数据跑的太慢了。或者换个思路，是当前寄存器的时钟跑的快了。\n\n插buffer来fix setup violation主要从信号的slew考虑，减buffer来fix setup violation主要从cell delay的角度考虑。选择何种方式主要看load capacitance。\n\n首先看一下slew的解释，以及与cell delay的相关参数。\n\n> A slew rate is defined as a rate of change.\n>\n> \n>\n> A simple timing model is a linear delay model, where the delay and the output transition time of the cell are represented as linear functions of the two parameters: input transition time and the output load capacitance.\n>\n> \n>\n> —《Static timing analysis for nanometer designs》\n\n下面两个评论是从插buffer的角度考虑\n\n> Buffers increases drive strength of signal and so delay decreases. This is like a repeater in a communication systems .  where repeater will re-shape the signal to match it to ideal one and thus time taken by signal to transition from 1->0 and 0->1 decreases.\n\n> If you insert the buffer, the signal strength will be improved. This will charge the load Cap fast. When the Cap gets charged fast, you will have less rise & fall delay. This will reduce the delay. That's it.\n\n下面的评论是从减buffer的角度考虑\n\n> Decrese the load Cap. can decrease the cell delay. until the load Cap, is much smaller than the output Cap, of the cell itself, the delay will nearly not change at all. We can call the delay instrinsic delay.\n> If a timing path consists of cells with instrinsic delay, insert buffer will just increase the delay.\n\n## 减少Data Path上的Buffer数量\n\n这会减少cell delay。cell级数减少了，这种减小也不是单纯地几何倍数的减小，减小的程度应该是**小于**remove buffer的数量×原来的cell delay；因为net wire变长之后，电流从net一端传播到net另一端衰减更加严重，对器件的充电速度变慢。\n\n但是该方式会增加net delay，net wire总长度变大，RC参数变大，RC曲线更加绵长。\n\n## 使用一对inverter替换Buffer\n\n我们知道buffer的结构基本上等价于两个inverter，使用一对inverter替换buffer可以减少data path上总的delay。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241516536.png)\n\n和只用一个buffer相比，一对反相器会两倍的减少信号的transition time，这会减少RC delay。而一个buffer的cell delay约等于一对inverter的cell delay，所以总的delay减少了。\n\n## Swap VT\n\n这就是换cell的阈值电压(voltage threshold)，就是把HVT(High)换成SVT/RVT(Standard/Regular)或者LVT(Low)。\n\n相同情况下low VT的cell的栅极阈值电压更低，所以对于该cell本身其slew更小；相同情况下low VT的cell的栅极导通电流更大，所以其对于后续的net wire的充电速度更快。\n\n所以low VT的cell相当于从cell delay和net delay两种角度去减小了总的delay。\n\n不过，Low VT的cell静态电流更大，静态功耗也更大。\n\n## Size-up cell\n\n一般来说大驱动的cell具有更高的speed，但是可能某些cell类型，更大的cell可能速度更慢。\n\n不过，这样也会使得power更高，area更大。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241522391.png)\n\n## Insert buffer\n\n插buffer会减小transition time，这会减小net delay。如果总的net delay的减小 大于 cell delay的增加；那么总的delay就会减小。\n\n不过，这也会导致power和area增加。\n\n## Insert repeater\n\n这跟insert buffer类似，不过区别在于场景的不同。\n\nLong net wire会导致大的RC delay，如果insert repeater可以将net wire切分成多段可以减少总的net delay；因为总的net delay的减少 大于 cell delay的增加，所以这是一种有效的方法。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241525219.png)\n\n## 调整cell在版图的location\n\n本质也是减少net delay.\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241527977.png)\n\n## 调整clock skew\n\n就是通过skew的调整向后一级接setup的余量。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241531184.png)\n\n## 给critial path用NDR走线\n\n与CTS绕线原理类似，就是减少net wire的RC和cross-talk。\n\nNDR全称是Non default routing rule，非默认绕线规则。默认的绕线规则都是单位宽度，对于clock path或者critial path可以采取双倍宽度的绕线宽度。\n\n## 手动走线\n\n手动换高层走线或者手动把net wire捋直。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241552917.jpg)\n\n直观感受一下，上图中橘色的为金属，高层的走线粗，电阻小，所以RC小，delay小。\n\n## 修crosstalk\n\n修crosstalk除了加shielding和NDR rule以外，还有一种方法是：违例点周围的各种走线remove掉或者拉的远一点。\n\n## 降频\n\n如果实在修不下去，该降就降吧。\n\n## 换库\n\n实在不行，也可以选用一些speed更快的库，或者自己定做一些库。\n\n该方法也分全局换库和局部换库，全局就是整个design都换，局部就是让critical path用一些特殊的库。\n\n## 调整floorplan\n\n通过调整floorplan使得具有交互的module的位置更合理。\n\n## split multi-bit flip-flop\n\n因为MBFF cell内部的**公共**走线和**公共**的晶体管更多，所以其本身的load Cap更大，则transition time就更大，delay就更大。因此可以通过拆分MBFF Cell来fix setup violation。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241557552.png)\n\n## 使用PBA代替GBA\n\nGBA 的全称是（Graph Base Analysis）。STA工具计算 timing 时，默认是采用 GBA 模式来报 timing 的，是工具默认的分析方式。它是说工具在从lib中读取cell的delay的时候，永远是读取**由最差transition产生的delay**。PBA是path based analysis，指的是我要分析哪条timing path，就用这条timing path的transition来查cell的delay。pba算法复杂，分析时间大大提高，但结果更为精确。\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241558706.png)\n\n## 打拍\n\n打拍就是在reg2reg path中间再加一个reg，一个周期搞不定的事情，分成两个周期来做。\n\n## 改RTL\n\n如果RTL综合出来本身的timing path逻辑级数太长或者组合逻辑太多，可以考虑改RTL。\n\n# Fix Hold violation\n\n## Add Delay\n\n可以使用buffer、inverter pairs、delay cell来修hold violation。\n\n由于hold violation path的start point和end point可能对应着别的setup violation path（或者setup slack比较紧张），所以add delay时需要格外小心。\n\n此外，一般不在两条timing path的common path增加delay。\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303241604159.png)\n\n## Size-down cell\n\n尽可能去size end-point附近的cell，这样对别的path影响较小。\n\n另外修crosstalk和手动走线也可修hold。\n\n# 题外话\n\n有时候面试官会问，流片完了还是有setup/hold violation怎么办，可以从以下角度去考虑回答。\n\nFix setup violation：降频使用；\n\nFix hold violation：在setup margin比较足的情况下可以降压，不足的情况下可以降频降压使用；","tags":["Basics"],"categories":["IC","Basics"]},{"title":"Physical aware synthesis是什么","url":"/2022/11/04/IC/Basic/Physical Synthesis是什么/","content":"\n> 本文转载自[论综合：为什么做physical aware synthesis](https://mp.weixin.qq.com/s/wX1rPgGrn4IwHfXc-f_e9Q)\n>\n> 如有任何版权问题请联系博主。\n\n## 前言\n\n工艺的更新给整个半导体行业带来了巨大的挑战，从生产设备、EDA再到芯片设计实现都需要紧跟更新的工艺点亮新技能。下图直观地呈现了从65nm到16/14nm由工艺进步引入的需要额外考虑的因素。\n\n![phsy](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202211032356068.jpg)\n\n在芯片设计实现流程中，P&R工程师对工艺带来的挑战感受会更直接，综合、STA、DFT 也都有新的方法学的更新，但大都被 EDA 工具严实地包了起来，就拿综合来说，相对于传统综合而言最大的更新莫过于physical aware synthesis。\n\n## 为什么？\n\n最根本的目的就是减少前后端的迭代次数，前后端迭代次数多的根本原因是前后端的关联度(correlation)差，而correlation需要从timing 和 congestion 两个方面来看：\n\n### Timing\n\n综合优化的对象是 timing path，而 Timing path delay = net delay + cell delay，90nm之前 timing path delay 由cell delay 主导，而进入65nm，net delay所占比例日渐增加，进入40nm之后几乎跟cell delay平分秋色。所以从40nm开始physical synthesis 被硅农熟知，因为physical aware synthesis在优化过程中可以看到更精确的net delay。\n\n![preview](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092022883.jpeg)\n\n**那么为什么logical synthesis不能精确计算net delay呢？**这就要回看一下传统综合是如何估算 net delay 的。传统综合俗称logic synthesis，它根据WLM 来估算net delay。WLM (wire load model) 由foundry 提供，WLM通常包括面积系数、电容系数和单位长度的电阻系数，以及一个用于估计net长度的表格，表的index是 fanout，直白地说就是将net的长度拟合成fanout 的函数。\n\n按照WLM来计算，下图中的blue器件到red器件的所有net长度都一样，net delay也一样，而实际上 net 行走的姿势五花八门，根本就不可能一样，缺点显而易见。另一个缺陷是WLM 的单位电容电阻是一个常值，无法模拟不同layer RC 值的差异，而工艺进入16nm 之后，必须要考虑 layer aware 的 net delay。\n\n![preview](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092025068.jpeg)\n\n在40nm甚至28nm，依然有人在用传统的方式来做综合，做法简单粗暴加时钟周期30%甚至更多的过约，这样做是可以cover net delay，但是实在是过犹不及。据统计在一颗芯片里80%以上的线都是短线，为了cover那不到20%的线，付出的代价就是更大的面积及更多的功耗。\n\n**那Physical synthesis是如何更精确的计算net delay？**要精确计算net delay必须要知道net的行走姿势，而要知道net 的行走姿势必需要知道：它来自哪里？要去向何方？这就需要知道cell 的位置，cell 位置确定了之后，综合工具会做global 绕线，根据global 绕线的结果来估算net delay。cell 位置由placement 确定，所以如今综合工具都集成了 placement 引擎，这也是做 physical synthesis 的关键所在。目前大概有两种做place的方式：\n\n- 做完优化跟mapping之后，再做place，操作对象是std cell；\n- 在elaborate 之后优化之初就做place, 即所谓的 early physical, 早期阶段针对module 做palce，mapping之后再以std cell为对象做place；\n\n下图是谷歌上随便找的一张图，只为显示什么是module place,  从Layout 上看每一个颜色对应一个 module。综合工具基本都按 translation + optimization + mapping 三大步来走， 所有结构的选择跟大部分优化的动作都在 optimization 这一步完成，如果可以在 optimization 时就知道 module 的位置信息，优化会更有的放矢会更能『精准打击』，所以 Early physical 十分必要。现在看到的趋势是把更多的物理信息拿到前端来，越早考虑物理信息得到的结果会越好。\n\n![preview](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092031003.jpeg)\n\n结论：physial synthesis根据真实的物理信息，用跟P&R一致的 place 引擎跟 global route 引擎，可以精确估算 net delay，并且是layer aware的。通常physical synthesis 只需过约时钟周期5%\\~10%即可，用于cover legalization跟detail route 的影响。\n\n### Congestion\n\n同样由于工艺进步，集成度提高，单位面积上要走的线骤增，所以 congestion 成了一个从RTL 设计就要开始关注的问题，否则到了绕线的时候绕不通，前面所做的一切都成了无用功。很显然，logical 综合是无法考虑 congestion 的，要在综合阶段做congestion优化必须要 physical synthesis.\n\n![preview](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210092033144.jpeg)\n\n其实不论PPA还是congestion主导决定权都在进实现之前，**架构算法设计**，才是真正决定一切的『权贵』，所以才说实现是个没有灵魂的工种，只要按着 设计/EDA/foundry 定的规则往下走就可以，切忌的就是『发挥』。\n\n对于congestion，综合工具能做的基本只有两件事：选结构跟推cell。至于选结构，一个例子就是把一个大MUX 拆成多级MUX用于解congestion。推cell这一点完全依赖于EDA 工具，如果你不知道如何做，那就找AE要变量或 option 让工具在综合做place时将 congestion 严重区域的cell推散。除此之外，还有一点可以人为干预，禁用或让工具少用size 小的复杂cell。\n\n要特别说明一点，在16nm之后，layer的影响特别大，所以综合用的DEF一定要有special net 部分，也就是你的power plan，让工具在综合时清楚地知道哪些layer的绕线资源已经被占用。\n\n## Reference\n\n[What is Physical Synthesis_IBM](https://cse.unl.edu/~seth/990/Pubs/What%20is%20physical%20synthesis.pdf)\n\n[What is Physical Synthesis?_synopsys](https://www.synopsys.com/glossary/what-is-physical-synthesis.html)\n","tags":["Basics"],"categories":["IC","Basics"]},{"title":"RTL Coding Style","url":"/2022/10/10/IC/Basic/RTL Coding Style/","content":"\n# RTL Coding Style\n\n## 标准的文件头\n\n在每一个版块的开头一定要使用统一的文件头，其中包括作者名，模块名，创建日期，概要，更改记录，版权等必要信息。\n\n建议使用以下的文件头\n\n```verilog\n// **************************************************************\n// COPYRIGHT(c) XDU ImgLab\n// All rights reserved.\n//\n// Module name  :  Module_name of this file just as “tx_fifo”\n// Full name    :  Full English name of this abbreviation\n//\n// Author       :  Athor/ID \n// Email        :  Author’s email\n// Abstract     :  Describe the function of the module briefly \n// Character Set:  GB-2312\n//\n// Modification history\n// ------------------------------------------------------------------------------------------------------\n// Date       By        Version       Change Description            \n// ----------------------------------------------------------------- \n// 22/10/10   David     v0.1          first try \n// *********************************************************************\n\n```\n\n## 标准的module格式\n\n对于模块的书写采用统一的格式便于项目内部成员的理解和维护，其内容解释如下：\n\n- 端口声明时，定义顺序以功能区分，不以方向区分。时钟和复位信号端口必须定义在其他信号之前。\n- 端口定义必须采用ANSI风格（在模块端口位置完全声明端口名称、类型和方向）\n- 模块名、模块例化名统一，例化名前加小写u_以区分 （ 多次例化另加标识 ），三者关系：\n  - 文件名 ：xxx .v  (小写)\n  - 模块名 ：xxx      (小写)\n  - 例化名 ：u_xxx\n- 例化模块时，每行只例化一个端口，且不能使用表达式，所有输入端口都必须有驱动，未使用的输出接口必须例化，但可以不连接。\n- 消除顶层模块的胶连逻辑（集成各功能单元的`top.v`位置），各功能单元的`top.v`中允许存在合理的胶连逻辑。\n\n## 一致的排版\n\n### 一致的缩排\n\n- 统一的缩排取4个空格宽度（注意尽量别使用TAB键缩进，不同的IDE对TAB缩进的解释可能不同）\n\n- 输入输出信号的宽度定义与关键字之间，信号名与宽度之间要用空格分开；所有宽度定义对所有信号名对齐，代码风格统一如下：\n\n  ```verilog\n  input   [3:0]    input_a   ;    // *****\n  input            input_b   ;    // *****\n         …\n  output  [127:0]  output_a ;\n  output  [15:0]   output_b ;\n  output           output_c ;\n  ```\n\n### 一致的begin  end书写方式\n\nalways中，一定要用begin end区分，格式和代码风格统一如下：\n\n```verilog\nalways @ (postedge clk or negedge rst_n) begin\n    if (rst_n == 1'b0)\n        syn_rst<= 1'b0;\n    else begin\n        if (a == b)\n            syn_rst<= 1'b1;\n        else\n            syn_rst<= 1'b0;\n    end\nend\n```\n\nif else中仅有一个语句行时，不要使用begin end；如果有多个语句行时，注意缩进四个空格。\n\n## 一致的信号命名风格\n\n|    全称     |   缩写   |      中文含义      |\n| :---------: | :------: | :----------------: |\n| acknowledge |   ack    |        应答        |\n|   address   | addr(ad) |        地址        |\n|   arbiter   |   arb    |        仲裁        |\n|    check    |   chk    |  校验，如CRC校验   |\n|    clock    |   clk    |        时钟        |\n|   config    |   cfg    |      配置信息      |\n|   control   |   ctrl   |        控制        |\n|    count    |   cnt    |        计数        |\n|  data  in   | din(di)  |      数据输入      |\n|  data  out  | dout(do) |      数据输出      |\n|   decode    |    de    |        译码        |\n|  decrease   |   dec    |        减一        |\n|    delay    |   dly    |        延迟        |\n|   disable   |   dis    |       不使能       |\n|    error    |   err    |    错误（指示）    |\n|   enable    |    en    |        使能        |\n|    frame    |   frm    |         帧         |\n|  generate   |   gen    |  生成，如CRC生成   |\n|    grant    |   gnt    |      申请通过      |\n|  increase   |   inc    |        加一        |\n|    input    |  in(i)   |      输入信号      |\n|   length    |   len    |    （帧、包）长    |\n|   output    |  out(o)  |      输出信号      |\n|  priority   |   pri    |       优先级       |\n|   pointer   |   ptr    |        指针        |\n| rd  enable  |   ren    |       读使能       |\n|    read     |    rd    |     读（操作）     |\n|    ready    |   rdy    |  应答信号或准备好  |\n|   receive   |    rx    |   （帧数据）接收   |\n|   request   |   req    | （服务、仲裁）请求 |\n|    reset    |   rst    |      复位信号      |\n|    souce    |   scr    |     源（端口）     |\n| ststistics  |   stat   |        统计        |\n|    timer    |   tmr    |       定时器       |\n|  temporary  |   tmp    |        临时        |\n|  transmit   |    tx    | 发送（帧数据）相关 |\n|    valid    |  vld(v)  |   有效、校验正确   |\n|  wr enable  |   wen    |       写使能       |\n|    write    |    wr    |       写操作       |\n\n1. 端口、信号、变量名的所有字母小写；函数名、宏定义、参数定义用大写；\n2. 使用简称、缩略词（加上列表）；\n3. 基于含义命名（避免以数字命名的简单做法），含义可分段（最多分三段），每一小段之间加下划线”_”，如tx_data_val；命名长度一般限制在20个字符以内；\n4. 低电平有效信号，加后缀”_n”，如 rst_n；\n5. 无条件寄存的寄存信号在原信号上加dly1、dly2… 如原信号 data_in，寄存一拍data_in_dly1，寄存两拍data_in_dly2；\n6. **不能用 ”reg”作为最后的后缀名**，因为综合工具会给寄存器自动加上reg后缀, 如果命名里就用reg作为后缀名则扰乱了网表的可读性。\n\n## 统一的表达式书写\n\n### 括号的使用\n\n如果一个表达式的分组情况不是很明显时，加上括号有助于理解。\n\n例如下面的代码加上括号就清晰很多。\n\n`if (&a==1’b1&&!flag==1’b1||b==1’b1)`\n\n改为：\n\n`if ((&a==1’b1)&&(!flag==1’b1)||(b==1’b1))`\n\n### 适当的使用空格\n\n一般表达式在运算符的两侧要各留出一个空格，但定义比较长的表达式，去掉优先级高的运算符前的空格，使其与运算对象紧连在一起，可以更清晰的显示表达式结构。\n\n还是上面的例子\n\n`if ((&a==1’b1)&&(!flag==1’b1)||(b==1’b1))`\n\n改为\n\n`if ( (&a==1’b1) && (!flag==1’b1) || (b==1’b1) )`\n\n**”<=”, ”=”,运算符前后都要加空格。**\n\n### 赋值要指明比特宽度\n\n**赋值或者条件判断时要注明比特宽度，注意表达式的位宽匹配。**如：\n\nreg [4:0] signal_a;\n\n错误情况：  \n\n```verilog\nsignal_a <= 5;\n\nif(signal_a == 5)\n\nsignal_a <= signal_b[3:0]+4;\n```\n\n正确情况：\n\n```verilog\nsignal_a <= 5'd5;\n\nif(signal_a == 5'd5)\n\nsignal_a <= {1'b0, signal_b[3:0]+5'd4;\n```\n\n因为工具默认是32位宽，如果不注明位宽，工具检查会报warning，而且这样增加了设计的严谨性。\n\n（tips：参数化代码设计中可直接加上不指定位宽的常数）\n\n### 书写规范\n\n每行只写一条语句，便于后续验证中行覆盖率的检查。\n\n## 统一的语句书写―条件判断结构书写方式\n\n### 条件的完整性\n\nif else搭配使用，对于缺省的条件要写”else；”；\n\nif else的条件判别式要全面，比如\"if(a == 1’b0)\";\n\ncase中的缺省条件要写”default”；\n\n### ”if else”结构：适用于复杂条件判断的语句\n\n对于复杂的条件判断，使用\" ? : \"如果不仔细分析条件的每一条路径，就让读代码的人搞不清它是到底要做什么。例如：\n\n`C = (!Ic&&!rc)?1'b0:(Ic?rc:Ic);`\n\n改为：\n\n```verilog\nalways @(Ic or rc) begin    //if else\n    if ( (Ic==0) && (rc==0) )\n        c = 1'b0;\n    else if (Ic==1)\n        c = rc;\n    else\n        c = Ic;\nend\n```\n\n简单的条件判断，我们可以使用三目符；当涉及复杂的条件判断，使用IF-ELSE结构以获得清晰的结构便于理解和维护。\n\n### IF-ELSE结构 VS CASE结构\n\n- IF-ELSE综合的结果可能是与或非门，也可能是一组多路选择器；而CASE综合结果一般会是多路选择器，但对于可以优化的CASE综合工具会综合出更简单的结构。\n\n- 所有对于可以写出平行结构的条件，优先写成case结构，例如地址译码等。条件之间有重复和嵌套的情况则是写成IF-ELSE结构。\n\n### Finite State Machine\n\n- 不允许有模糊不清的状态机模式，所有的状态机必须清晰明了。\n\n- 要求将状态机的时序部分和组合逻辑部分分开，建议采用三段式结构。\n- 状态机的状态名必须使用参数编码，并以“ST_”做前缀命名，状态信号必须用fsm\\_<cs/ns/ls>命名。（注：cs为current state，ns为next state，ls为last state）\n\n## 统一格式的always程序块的书写\n\n### always 中的变量的赋值方式―阻塞与非阻塞赋值\n\n当进行时序逻辑建模时，always块中使用非阻塞赋值，“<=”；\n\n参考如下代码：\n\n```verilog\nalways @(posedge clk or negedge rst_n) begin \n    if (rst_n == 1'b0)\n        myreg <= 1'b0;\n    else\n        myreg <= 1'b1;\nend\n```\n\n当进行组合逻辑建模时，always块中使用阻塞赋值，“=”；\n\n```verilog\nalways @(addr) begin\n    case (addr)\n        2'b00 : cs0_n = 1'b0;\n        2'b01 : cs0_n = 1'b1;\n        2'b10 : cs0_n = 1'b0;\n        2'b11 : cs0_n = 1'b1;\n        default: cs0_n = 1'b1;\n    endcase\nend\n```\n\n### always中变量赋值的唯一性\n\n组合always块一定要注意敏感量列表中的触发项完整且不冗余；如果不是这样，综合的电路会与实际设计不符合，会报warning；这边建议使用`always @(*)`的写法描述组合always块。\n\n不要再多个always模块中对同一个reg型变量进行赋值；\n\n建议不要在一个always块里给多个变量赋值。如果将一组条件相同的变量写在一个always块中更有利于可读性的提高和功能的实现时候，可有例外情况，但请尽量多加注释，以增加可读性，并注意在组合always块中不要出现LATCH；\n\n### always复位的书写\n\n异步复位和同步复位模块内要统一，异步复位的条件表达式及命名要和always敏感列表中的描述相统一，所有的复位有效电平必须统一。\n\n## 合理的注释\n\n- 代码中建议采用英文作详细的注释；\n- 注释应该与代码一致，修改程序的时候一定要修改相应的注释；\n- 注释不应重复代码已经表明的内容，而是简明地点明程序的突出特征；\n- 注释应该提取程序的线索和关键词，它整合程序中分散的信息并它帮助理解程序中不能表明的部分。\n- 注释中可以加入TODO、FIXME等标签来提示代码中的待办事项；\n\n## 重用化设计\n\n### 层次结构与模块划分\n\n- 层次设计的原理以简单为主―尽量避免不必要的层次；层次结构设计得好，在综合中就不需要太多的优化过程；\n- 模块的划分根据层次设计来决定―模块化对于布线有很大帮助，模块化的设计中要尽量减少全局信号的使用；\n- 通用的部分尽量提取出来作为一个共用模块；\n\n### 参数传递\n\n- 需要传递参数的模块，在多次例化的时候统一都传递参数，不要例化同一个模块，有的传参数，有的不传。\n- 大模块间信号加前缀：“模块A缩写”_“模块B缩写”表示模块A到模块B的信号。\n\n### 模块划分的技巧\n\n- 将不同的时钟域分离开来；\n- 按照不同的设计目标划分成块，分块时应在数据流方向上进行切分；\n- 在同一模块中实现逻辑资源和算术资源的共享；","tags":["Basics"],"categories":["IC","Basics"]},{"title":"FPGA输入输出信号的IOB约束方式","url":"/2022/10/09/FPGA/FPGA输入输出信号的IOB约束方式/","content":"\n## 前言\n\n笔者在做实验室FPGA项目时，遇到输入输出信号相关的约束问题。在请教老师后，总结以下内容，供以后遇到类似问题时翻阅。\n\n对于FPGA的输入信号，我们要以异步信号来看待，输入信号进来先打拍，使用打拍后的数据。第一次打拍的FF要约束到IOB中的IFF中，第二个FF就可以放到Slice中，这样每次布局布线不会因为FF的位置不同导致时序出问题，且解决了输入信号的异步问题；\n\n对于FPGA的输出信号，我们也要打拍输出，确保扇出为1，将其放到IOB中的OFF中。这样OFF到PAD的路径延迟固定，每次布局布线不会因为FF位置不同导致时序出问题。\n\n对于inout信号，当该信号作为输入信号时，我们需要对其打两拍进行使用；当需要向总线上放数据时，需注意要用三态的方式放置数据`assign inout_data = sel ? dout : 'bz;`，且要保证sel信号是reg类型。\n\n## 问题描述\n\n输入信号没有使用IOB约束，在ISE的IOB Properties中未见输入信号部署到IFF中。\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091732502.png)\n\n\n\n## 尝试步骤\n\n在ISE工具的Implement的property选项中，对-pr选项要选择For Inputs and Outputs选项；\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091735357.png)\n\n修复跟输入相关的模块，对输入信号要做打拍处理，使用打拍后的数据进行内部的逻辑运算；\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091736236.png)\n\n### 修改Implement的选项报错\n\n修复后在Map阶段报错，报错具体位置在8b10b解码IP：\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091737591.png)\n\n打开8b10b的IP网表进行分析：\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091737650.png)\n\n其中rx为输入的多光谱数据线，**猜测为8b10b的IP网表中对ff_c0和ff_d1有布局上的约束，ff_c0和ff_d1需要pack在一起，而如果使用输入IOB的话，ff_c0需要布局在IOB中，而ff_d1无法布局在IOB中，导致报错。**\n\n所以解决方案中不能使用Implement的property。\n\n### Inout信号的处理方式\n\n要改变总线上的数据时，使用三态控制；\n\n`assign   cpu_data       = (rd_latchn == 1'b0) ? cpu_rdata_mux : 16'bz;`\n\n要使用总线上的数据时，直接打拍总线上的数据（cpu_data）使用；\n\n增加上述约束后，查看ISE报告，cpu_data仍然是OFF，输入信号没有约束到IFF上。\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091738262.png)\n\n## 解决方案\n\n### 对于输入信号\n\n对于输入信号而言，进来先打两拍，第一拍的数据别用，用第二拍的数据。\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091738401.png)\n\n如果在ISE的Implement选项里可以选择`For Input and Outputs`的选项的话，那后续可以不用管了，注意该选项是针对全局的设计的。如果像上文这种有个lvds接口无法放置到IOB中的话，需要考虑以下的做法。\n\n1、使用Verilog的attribute语法\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091739313.png)\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091739332.png)\n\n```verilog\n(* IOB = \"TRUE\" *) reg [8:0] cpu_data_d1;\n```\n\n2、在UCF文件里添加约束\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091741530.png)\n\nISE工具默认会把接口上的数据放置到IOB内。如果默认的放置方式没有起作用的话，我们这里采用的是第二种做法。\n\n### 对于输出信号\n\n**保证扇出为1**，在ISE的Implement选项中设置-pr选项，使用I/O Register；或者使用verilog中attribute的方式或是UCF文件中添加约束的方式；\n\n### 对于inout信号\n\n把inout信号当输入使用时，注意打两拍再使用；\n\n把inout信号当输出时，注意采用三态写法，且sel信号需要是reg类型；\n\n`assign   cpu_data       = (rd_latchn == 1'b0) ? cpu_rdata_mux : 16'bz;`\n\n对于inout信号，最好在UCF文件中显式的对io信号做IOB的约束；\n\n```tcl\nINST \"u_cpu_top/cpu_data_d1*\" IOB=FORCE;\n```\n\nps：PR之后的信号名可以到ISE中的FPGA Editor去查询。 \n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091743114.png)\n\n## 结果\n\ninput、output、inout信号均正确约束到IOB中。\n\n![img](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210091743675.png)\n\n## Reference\n\n[UG625](https://www.xilinx.com/content/dam/xilinx/support/documents/sw_manuals/xilinx14_7/cgd.pdf)\n","tags":["FPGA_Tools"],"categories":["FPGA","FPGA_Tools"]},{"title":"为什么需要门级仿真","url":"/2022/10/07/IC/Basic/为什么需要门级仿真/","content":"\n## 背景\n\n当时面试百度昆仑芯的时候，面试官问我这样一个场景。各Corner下的Timing已经Clean了，Formality已经保证RTL和门电路保持一致了，为什么要需要去做GLS（Gate Level Simulation）呢？\n\n当时问的一下愣住，没想明白，下来搜集资料发现以下几点原因。其中部分原因自己也还不能理解到位，期待后续实际工作中加深理解。\n\n## 原因\n\n![GLS](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071537119.jpg)\n\n1. 解决STA工具的局限性，如STA工具无法分析异步接口信号，STA工具也会放宽对False Path和Multi-cycle Path的检查，用GLS来复查一下；\n2. 核实一下系统初始化是否正常进行，复位链是否正确；\n3. 验证所有电源域的上电和复位操作是否符合要求，并且检查设计不依赖于设计的初始条件；\n4. 利用最坏和最佳的时序信息的组合来揭示边缘敏感信号上的Glitch情况；\n5. 执行DFT验证，因为扫描链是在RTL综合后插入的；\n6. 验证时钟树综合（CTS）是否满足要求；（Skew、Jitter等）\n7. 获取翻转率参数来更准确地估计功耗；\n8. 在RTL或者GLS中以悲观/乐观来分析X态；（不太理解）\n9. 检查最终的性能以确保设计工作在所需的频率，路径上实际的延迟需考虑在内，包括部分结构元素不被STA或者Formality检查，或者在PR阶段在路径上插入的Buffer或者其他的电路元素。","tags":["Basics"],"categories":["IC","Basics"]},{"title":"Blog图像加载失败解决方法","url":"/2022/10/07/Misc/Blog图像加载失败解决方法/","content":"\n## 背景\n\n如果你没有用科学上网方式的话，可能本博客中部分内容的图像是看不了的，因为后期我文章中的图像托管到了Github仓库里。此时需要根据系统配置一下DNS来进行图像的查看，找了部分资料链接放在下面，个人比较推荐修改DNS的方式，快捷简单。以后访问Github时也比较方便。\n\n## 参考资料\n\n[Github访问速度慢,图片无法加载的解决方法](https://zhuanlan.zhihu.com/p/368689473)\n\n[修改Hosts解决Github访问失败](https://zhuanlan.zhihu.com/p/107334179)","tags":["Misc"],"categories":["Misc"]},{"title":"摄影入门知识","url":"/2022/10/07/Misc/摄影入门知识/","content":"\n# 摄影入门知识\n\n## 曝光三要素\n\n### 三个参数\n\n光圈大小、快门速度、ISO大小\n\n- 光圈大小：同时能进多少光\n- 快门速度：遮光板**打开和关闭**一次的时长，速度越慢遮光板打开时间越久，进光越多\n- ISO：理解为额外增加的小手电，强行添加额外亮度（电子信号），会增加颗粒感\n\n### 参数对应的数值说明\n\n- 光圈数值，与大小相反，F1.8为大光圈，F22为小光圈，以此类推...\n- 快门速度，单位为秒（16，1/2，1/8000 秒等），数值越小，遮光板打开时间越短，进光越少；\n- iso 数值  （100，800，1600等），数值越大，额外强行补光越多，颗粒感越重\n\n### 亮暗环境下的调整步骤\n\n- 暗环境下：1、首先调大光圈；2、其次减慢快门；3、最后还不行再调大iso；优先级逐渐降低；\n- 亮环境下：1、调低ISO；2、加快快门；3、最后还不行再调小光圈；\n\n## 光圈和快门对照片的其他影响\n\n### 光圈大小影响亮度、景深、虚化\n\n- 景深：从镜头发散出去，只有一部分区域的景象是清晰的，其他的会模糊。**清晰的区域，就叫做景深。**大光圈，浅景深，清晰的区域小，背景会模糊；小光圈，深景深，清晰的区域大，背景也清晰；\n- 虚化：光圈越大，背景虚化越强（与景深联系起来，大光圈，浅景深，背景模糊→背景虚化）；光圈越小，背景虚化越弱；\n  - 虚化强弱的理解：一盏小灯在大光圈下，灯会虚化成大光斑；小光圈，灯虚化成的光斑也小；（光斑的形状来源于光圈扇叶形成的圆洞，**假如用卡纸剪出心形置于镜头前，光斑也成心形**）；\n  - 虚化的不止背景，还有前景；可应用前景虚化，拍摄梦幻感的照片。\n  - 景深与对焦的理解：对焦，就是让清晰的区域（景深）与拍摄主体有重合。因此，**小光圈易于对焦运动中的主体**。\n\n### 快门速度影响亮度，动态模糊\n\n- 慢快门时，假如相机抖动，将导致光在CMOS上有运动轨迹，进而导致照片糊掉；\n- 自动挡时，使用大光圈，增大ISO，或者用闪光灯或补光灯照亮主体，可以尽可能避免相机使用慢快门，进而避免拍摄时，相机抖动导致照片糊掉；\n- 慢速快门拍摄技巧，可用于拍摄光绘，星轨，车流，火花；可使用三脚架保持相机稳定，防止糊掉\n\n### 在强光下如何虚化+动态模糊？\n\n虚化就需要光圈调大->浅景深->背景模糊，动态模糊需要慢快门->让光在CMOS上运动，那么就会导致进光量太多的问题，本质上是矛盾的。\n\n这时我们引入ND滤镜（控光工具），可理解为相机用墨镜🕶可以降低画面亮度，有可变和固定参数两种。\n\n## 相机档位\n\n### 定义\n\n相机档位本质上是用来控制光圈、ISO和快门速度的，只不过不同的档位下你能把握的变量不同；\n\n- M：自由控制所有参数；\n- A/AV：只能控制光圈参数，其它参数相机自适应（用途：（画面有大光圈虚化）人、微距、特写。条件：光线、亮度足够好。）\n- S/TV：只能控制快门速度，其他参数相机自适应。（用途：1、慢速快门；2、快速抓拍：打鸟、小孩、速度快的物体/事件；）\n- P：定向自适应模式，相机通过你的修改参数来自动调整其它参数。例如：光圈（你），ISO，快门速度（相机）；相机会通过你的自变量（x=光圈/快门速度），来调整另一个参数（快门速度/光圈），前提：ISO为auto 。\n\n### 曝光补偿\n\n程序算法，根据你的选择，调整三要素数值，改变画面亮度；\n\n在不同的档位模式下，曝光补偿能改变的参数不同；\n\n![曝光补偿说明](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210031850425.png)\n\n### 图像直方图\n\n|     画面     |   方向   |\n| :----------: | :------: |\n|      暗      |   偏左   |\n|      亮      |   偏右   |\n|   正常曝光   | 均匀平铺 |\n| 没有过渡部分 | 分散两边 |\n\n如果场景敏感比例不平衡的话，直方图不能直观的显示，就要做取舍，注意拍摄主题的质量；\n\n## 白平衡\n\n当我们拍摄低色温环境如3500k（偏蓝），白平衡k值设置要高如7000k（偏黄），两者综合才能还原物体原来颜色，这就是白平衡的用处。\n\n简单来说就是：白平衡设置低k值，相机会认为外部环境偏黄，所以加蓝；设置高k值，相机会认为外部环境偏蓝，所以加红。傍晚拍摄照片时用3500k，没什么问题，如果想要拍摄绚丽黄昏，高k值也是不错的选择，这取决于最终想怎么表现一张图想表达的情绪。\n\n## 测光\n\n主要调整对象：光圈快门ISO、曝光补偿、测光模式\n\n亮度太高/亮度不足：看直方图判断、曝光补偿小管家（在M档位下）（看+/-数值）；\n\n测光模式：评价/多重测光（拍人像）、中央测光（对象在画面中央，跟拍vlog）、点测光（对象一直在画面某个位置，如会议记录）；\n\n固定测光的亮度：亮度锁（*）、Sony（ael）；\n\n## 景深\n\n- 景深通俗的来说就是画面中前后清晰的范围，但对焦并不等于移动景深，而是移动焦点。\n\n- 同时景深也并不只是一个简单的范围，而是由三个部分组成：大概示意图：\n\n  🎥  <         (   前景深｜焦点|       后景深 )\n\n- 为什么要把景深分为三个部分？\n\n  景深范围内并不是所有东西都同样清晰！\n\n  从物理理论上来说，只有焦点上的物体才是“绝对”清晰的 而前景深与后景深只是“相对清晰”（轻微模糊，但人眼分辨不出） 这似乎都是清晰 但假如在一些需要放大几倍的特殊情况下 这个问题就会显现：比如在拍摄人像的时候，对焦到鼻尖 。好像眼睛和鼻尖都在景深内，但放大后眼睛是可能会感觉到轻微模糊的。\n\n  所以盲目把对焦理解为“只要落在这个范围里”是非常危险的！！！正确方法应该是将最主要的物体（例如人像的眼睛）放在焦点上，而至于其他区域（例如耳朵、鼻子等）如果想要清晰的话，再通过调整光圈或焦距的方法改变景深大小来实现清晰！\n\n- 拍照时先定焦点，再去构图；\n","tags":["photography"],"categories":["Misc","photography"]},{"title":"我的秋招小结","url":"/2022/09/30/Interview/秋招小结/","content":"\n# 背景介绍\n\n2022年，不知道是不是未来十年最好的一年，不过应该是过去十年最差的一年。听完任总的“寒气论”和字节梁总的“去肥增瘦”理论后，每个2023的应届生应该都能感受到这刺骨的寒意。\n\n我的秋招经历开始较早，6月陆续开始投递各公司的提前批，7-8月份为面试高峰期，9月陆续收到各家的offer。文章的后面我会大概回忆各面试的问题，梳理校招时面试官关心的共性问题，仅供大家参考，准备后续的秋招笔试面试。\n\n本文整理的一些知识点后续会慢慢在自己的博客更新（给自己挖了一波大坑），希望后面慢慢填上；\n\n# 项目相关\n\n- 准备项目的简要系统架构介绍。可以包括以下要素：项目框图、各模块功能介绍、系统接口、时钟复位网络；可以用Xmind或者MarkDown工具去梳理项目架构。\n- 提取项目的亮点、难点。部分面试时间不够的话面试官不会给充足的时间详尽介绍项目，可以从时序约束、算法设计、优化方式、计算性能等方向去整理；\n- 项目中涉及到的点要拓展延伸，了解相关的基础知识。举例说明，我的项目接口信号使用了8b10b编码方式，自己可以考虑如下几点：1、8b10b编码是什么？2、为什么需要8b10b编码，该编码是用来解决什么问题的？3、有其他方式可以解决该问题吗？要带入面试官的角度去思考自己的项目；\n- 总结在做项目过程中遇到的棘手问题，在给面试官叙述自己解决问题的思路和方式的过程中展现自己的能力。\n- 项目的验证方式；了解项目涉及的IC/FPGA的工艺，面积；\n- 统计项目中自己负责部分的代码量；\n\n# 基础知识\n\n## 跨时钟域\n\n- 基本的CMOS、PMOS结构；\n- 跨时钟域的原因，亚稳态的定义；\n- 建立时间、保持时间；\n- 单bit信号跨时钟域，考虑快慢时钟域；\n- 多bit信号跨时钟域；\n  - 异步FIFO的假空假满；\n  - 格雷码跨时钟域问题；\n  - 如何考虑FIFO深度；\n  - FIFO和DMUX的相关时序约束；\n- 何时需要跨时钟，跨时钟方式如何选择；\n- 关于复位信号的跨时钟域；\n- Time Borrow/Steal（进阶）\n\n## 低功耗设计\n\n- 功耗的分类、影响因素、计算公式\n- 静态低功耗技术，降静态功耗的方法；\n- 动态低功耗技术，降动态功耗的方法；\n- RTL设计中降功耗的方式；\n- 以反相器为例解释静态功耗和动态功耗；\n\n## 时序约束\n\n- 时钟相关\n  - 周期、占空比、管脚；\n  - Primary Clock、Virtual Clock、Generated Clock、Clock Groups；\n  - Clock Latency、Jitter、Uncertainty；\n- IO Delay\n  - Input Delay；\n  - Output Delay；\n- Time Exceptions\n  - Multicycle；\n  - False Path；\n  - Max/Min Delay；\n\n## IC相关\n\n- 简述IC设计流程，了解各步骤的目的；\n- IC和FPGA的区别；\n- 修Time Violation的方式；\n\n## AMBA协议\n\n- 读写架构，信号列表及含义；\n- 跨4K问题；\n- 握手间的依赖关系；\n- 能否提前结束突发传输；\n- 窄位宽数据传输、非对齐传输、混合大小端传输；\n- Outstanding的含义，如何考虑Outstanding深度；\n\n- Out of Order的含义，跟ID信号是否有联系；\n- Interconnect的结构；\n- AXI3、AXI4的区别；\n- AXI Full、AXI Lite的区别；\n- AXI的死锁场景；\n\n# 笔试\n\n- 状态机相关：红绿灯、自动售货机、序列检测；\n- 分频相关：奇偶分频、半整数分频、小数分频；\n- 仲裁相关：优先级仲裁、固定优先级仲裁、变优先级仲裁、轮询仲裁、加权轮询；\n- 存储：单口RAM、简单双口RAM、真双口RAM；\n- CDC\n  - 同步FIFO：基于单口RAM、基于双口RAM；\n  - 异步FIFO：Bin2Gray、Gray2Bin；\n  - 脉冲同步器、带反馈的脉冲同步器；\n  - 前向/后向Pipe；\n- 门级电路：计数器、全加器、二/三分频、占空比1:3的二分频；\n- 其它：Generate、For语法相关；","tags":["interview"],"categories":["interview"]},{"title":"跨复位域小结","url":"/2022/09/29/Interview/跨复位域小结/","content":"\n# 跨复位域小结\n\n跨时钟域我们比较熟悉，但跨复位域可能就比较陌生了。在平头哥实习的一面中，面试官问了我较多跨复位域的问题，主要还是自己在简历里挖了个坑（就不该写设计复位网络的TAT），所以这篇文章就来简要介绍一下跨复位域中存在的一些问题及解决方法。\n\n## 异步复位导致的亚稳态\n\n### 异步复位的释放\n\n复位如果在时钟采样沿的前后的一个时间窗口内释放的话会导致输出的Q端存在亚稳态问题，**本质上也是触发器建立时间和保持时间的要求**，对复位而言就是Recovery Time和Removal Time的要求。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121969.png)\n\n为解决异步复位释放的亚稳态问题，我们可以使用异步复位，同步释放的方式来解决。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121355.png)\n\n### 异步复位的置位\n\n复位的置位也可能导致亚稳态问题，主要场景是电路中有多复位域，我们分析一下下图所示场景。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121206.png)\n\ndff1和dff2分别使用不同的时钟和复位信号，dff1先复位，之后dff2再复位。可能存在的问题是arst1置位时，**dff1的Q端数据从data向Reset-value跳变时可能不满足dff2的建立/保持时间要求**，从而使dff2的Q端出现亚稳态。\n\n以下关于时钟复位的5种情形**都可能导致亚稳态**：\n\n1、clk1和clk2是一样的/同步的；\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232121776.png)\n\n2、clk1和clk2是异步的；\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122669.png)\n\n3/4、对arst1和arst2均做异步复位，同步释放操作；\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122118.png)\n\n5、rst2做同步复位；\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122155.png)\n\n## 如何安全地处理跨复位域\n\n既然跨异步复位域容易出问题，这里给出3种RDC相关信号的设计方法。\n\n首先，我们要识别哪些信号穿越Reset Domain，处理这些信号的大原则如下：\n\n**一个Reset Domain复位后，RDC信号不能产生翻转，至少不能被另一个复位域采到。**\n\n从上面的原则我们可知，跨复位域的控制信号最好是**脉冲**而非电平信号，因为电平信号更容易触发RDC的X态传播。\n\n主要解决方法有以下几种：\n\n### 1、人工确认RDC信号复位时不翻转（不推荐）\n\n如果我们能确认RDC信号不翻转，自然不会带来亚稳态。\n\n但这个方法基本不建议使用，因为**很难分析RDC信号复位时是否翻转。**\n\n举例来说，假如生成RDC信号的是组合逻辑，如下图。\n\n![rdc1](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/rdc1.png)\n\n这种情况下RST0复位了，DFF1和DFF2复位时间可能不相同，显然会给DFF3造成亚稳态。\n\n那么是否信号由寄存器输出就高枕无忧了？\n\n显然不是，我们看下图这种情况\n\n![rdc2](https://raw.githubusercontent.com/XduDavid/Blog_Img/main/rdc2.png)\n\n如果实际电路中，DFF3收到的RST0信号比DFF1和DFF2晚，**DFF3恰好在采值的过程中被复位了**，A点还是亚稳态。\n\n此处我们想一个问题，如果一个处于RST0复位域的异步FIFO为空，如果复位的话会对空/满信号造成毛刺吗？\n\n直观上我们觉得不会，因为FIFO都空了凭什么不让复位。但是注意跨异步复位域的条件，**RDC信号不发生翻转**。FIFO为空，只能说明读/写指针相等，但他俩不一定为零。\n\n如果把上图中的DFF1当做读指针，DFF2当做写指针，DFF3当做空/满信号，我们就会发现，复位的时候，异步FIFO的空满信号可能会发生跳变。\n\n上面的内容体现了保证RDC信号在reset的时候不发生跳变是一件很难的事。建议还是以下面的方式保证RDC信号的正确性。\n\n### 2、对复位的顺序提出要求（不推荐）\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122904.png)\n\narst2在arst1之前置位的话，就不存在dff2的亚稳态问题，**这种先复位后级模块的策略可以有效避免亚稳态。**\n\n但在实际模块设计中，这个很难做到保证。\n\n### 3、增加数据隔离单元（推荐，需要加钳位寄存器）\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122542.png)\n\n在dff1的arst1置位前隔离dff1的输出，将输出钳位到0，避免arst1置位时导致dff2出现亚稳态；\n\nIsolation enable实际上就是一个钳位寄存器，复位流程要进行修改：\n\n- 先配置钳位寄存器为0\n- 拉低arst1\n- 然后配置钳位寄存器为1\n\n该方法需要注意的是，**钳位寄存器需要单独复位**。不要错误的将钳位寄存器的复位端连到arst1。\n\n### 4、通过时钟门控进行数据隔离（推荐，需要dest domain支持CG）\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232122095.png)\n\n该方法值得推荐，但需要dest domain能单独关闭时钟。与数据隔离单元的思想类似，只不过通过门控dff2的方式来完成数据隔离。\n\n我把DFF2在arst1复位的时候提前关掉，自然复位导致的不稳定信号就不能传递过来了。\n\n一般来讲这种方法是可行的。因为既然单独复位，**arst2复位域一般会留出强制关钟的寄存器配置信号**。\n\n但这种方法需要在EDA上进行验证，DFF2在工作状态突然关闭时钟，会不会造成其它功能错误。\n\n如果可行，我们要在arst1复位流程中加入clk2关钟流程，等arst1复位信号生效后再开dff2的时钟。\n\n## 小结\n\n安全处理跨复位域的做法：\n\n- 增加钳位寄存器，在前级模块进行复位前进行数据隔离；\n- 复位前级模块时，关闭Dest domain的CG时钟；\n\n## 有趣的问题\n\n平头哥一面中，面试官提问我，ASIC中复位网络的扇出很大，很难保证所有寄存器都满足recovery和removal time的要求，异步复位/同步释放的方式也解决不了该问题，因为有Skew存在，问此时**如何保证正常的异步复位功能，且不用考虑recovery和removal time？**\n\n当时面试过程中没答出来，于是问了面试官，面试官说**异步复位前先把clock关了，复位后再开clock**，这样就可以避免考虑recovery和removal time，这个答案震惊到我了，作下记录，感谢平头哥的面试官！\n\n## Reference\n\n[Reset Domain Crossing](https://www.youtube.com/watch?v=G_37fwOVnik)\n\n","tags":["interview"],"categories":["interview"]},{"title":"Questasim安装与破解教程","url":"/2022/09/29/FPGA/Questasim安装教程/","content":"\n# Questasim安装与破解教程\n\n## 安装前提：\n\n系统要求：Win10 64位\n\n注意：安装路径及以后的项目路径、文件路径等都不要有中文和空格。\n\n## 安装破解步骤：\n\n1. 关闭电脑的杀毒软件和防火墙，双击安装包中的`questasim-win64-10.6c.exe`进行安装，推荐安装目录：`D:/questasim64_10.6c`。安装完成后不要打开软件先进行破解。\n\n   ![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055355.png)\n\n   ![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055257.png)\n\n   ![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055020.png)\n\n2. 复制和此文档同一压缩包内的'patch_dll.bat' 和'MentorKG.exe'和'license.dat'和'MakeLic.bat'（所有文件）到 <path_to_questasim_win64>文件夹(即安装目录里的win64文件夹，（举例：本人安装在`D:\\Program Files\\Questasim`，所以复制到文件夹`D:\\Program Files\\Questasim\\win64`）\n\n   ![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055285.png)\n\n3. 找到安装路径下`win64/mgls64.dll` 去掉其只读属性\n\n   ![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055378.png)\n\n4. 双击运行安装路径下`win64/patch_dll.bat`（这个文件是刚刚由压缩包中复制过来的），等待一段时间会产生LICENSE.TXT，保存到安装目录里的win64文件夹（本人是`D:\\Program Files\\Questasim\\win64`）\n\n   ![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232055937.png)\n\n5. 接下来是修改用户变量和系统变量，不同系统可能步骤不一样，但修改的内容都一样\n\n   **用户变量**\n\n|      变量名       |                    变量值                    |\n| :---------------: | :------------------------------------------: |\n|  LM_LICENSE_FILE  | D:\\Program Files\\Questasim\\win64\\license.dat |\n| MGLS_LICENSE_FILE | D:\\Program Files\\Questasim\\win64\\LICENSE.TXT |\n\n​\t**Path中新建两项**\n\n`D:\\Program Files\\Questasim\\win64`\n\n`D:\\Program Files\\Questasim\\win64\\LICENSE.TXT`\n\n​\t**系统变量**\n\n|      变量名       |                    变量值                    |\n| :---------------: | :------------------------------------------: |\n| MGLS_LICENSE_FILE | D:\\Program Files\\Questasim\\win64\\LICENSE.TXT |\n|  lm_license_file  | D:\\Program Files\\Questasim\\win64\\LICENSE.TXT |\n\n步骤图如下所示\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056666.png)\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056831.png)\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056685.png)\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056957.png)\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056079.png)\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056514.png)\n\n![13](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056480.png)\n\n![14](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232056522.png)\n\n6. 完成后打开软件，如果完成正确的配置后依旧无法打开可以重启计算机后打开。","tags":["FPGA_Tools"],"categories":["FPGA","FPGA_Tools"]},{"title":"Vivado与Modelsim联合仿真","url":"/2022/09/29/FPGA/Vivado与Modelsim联合仿真/","content":"\n# Vivado与Modelsim联合仿真\n\n笔者在学习FPGA过程中遇到了如何使用Vivado和Modelsim进行联合仿真的问题，特此记录。\n\n## 确定版本\n\n笔者Vivado用的是2018.3版本，先是随便下了个Modelsim10.1c的版本，到编译库文件时报错了，后来发现是俩款软件的版本不匹配。所以大家在进行联合仿真之前先核对两个软件的版本是否对应，不用到最后再卸载重装。\n\n**Vivado Design Suite 2018.3**\n\nMentor Graphics ModelSim SE/DE/PE (10.6c)\nMentor Graphics Questa Advanced Simulator (10.6c)\nCadence Incisive Enterprise Simulator (IES) (15.20.053)\nCadence Xcelium Parallel Simulator (18.03.005)\nSynopsys VCS and VCS MX (N-2017.12-SP2)\nAldec Active-HDL (10.5) Aldec Riviera-PRO (2018.02)\n\n**Vivado Design Suite 2018.2**\n\nMentor Graphics ModelSim SE/DE/PE (10.6c)\nMentor Graphics Questa Advanced Simulator (10.6c)\nCadence Incisive Enterprise Simulator (IES) (15.20.042)\nCadence Xcelium Parallel Simulator (17.10.005)\nSynopsys VCS and VCS MX (N-2017.12)\nAldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.10)\n\n**Vivado Design Suite 2018.1**\n\nMentor Graphics ModelSim SE/DE/PE (10.6c)\nMentor Graphics Questa Advanced Simulator (10.6c)\nCadence Incisive Enterprise Simulator (IES) (15.20.042)\nCadence Xcelium Parallel Simulator (17.10.005)\nSynopsys VCS and VCS MX (N-2017.12)\nAldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.10)\n\n**Vivado Design Suite 2017.4**\n\nMentor Graphics ModelSim SE/DE/PE (10.6b)\nMentor Graphics Questa Advanced Simulator (10.6b)\nCadence Incisive Enterprise Simulator (IES) (15.20.028)\nSynopsys VCS and VCS MX (M-2017.03-SP1)\nAldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.02)\n\n**Vivado Design Suite 2017.3**\n\nMentor Graphics ModelSim SE/DE/PE (10.6b)\nMentor Graphics Questa Advanced Simulator (10.6b)\nCadence Incisive Enterprise Simulator (IES) (15.20.028)\nSynopsys VCS and VCS MX (M-2017.03-SP1)\nAldec Active-HDL (10.4a) Aldec Riviera-PRO (2017.02)\n\n**Vivado Design Suite 2017.2**\n\nMentor Graphics ModelSim SE/DE/PE (10.5c)\nMentor Graphics Questa Advanced Simulator (10.5c)\nCadence Incisive Enterprise Simulator (IES) (15.20.014)\nSynopsys VCS and VCS MX (L-2016.06-SP1)\nAldec Active-HDL (10.4) Aldec Riviera-PRO (2016.10)\n\n**Vivado Design Suite 2017.1**\n\nMentor Graphics ModelSim SE/DE/PE (10.5c)\nMentor Graphics Questa Advanced Simulator (10.5c)\nCadence Incisive Enterprise Simulator (IES) (15.20.014)\nSynopsys VCS and VCS MX (L-2016.06-SP1)\nAldec Active-HDL (10.4) Aldec Riviera-PRO (2016.10)\n\n**Vivado Design Suite 2016.4**\n\nMentor Graphics ModelSim SE/DE/PE (10.5c)\nMentor Graphics Questa Advanced Simulator (10.5c)\nCadence Incisive Enterprise Simulator (IES) (15.20.005)\nSynopsys VCS and VCS MX (L-2016.06)\nAldec Active-HDL (10.3) Aldec Riviera-PRO (2016.06)\n\n**Vivado Design Suite 2016.3**\n\nMentor Graphics ModelSim SE/DE/PE (10.5c)\nMentor Graphics Questa Advanced Simulator (10.5c)\nCadence Incisive Enterprise Simulator (IES) (15.20.005)\nSynopsys VCS and VCS MX (L-2016.06)\nAldec Active-HDL (10.3) Aldec Riviera-PRO (2016.06)\n\nVivado Design Suite 2016.2, 2016.1\n\nMentor Graphics ModelSim SE/DE/PE (10.4d)\nMentor Graphics Questa Advanced Simulator (10.4d)\nCadence Incisive Enterprise Simulator (IES) (15.10.013)\nSynopsys VCS and VCS MX (K-2015.09)\nAldec Active-HDL (10.3) Aldec Riviera-PRO (2015.10)\n\n**Vivado Design Suite 2015.4, 2015.3**\n\nMentor Graphics ModelSim SE/DE/PE (10.4b)\nMentor Graphics Questa Advanced Simulator (10.4b)\nCadence Incisive Enterprise Simulator (IES) (14.20.006)\nSynopsys VCS and VCS MX (J-2014.12-SP2)\nAldec Active-HDL (10.2 SP2) Aldec Riviera-PRO (2015.06)\n\n**Vivado Design Suite 2015.2, 2015.1**\n\nMentor Graphics ModelSim SE/DE/PE (10.3d)\nMentor Graphics Questa Advanced Simulator (10.3d)\nCadence Incisive Enterprise Simulator (IES) (14.10.011)\nSynopsys VCS and VCS MX (I-2014.03-SP1)\nAldec Active-HDL (10.1 SP1) Aldec Riviera-PRO (2015.02)\n\n**Vivado Design Suite 2014.4**\n\nMentor Graphics ModelSim SE/DE/PE (10.3b)\nMentor Graphics Questa Advanced Simulator (10.3b)\nCadence Incisive Enterprise Simulator (IES) (13.20.005)\nSynopsys VCS and VCS MX (I-2014.03)\nAldec Active-HDL (9.3 SP1) Aldec Riviera-PRO (2014.02)\n\n**Vivado Design Suite 2014.3**\n\nMentor Graphics ModelSim SE/DE/PE (10.3b)\nMentor Graphics Questa Advanced Simulator (10.3b)\nCadence Incisive Enterprise Simulator (IES) (13.20.005)\nSynopsys VCS and VCS MX (I-2014.03)\nAldec Active-HDL (9.2 SP1) Aldec Riviera-PRO (2014.02)\n\n**Vivado Design Suite 2014.2, 2014.1**\n\nMentor Graphics ModelSim SE/DE/PE (10.2a)\nMentor Graphics Questa Advanced Simulator (10.2a)\nCadence Incisive Enterprise Simulator (IES) (12.2-016)\nSynopsys VCS and VCS MX (H-2013.06-SP1)\nAldec Active-HDL (9.3 SP1) Aldec Riviera-PRO (2014.02)\n\n**Vivado Design Suite 2013.4**\n\nMentor Graphics ModelSim SE/DE/PE (10.2a)\nMentor Graphics Questa Advanced Simulator (10.2a)\nCadence Incisive Enterprise Simulator (IES) (12.2-016)\nSynopsys VCS and VCS MX (H-2013.06)\nAldec Active-HDL (9.2 SP1) Aldec Riviera-PRO (2013.06)\n\n**Vivado Design Suite 2013.3**\n\nMentor Graphics ModelSim SE/DE/PE (10.2a)\nMentor Graphics Questa Advanced Simulator (10.2a)\nCadence Incisive Enterprise Simulator (IES) (12.2-016)\nSynopsys VCS and VCS MX (H-2013.06-3)\nAldec Active-HDL (9.2) Aldec Riviera-PRO (2013.02)\n\n**Vivado Design Suite 2013.1, 2013.2**\n\nMentor Graphics ModelSim SE/DE/PE (10.1b)\nMentor Graphics Questa Advanced Simulator (10.1b)\nCadence Incisive Enterprise Simulator (IES) (12.2)\nSynopsys VCS and VCS MX (G-2012.09)\nAldec Active-HDL (9.2) Aldec Riviera-PRO (2012.10)\n\n[reference](https://www.xilinx.com/support/answers/68324.html)\n\n笔者用的是Vivado2018.3，查询的对应的Modelsim版本为10.6c。\n\n------\n\n## Modelsim破解\n\n准备Modelsim10.6c的安装包\n\n[下载链接](https://download.csdn.net/download/qq_42334072/13087931)\n\n步骤如下：\n\n(1)、安装软件，**注意安装路径中不要出现中文或空格**，安装过程中一直点击YES即可。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102490.png)\n\n(2)、把`crack.bat`、`MentorKG.exe`一起拷贝到modelsim安装目录的win64文件夹下，例如`D:\\modelsim_dlx64_10.6c\\win64pe`\n\n(3)、双击`crack.bat`，若出现下图所示问题，则将`mgls64.dll`重命名为`mgls.dll`再次重新运行`crack.bat`即可。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102020.png)\n\n(4)、将生成的`LICENSE.TXT`放在modelsim的安装路径下，如`D:\\modelsim_dlx64_10.6c`，若前面修改了mgls64.dll文件的名称，则生成完LICENSE文件后应当把名字改回去。\n\n(5)、新建环境变量`MGLS_LICENSE_FILE`，变量值为LICENSE放置的路径，如`D:\\modelsim_dlx64_10.6c\\LICENSE.TXT`。在win10中，右键此电脑->属性->高级系统设置->环境变量，进行环境变量的添加。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102492.png)\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102352.png)\n\n(6)、打开Modelsim软件，安装破解结束。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232102973.png)\n\n------\n\n## 联合仿真\n\n(1)、打开任意一个vivado工程，再按下图所示点击编译Xilinx的仿真库。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103139.png)\n\n注意：Simulator选Modelsim Simulator，编译库Compiled library location放入新建的文件夹`D:\\Xilinx\\Xlib`中(可自己指定)，Simulator executable path选择modelsim安装路径下的win64pe。注意Compile Xilinx IP选项不勾选。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103436.png)\n\n编译结果从Vivado中的Tcl Console中可知，无Errors，芜湖起飞！\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103881.png)\n\n(2)查看编译库Compiled library location路径下，应该出现`modelsim.ini`文件。\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103243.png)\n\n我们将其设置为用户的全局变量，这样下次就不需要再编译库文件了，步骤如下图所示：\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103520.png)\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103420.png)\n\n(3)、设置第三方仿真软件的安装路径与编译库的路径，具体步骤如下图所示\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232103143.png)\n\n![13](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104566.png)\n\n![14](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104304.png)\n\n(4)、全部准备就绪后，点击Run Simulation中的Run Behavioral Simulation。\n\n![15](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104184.png)\n\n自动弹出Modelsim，并显示波形，游戏结束。\n\n![16](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232104385.png)\n\n","tags":["FPGA_Tools"],"categories":["FPGA","FPGA_Tools"]},{"title":"Vivado中RTL封装IP流程","url":"/2022/09/29/FPGA/Vivado中RTL封装IP流程/","content":"\n# Vivado中RTL封装IP流程\n\n## 前言\n\n本文记录自己将RTL代码封装成IP的流程，以供之后查阅使用。最近一个月在做一个数据仲裁与转发的项目，已经完成功能仿真，准备将其封装成IP在Block Design中进行调用。实验平台为Vivado 2018.3，编程语言为Verilog，IP的接口主要是一个AXI-Lite接口和一个AXI-Full接口。闲言少叙，我们直接开始。\n\n## 详细流程\n\n### 准备工作\n\n新建一个文件夹`ip_test`，在该文件夹下新建文件夹`rtl`，将所有RTL源码放入该文件夹，完成准备工作；\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232113260.png)\n\n新建一个文件夹`top_module`，里面仅存放RTL源码的最顶层的.v文件，便于IP生成正确的接口。(**之前尝试将所有的RTL源码一次导入，发现vivado不能正确识别顶层模块，从而导致IP接口一直不对**)\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232113923.png)\n\n### 创建工程\n\n双击打开vivado 2018.3，选择`Tasks->Manage IP->New IP Location`,按下图所示顺序进行操作；\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114706.png)\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114156.png)\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114661.png)\n\n上图中的`IP location`选择之前建立的`ip_test`文件夹路径，选完后点击`Finish`完成工程的创建；\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114039.png)\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114564.png)\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114217.png)\n\n因为本项目已有RTL源码，所以上图中我们选`Package a specified directory`；如果没有源码想创建一个带AXI接口的空IP往里写功能的话就选择`Create a new AXI4 Peripheral`；\n\n此处一定注意下图中的路径，选择**RTL顶层模块源码**的路径\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232114671.png)\n\n指定项目的名称，本示例工程名字为`ip_test`;\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115430.png)\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115659.png)\n\n点击`Finish`后我们看到封装IP的界面，此时看到IP的名称与顶层模块相同，且接口也与顶层模块的一致，只是此时除了顶层模块外，其余模块均未添加到`Design Sources`中。\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115723.png)\n\n![13](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115661.png)\n\n下面进行剩余源码的添加，将`rtl`文件夹中的代码添加到`Design Sources`中。\n\n![14](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115747.png)\n\n![15](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232115898.png)\n\n![16](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116980.png)\n\n![17](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116444.png)\n\n选择IP封装模块的`File Groups`选项，点击`Merge changes from File Groups Wizard`\n\n![18](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116407.png)\n\n可以看到此时的IP已经包含了所有的源码；\n\n![19](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116420.png)\n\n### 属性配置\n\n![20](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116796.png)\n\n在`Ports and Interfaces`界面中，我们可以看到，vivado工具自动将时钟复位信号、AXI-Full信号和AXI-Lite信号进行打包处理(*vivado永远的神！*)，但还有一些属性需要设置，否则vivado会报warning。如复位信号的低电平复位属性、时钟与AXI协议的相关属性等；\n\n添加复位信号的低电平复位属性流程如下：\n\n![21](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116809.png)\n\n![22](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232116268.png)\n\n![23](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117310.png)\n\n将`clk`时钟与`rst_clk_n`绑定起来，并指定AXI-Lite接口用`clk`时钟\n\n![24](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117443.png)\n\n![25](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117514.png)\n\n具体各参数的属性配置情况大家可以参考**vivado官方教程ug1118**。完成上面时钟或者复位的绑定配置后，最后进行IP核的导出。\n\n### 导出IP\n\n在封装IP界面选择`Review and Package`，先进行打包IP的配置，点击`Edit packaging settings`；\n\n![26](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117071.png)\n\n进行上图所示的配置，其中`Delete project after packaging`选项可以不选，因为导出IP可能之后还要继续，要对RTL代码进行修改上板测试来迭代更新，所以我们一般保留导出IP的项目工程。\n\n![27](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117492.png)\n\n最后回到封装IP的界面，点击`Package IP`选项即可。\n\n![28](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232117377.png)\n\n已经成功打包，询问是否关闭项目工程，`Yes`或者`No`均可。\n\n![29](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232118766.png)\n\n到指定的路径下查看，发现已经生成我们所需的IP。至此，封装IP圆满结束。\n\n![30](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232118967.png)\n\n## 结语\n\n本文为笔者打包IP的经验分享帖，其中不免错误不足之处，如果其中步骤有误还望大家指正出来，一起交流进步。\n\n## 参考资料\n\n[Vivado Design Suite User Guide: Creating and Packaging Custom IP (UG1118)](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug1118-vivado-creating-packaging-custom-ip.pdf)","tags":["FPGA_Tools"],"categories":["FPGA","FPGA_Tools"]},{"title":"NVDLA阅读笔记","url":"/2022/09/29/Proj/NVDLA阅读笔记/","content":"\n# NVDLA阅读笔记\n\n## Unit Description\n\n### System Architecture\n\nNVDLA作为深度学习加速器可以集成在SoC中作为一个协处理器；\n\nNVDLA有许多数据处理Engine，各Engine都是独立的且可以自由配置，比如不需要池化的网络可以移除Planar Data Processor，各Engine的调度操作可以委托给Microcontroller或者CPU；其中用Microcontroller来调度的方式称为“headed” implementation，用CPU来调度的方式称为“headless” implementation；\n\n图中左边的框图展示了“headless” implementation的示例，是一个小型的NVDLA系统，成本较低；右边的框图展示了“headed” implementation的示例，是一个大型的NVDLA系统，主要是添加了Microcontroller和高带宽的SRAM，适合于高性能的物联网设备。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141331.png)\n\nNVDLA主要有4个接口，其中SRAMIF是可选项；\n\n- CSB（Configuration Space Bus）：这个接口是一个同步、低带宽、低功耗的32位控制总线，主要用来访问NVDLA的配置寄存器；\n- IRQ（Interrupt Request）：当NVDLA中的任务完成或者发生错误时会将中断线进行置位；\n- DBB（Data Backbone Interface）：DBB接口连接NVDLA和片外的DRAM，与AXI接口类似，是高速、高度可配置的数据总线，可以根据系统的要求发出不同大小的读写请求；\n- SRAMIF（SRAM Interface）：DBB接口还有一个可选的接口，在设计上与DBB接口相同，目的在于结合片上的SRAM来提供更高的数据吞吐量以及更低的访问延迟；\n\n### DLA Core Architecture\n\nDLA的结构框图如图所示；内部主要有两个接口模块，其中Configuration Interface用于访问NVDLA的配置寄存器，Memory Interface用于读写特征数据、权重、像素数据等；\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141690.png)\n\nConvolution buffer主要用于缓存像素数据、特征数据、权重数据等，供卷积核中的卷积序列控制器模块读取；Convolution core主要完成卷积中的乘加运算；SDP主要负责对单个数据执行后处理操作，包括bias加法、ReLU、Sigmoid、双曲正切、BN、逐元素操作等；PDP是平面数据处理器，主要完成池化相关的操作；CDP主要在通道方向上执行操作，旨在解决局部响应归一化层；RUBIK模块的功能与BDMA类似，它在不进行任何数据计算的情况下转换数据的映射格式，因为它的功能是变换特征数据立方体的尺寸，所以又被称为魔方单元；BDMA模块在外部DRAM和片上SRAM之间提供了一条移动数据的通道，它有两条独立的路径，一条是将数据从外部DRAM复制/移动到内部SRAM，另一条是将数据从内部SRAM复制/移动到外部DRAM，两条路径不能同时工作；\n\nNVDLA有两种工作模式，独立模式（Independent Mode）和结合模式（Fused Mode）。独立模式下，各Engine分别通过两组数据接口完成各自分配的任务；结合模式可以将Convolution Core、SDP和PDP连接在一起作为一个整体流水线完成分配的任务；\n\n### Convolution Pipeline\n\n流水线卷积模块是NVDLA的核心逻辑，用于加速卷积算法，同时在卷积流水线中引入了Winograd算法和Multi-batch，提高MAC效率。Convolution Pipeline有五个阶段，分别是Convolution DMA、Convolution Buffer、Convolution Sequence Controller、Convolution MAC和Convolution Accumulator，各阶段都有自己的CSB来接收来自CPU的配置数据。CDMA从SRAM/DRAM中获取数据来进行卷积操作，并按卷积Engine所需的数据顺序存储到CBUF中；CBUF缓存来自CDMA模块的像素、特征和权重等数据，由CSC模块进行读取；CSC模块负责从CBUF加载数据并发送到CMAC单元，它是卷积序列控制的关键模块；CMAC模块从CSC接收输入数据和权重，执行乘法和加法运算，并将结果输出给CACC；CACC模块用于对CMAC模块的部分和进行累加，并在发送给SDP模块前对数据进行舍入操作。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141311.png)\n\n### CDMA\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141023.png)\n\nCDMA主要负责从SRAM/DRAM中获取数据来进行卷积操作，读取的数据主要有以下数据类型：\n\n- 像素数据（Pixel Data）\n- 特征数据（Feature Data）\n- 未压缩/压缩权重数据（Uncompressed/compressed weight）\n- WMB（Weight Mask Bit）\n- WGS（Weight Group Size）\n\nCDMA主要有两个数据通道，分别是权重读取通道和数据读取通道，CDMA仅发送数据读取的请求。CDMA有三个子模块来获取像素数据或者特征数据来进行卷积，分别是CDMA_IMG（Pixel）、CDMA_WG（Winograd）、CDMA_DC（Direct Convolution）。上述三个子模块的工作步骤类似，区别在于数据存放在CBUF RAM中的格式，任何时候只能有一个子模块被激活来获取像素/特征数据。以CDMA_DC为例介绍一下CDMA的工作流程：\n\n- 检查CBUF的状态，查看是否有空间；\n- 进行一个读取事务；\n- 在共享缓冲区（Shared_buffer）中缓存特征数据；\n- 将特征数据立方体重塑为正确的格式；\n- 生成卷积缓冲区（CBUF）的写入地址；\n- 将特征数据写入CBUF；\n- 更新CDMA_STATUS子模块中CBUF的状态；\n\n### CBUF\n\nCBUF模块有16个32KB的Bank，每个Bank由两个512位宽、256深度的双口RAM组成，存储空间共512KB；CBUF缓存来自CDMA的像素、特征、权重和WMB数据，并由CSC模块进行读取；CBUF有两个写端口和三个读端口。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232141424.png)\n\n如果权重被压缩，那么Bank15分配给WMB数据，Bank0~14分配给特征、权重进行缓存。如果权重没被压缩，那么特征、权重缓冲区可以使用16个Bank；\n\n每个Bank都是循环缓冲区，新的数据进来时地址都会进行自增，当地址达到最大值后会回到0重新自加；\n\n### CSC\n\n卷积序列控制器（CSC）负责从CBUF加载输入特征数据、像素数据和权重数据，并将其发送到CMAC单元，主要包含三个模块：CSC_SG、CSC_WL和CSC_DL。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142001.png)\n\n#### CSC_SG\n\nCSC_SG模块用来生成序列来控制卷积操作，它的工作流程如下：\n\n1. 在CBUF中轮询足够的数据和权重；\n2. 生成一对序列包，包括weight加载包和data加载包，每个包表示一个stripe operation；\n3. 将两个加载包push到两个FIFO中；\n4. 两个用于weight和feature/image的计数器都是向下计数；//计数器的作用？\n5. 当计数器达到零时，检查来自CACC的信号是否有任何back pressure；\n6. 如果所有条件都准备就绪，就将weight和data包发送给CSC_WL和CSC_DL；\n\n#### CSC_DL\n\nCSC_DL（Data loader）负责执行feature/image加载序列的逻辑，他从CSC_SG接收包，从CBUF加载feature/image data，并将其发送到CMAC；且它还维护CBUF的状态，并与CDMA通信以保持状态最新。对于Winograd模式，它还执行预加法来转换输入数据；\n\n以DC mode为例说明CSC_DL的工作流程：\t\t\t\t\t\t\t\t\t\t\t\n\n1. 每个Atomic Operation，DL从CBUF读取一个data atom，并发送给CMAC；\n2. 每个Stripe Operation，DL从CBUF读取16~32个data atom，并发送给CMAC；\n3. 每个Block Operation，DL重复（weight_height*weight_width）次stripe operation，从CBUF读取对应的data atom，并发送给CMAC；\n4. 每次Channel Operation，DL重复C/64次block Operation，从CBUF读取对应的data atom，并发送给CMAC；\n5. 每个Group Operation，DL遍历整个feature map，重复（data_width*data_height）/（16~32）次channel operation，并发送给CMAC；\n6. DL重复kernel_num/（16~32）次group operation，每次的data都是相同的；\n\n注：16 or 32取决于数据精度。\n\n#### CSC_WL\n\nCSC_WL（Weight loader）执行weight加载序列的逻辑，它从CSC_SG接收包，从CBUF加载weight，并进行必要的解压缩并将其发送到CMAC。它帮助维护权重缓冲区状态，并与CDMA_WT通信，来使状态及时更新。\n\n以DC mode为例说明CSC_WL的工作流程：\t\t\t\t\t\t\t\t\t\t\t\n\n1. 每个atomic operation，WL不需要操作；\n2. 每个stripe operation，WL从CBUF读取1个group的16/32个weight atom，并发送给CMAC；\n3. 每个block operation，WL重复（weight_height*weight_width）次stripe operation，从CBUF读取对应的weight atom，并发送给CMAC；\n4. 每个channel operation，WL重复C/64次block operation，从CBUF读取对应的weight atom，并发送给CMAC；（tips：64=128byte/(int16/fp16)）\n5. 每个group operation，WL反复读取同一组group的weight，重复（data_width*data_height）/（16~32）次channel operation，并发送给CMAC；\n6. WL重复kernel_num/（16~32）次group operation，完成所有kernel group的读取；\n\n### CMAC\n\nCMAC（Convolution Multiply Accumulate）模块是流水线卷积操作的一个阶段，它从CSC接收输入数据和权重，进行乘法和加法运算，并将输出结果输出到卷积累加器。当在Winograd模式下工作时，CMAC在输出上执行POA(post addition)将结果转换为标准激活格式。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142273.png)\n\nCMAC有16个相同的MAC Cell，每个MAC Cell包含64个用于16bit的16位乘法器，还包含72个16bit的加法器，用于Winograd的POA。每个16位宽的乘法器和加法器都可以拆分成int8格式的两个计算单元，所以int8的吞吐量是int16的两倍；MAC Cell的流水线深度为7个Cycle。\n\n为了Physical Design Optimization，CMAC被分为两部分CMAC_A和CMAC_B，每个都有单独的CSB接口。\n\n### CACC\n\n卷积累加器（CACC）是卷积流水线在CMAC之后的阶段，它用于累加CMAC模块的部分和，并在发送到SDP之前对结果进行舍入/饱和。它支持不同位宽的数据输入，对于INT16输入而言结果位宽为48位，对于INT8输入而言结果位宽为34位。CACC和SDP模块之间的数据位宽是32，所以在将结果发送给SDP之前需要执行一个舍入和饱和运算。\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142043.png)\n\nCACC中的组件如图所示，工作流程主要如下：\n\n1. 从assembly SRAM中预取累加和；\n2. 当CMAC的部分和到达时，将它们与累加和一起发送到adder array；如果部分和来自第一个stripe operation，则累积和应为0；\n3. 从adder array的输出端收集新的累加和；\n4. 存储到assembly SRAM中；\n5. 在stripe operation中重复step1~step3，直到一个channel operation完成；\n6. 如果完成channel operation，加法器的输出将被舍入并饱和；\n7. 收集上一步的结果并将其存储到delivery SRAM中；\n8. 从delivery SRAM中加载结果并将它们发送给SDP；\n\n为支持Direct Convolution模式下的Multi-Batch选项，CACC在交付SRAM组中应用了data remapping功能；为了防止数据溢出，CACC使用相关协议来反压CSC模块。\n\n### SDP\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142835.png)\n\nSDP是单点数据处理器，意在对单个数据元素级别执行后处理操作，主要完成以下的操作：\n\n1. **<u>Bias加法</u>**的公式为`y=x+bias`，bias是一个预先训练的参数，可以是以下3种之一：如果整个data cube都是同一bias的话可以从寄存器获取；per-channel模式下，同一channel内bias共享；per-element模式下，不同的element的bias都不同。\n2. Non-Linear Function，包括ReLU、Sigmoid和双曲正切。ReLU可以通过硬件逻辑实现，Sigmoid和双曲正切函数是非线性函数，所以用查找表来实现；\n3. Batch Normalization：SDP支持使用给定的均值/标准方差参数进行批量归一化，参数是从训练中获得的，SDP还可以支持按层参数或者按通道参数进行批量归一化操作；\n4. Element-Wise Layer：它指两个具有相同W、H和C参数的特征数据立方体之间的一种操作。这两个W×H×C特征数据立方体进行元素加法、乘法、或MAX/MIN比较操作，并输出一个W×H×C的特征数据立方体；\n5. PReLU Function，ReLU是将负值裁剪到0，而PReLU是将负值进行缩放；\n6. Format Conversion：NVDLA支持INT8、INT16和FP16精度，较低的精度可提供较高的性能，而较高的精度可提供更好的推理结果。\n\n### PDP\n\nPDP主要沿宽×高的平面执行操作，PDP模块旨在完成池化层，支持MAX、MIN和AVERAGE池化操作。PDP单元接收来自SDP或者MCIF/SRAMIF的数据，并将数据发送给MCIF/SRAMIF。\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142274.png)\n\n支持的尺寸如下：Pooling Kernel Size：1~8；Pooling Kernel Stride：1~16；\n\non-the-fly模式下输入数据直接从SDP获取，off-fly模式下输入数据从PDMA获取；\n\nPre-processing模块主要完成最大、最小操作以及部分和的求和操作；\n\nPos-processing模块主要针对Average Pooling进行相关的后处理操作，如果是MAX/MIN Pooling操作的话，那么Share Line Buffer存储的就是最终结果；如果是Average Pooling的话，需要取出Share Line Buffer中的数进行除法操作，并且为方便硬件实现将除法转换为乘法操作；\n\n### CDP\n\nCDP模块旨在解决局部响应归一化层，LRN通过在通道方向上对局部输入区域进行归一化。CDP模块始终与其它处理子单元<u>**独立工作**</u>，它从PDMA接收输入数据并将输出数据发送回PDMA。\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232142860.png)\n\nLRN的计算公式中涉及到除法和指数运算，使用硬件实现代价较大，所以内部用LUT实现功能。\n\n### RUBIK\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143590.png)\n\nRUBIK的功能是转换数据的映射格式，主要有三种工作模式：\n\n- contract data cube\n- split feature data cube into multi-planar formats\n- merge multi-planar formats to data cube\n\n### BDMA\n\nNVDLA一般将输入图像和处理结果存储在外部DRAM中，但受限于DRAM的带宽和延迟，NVDLA不能提高MAC阵列的效率，所以NVDLA配置了一个到片上SRAM的辅助存储器接口。\n\n![13](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143215.png)\n\nNVDLA使用BDMA来在外部DRAM和内部SRAM之间移动数据，有两个独立的路径，一个是从DRAM到SRAM，另一个是从SRAM到DRAM，两个方向不能同时工作。同时BDMA还可以将数据从DRAM移动到DRAM，或者从SRAM移动到SRAM。\n\n两个接口的数据位宽均为512位，最大突发长度为4。\n\n### MCIF&SRAMIF\n\n![14](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143502.png)\n\n![15](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143212.png)\n\nMCIF用于仲裁多个内部子模块的请求，并转换为AXI协议来连接到外部DRAM。MCIF是同时支持读写通道的仲裁的，但有些NVDLA的子模块只有读请求，如图中的CDMA0和CDMA1只有读请求，其它5个接口均需要读写。\n\nSRAMIF与MCIF接口功能类似，但预计总线延迟更低。\n\n## Convolution in NVDLA\n\n下面简单说一下NVDLA中直接卷积的流程。输入的Data Cube为W×H×C；共K个kernel，每个kernel的尺寸为S×R×C；输出的Data Cube尺寸为W'×H'×C'；其中W'和H'与Padding和Stride有关，C'与Kernel数量相等；\n\n![16](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143782.png)\n\n下图显示了Stride和Zero Padding的示意图，其中黑色虚线框出的是Padding之前的Feature Data；Kernel字母表示卷积核的中间位置，可以看到在X方向和Y方向上分别以SX和SY为距离进行步进；\n\n![17](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143564.png)\n\n### Data Format\n\n![18](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232143069.png)\n\n![19](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144717.png)\n\n这张图显示了Direct Convolution模式下特征数据与权重的数据格式，特征数据以32Byte为单位，在W-H-C方向上进行扫描并对数据进行存储，如果原始特征数据不是C方向上的32字节对齐，则将数据添加到通道末尾；\n\n权重数据是在卷积操作之前很久就生成的，软件应将权重数据按DLA中的计算顺序进行映射。权重是在通道方向上以128Byte为单位进行划分，不足128Byte的话要进行一个补零操作，在C'-W-H-C方向上进行扫描并对数据进行存储。\n\n### Atomic Operation\n\n![20](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144637.png)\n\n在一个原子操作中，每个MAC Cell都取一个1×1×64的weight cube（16bit）来与1×1×64的feature data做运算，**<u>完成64个数的乘加运算操作（64个Channel）</u>**。因为有16个MAC Cell，所以一次能并行计算16个kernel，MAC Cell乘加运算后的结果叫做部分和，所以**<u>每个Cycle我们可以得到16个部分和（partial sum）</u>**。得到的部分和被送往CACC模块进行累积和的计算。\n\n### Stripe Operation\n\n![21](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144640.png)\n\n条带操作是原子操作的组合，在一次条带操作的过程中，**<u>MAC Cell中的权重数据保持不变</u>**，特征数据沿着input data cube滑动。（首先沿着W方向进行滑动）\n\n由于条带操作MAC Cell中权重数据保持不变，所以**<u>一次条带操作中的部分和不能进行累加操作</u>**，因为它们来自不同的卷积核；这就是说需要在CACC模块对部分和进行缓存。\n\n**<u>由于CACC模块的缓冲区受限，所以Stripe Operation的Length有上限，上限为32。</u>**同时Stripe Operation的Length也有下限，**<u>因为要更新下一次Stripe Operation的权重数据至少要16个Cycle，所以下限为16。</u>**\n\n即1次Stripe Operation=16~32次Atomic Operation，其中Weight Data不变，滑动Feature Data。\n\n### Block Operation\n\n![22](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144564.png)\n\nBlock Operation是由一系列的Stripe Operation组成，**<u>次数为（Weight Width×Weight Height）</u>**，每次Stripe Operation的部分和结果都被发送到CACC模块进行累加和的计算。\n\n<!--NVDLA文档上写的是16-32 element accumulator，我理解的是可以对16-32路进来的数据进行累加，在一次Block Operation中每路的数据量应该是（Weight Width×Weight Height），每个数据都是Atomic Operation的部分和。-->\n\n> The partial sums from the same block operation are added together per stripe operation in the convolution accumulator.\n\n累加和的计算公式如下：\n$$\nAS_{w,h,k,c}=\\sum_{r=0}^{R-1}\\sum_{s=0}^{S-1}\\sum_{i=c}^{min(c+63,C-1)}x_{(w*SX-LP+r),(h*SY-TP+s),i}*wt_{r,s,i,k}\n$$\n在公式中，AS指accumulative sum，其中第一个和第二个求和应该是由CACC模块进行，第三个求和应该是MAC Cell进行。\n\n### Channel Operation\n\n![23](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144295.png)\n\n每次Block Operation完成64个kernel的运算，Channel Operation是一系列Block Operation的组合，次数共有`(C+63)/64`，完成Channel方向上的所有运算。**<u>在同一个Channel Operation中的部分和应该以卷积核为单位继续进行累加操作</u>**，在Channel Operation完成后，存储的累加和才是卷积的最终结果，才会从CACC模块中的assembly SRAM卸载到delivery SRAM，送给后续的处理模块。\n\n<!--CACC模块对16-32路进来的数据进行累加，在一次Block Operation中每路的数据量应该是（Weight Width×Weight Height）×[(C+63)/64]，每个数据都是Atomic Operation的部分和。-->\n\n### Group Operation\n\n![24](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232144454.png)\n\nGroup Operation是Channel Operation的组合，需要重复`(data_width*data_height)/(16~32)`次。在Group Operation后，输出的数据尺寸为`W×H×K'`，其中K'为一次Kernel Group中Kernel的数量，对于16-bit的数据而言为16个，对于8-bit的数据而言为32个。\n\nDirect Convolution重复`kernel_num/(16~32)`次Group Operation即可完成卷积运算，每次的feature data都是相同的。\n\n## 其它\n\n### 权重压缩\n\n- WMB：Weight Mask Bit，用一位标记来指示权重元素是否为0，1位与1个权重element对应；对于int16和fp16，1位代表2字节权重数据；对于int8，1位代表1个字节的权重数据；WMB始终是128Byte对齐，不足的补0。\n- WGS：Weight Group Size，压缩后的权重组数据量大小，单位为Byte，位宽为32bit；\n\n### Multi-Batch Mode\n\nNVDLA支持多批次模式来提高性能并降低带宽，特别是对于全连接层。全连接层的输出是1×1×C的data cube，也就是说FC层中的所有权重只使用一次，就是FC层的一个条带操作内只有一个原子操作，但流水线卷积还需要16个周期来为下一个原子操作加载权重，MAC的效率下降到6.25%。\n\n多批次就是说同时处理多个输入的特征数据立方体，流水线卷积将为一组权重kernel获取多个输入数据立方体，这也改变了原子操作。来自不同输入数据立方体的1×1×64的cube一个一个交错加载以进行原子操作，然后条带操作包含多个批次的原子操作。由于权重在整个Stripe Operation中重复使用，因此可以把权重加载周期隐藏到处理流程中，提高了MAC的使用效率。\n\n## END\n\n[Reference](http://nvdla.org/hw/v1/ias/unit_description.html)","tags":["Proj"],"categories":["Proj"]},{"title":"Verilog各类分频器设计详解","url":"/2022/09/29/IC/Basic/Verilog各类分频器设计详解/","content":"\n# Verilog各类分频器设计详解\n\n分频器是时序电路的基本器件，它的功能是对系统时钟或其他时钟进行分频产生所需要的时钟信号。分频有两种方式：一是通过HDL语言建模产生所需要的时钟信号，二是利用开发工具的PLL进行分频。前者分频灵活，需编写代码实现；后者使用场景受限，因为有的低端FPGA没有PLL，但PLL的分频效果更好，而且在进行小数分频时也比较容易实现。**本文首先尝试用HDL语言建模方式设计各种类型的分频器，最后给大家简单介绍一下PLL的使用。**如有不足之处还望大家批评指正。\n\n## 偶数分频器\n\n我们先从最简单的偶数分频器切入，慢慢分析各种分频器的实现。\n\n若要实现二分频，则只需要在原时钟的上升沿进行输出时钟状态的翻转即可，如下图所示\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232037429.png)\n\n若实现四分频呢？则需要一个计数器，每次在原时钟的上升沿计数，当计数器记到2个上升沿时输出时钟状态进行翻转，如下图所示\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232037205.png)\n\n现在对一般情况进行分析，**对时钟进行N分频，N为偶数**；则计数器每次在原时钟的上升沿计数，**计数器的范围为0~(N-1)**，我们可以在0—(N-1)这N个数中分出两个范围选择输出时钟的状态，如当cnt在0—M范围时输出时钟为低电平，当cnt在(M+1)—(N-1)范围时输出时钟为高电平，则**我们可以动态调整输出时钟的占空比**，输出时钟的占空比为(N-M-1)/N；\n\n以8分频为例，则N=8，取M=3，则此时输出的时钟应当是50%占空比，如下图所示\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232038249.png)\n\n若取M=1，则此时输出时钟的占空比应当是75%，如下图所示\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232038225.png)\n\n**偶数分频器代码**\n\n```verilog\n// 偶数分频器示例，可调占空比\nmodule clk_div_even(\n\tinput wire clk,                 //系统时钟\n\tinput wire rst_n,               //异步低电平复位\n\tinput wire [7:0] clkperiod,     //分频系数，N(偶数)分频时clkperiod=N\n\tinput wire [7:0] clklow,        //低电平占用系统时钟的周期数\n                                    //占空比为50%时clklow=N/2\n    output reg clk_out\t\t\t\t//输出时钟\n    );\n \nreg [7:0] cnt;\n \nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        cnt <= 8'b0;\n        clk_out <= 1'b0;\n    end\n    else begin\n        if(cnt == clklow - 1'b1) begin\n            clk_out <= 1'b1;\n            cnt <= cnt + 8'd1;\n        end\n        else if(cnt == clkperiod - 1'b1) begin\n            clk_out <= 1'b0;\n            cnt <= 8'd0;\n        end\n\t\telse begin\n            cnt <= cnt + 8'd1;\n\t\tend\n    end\nend\n \nendmodule\n```\n\n## 奇数分频器\n\n我们先以三分频模块切入，分析奇数分频器的思想：整体思路是**产生两路上升沿和下降沿触发信号**，然后对这两路信号进行操作得到最终分频时钟。\n\n当分频系数N为奇数时，使用一个计数器在0~(N-1)循环进行计数，控制输出(N-1)/2个高电平，(N+1)/2个低电平，称为`clk_1`；然后将此`clk_1`电平信号延迟半个周期称为`clk_2`，最后输出`clk_out =  clk_1 | clk_2`，即为占空比为50%的奇数分频器；另一种思路是产生输出(N+1)/2个高电平，(N-1)/2个低电平的`clk_1`，输出的分频时钟为`clk_out =  clk_1 & clk_2`。\n\n以`clk_out =  clk_1 & clk_2`为例，将`clk_1`延时半个时钟周期的方法有两种，法1是直接使用下降沿的锁存器对`clk_1`锁存得到`clk_2`，法2得到`clk_2`的原理与`clk_1`相同，不过是在下降沿检测。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232039017.png)\n\n若采用法一，则我们用一个**下降沿触发**的D触发器锁存`clk_1`的结果`clk_2`，然后将`clk_1`与`clk_2`信号做逻辑“或”就得到了占空比50%的分频时钟信号`clk_out`。\n\n结合上面的偶数分频器，如果N为偶数，则`clk_1`就是我们所需要的分频结果，如果N为奇数，则`clk_1 & clk_2`就是我们所需的分频结果，所以我们可以把偶数分频和奇数分频结合，实现N分频器设计，其中N为正整数；通过N[0]选择输出，N[0]=1为奇数分频，N[0]=0为偶数分频。\n\n5分频结果如下：\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232040146.png)\n\n6分频结果如下：\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232040660.png)\n\n**正整数分频器代码**\n\n```verilog\nmodule clk_div_integer #(\n    parameter N = 6,        //N分频，N为整数\n    parameter WIDTH = 3     //计数器位宽\n) (\n    input wire clk,\n    input wire rstn,\n    output wire clk_out\n);\n\n    reg [WIDTH-1:0] cnt;\n    reg clk_1,clk_2;\n    wire clk_odd;\n\n    always @(posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            cnt <= 0;\n        end\n        else begin\n            if(cnt == N-1) begin\n                cnt <= 0;\n            end\n            else begin\n                cnt <= cnt + 1'b1;\n            end\n        end\n    end\n\n    always @(posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            clk_1 <= 1'b0;\n        end\n        else begin\n            if(cnt == ((N-1) >> 1)) begin\n                clk_1 <= 1'b1;\n            end\n            else if(cnt == (N-1))begin\n                clk_1 <= 1'b0;\n            end\n            else begin\n                clk_1 <= clk_1;\n            end\n        end\n    end\n\n    //法1：在时钟下降沿锁存clk_1得到clk_2\n    always @(negedge clk or negedge rstn) begin\n        if(~rstn) begin\n            clk_2 <= 1'b0;\n        end\n        else begin\n            clk_2 <= clk_1;\n        end\n    end\n\n    //法2:clk2与clk_1产生的方式相同，差别是clk_2是下降沿触发\n    // always @(negedge clk or negedge rstn) begin\n    //     if(~rstn) begin\n    //         clk_2 <= 1'b0;\n    //     end\n    //     else begin\n    //         if(cnt == ((N-1) >> 1)) begin\n    //             clk_2 <= 1'b0;\n    //         end\n    //         else if(cnt == (N-1)) begin\n    //             clk_2 <= 1'b1;\n    //         end\n    //         else begin\n    //             clk_2 <= clk_2;\n    //         end\n    //     end\n    // end\n\n    assign clk_odd = clk_1 | clk_2;\n    assign clk_out = N[0] ? clk_odd : clk_1;\n    \nendmodule\n```\n\n## 半整数分频器\n\n**1、占空比非50%**\n\n网上比较多的分频思路是：半整数分频多出来的那半个周期为高电平，其余为低电平。以5.5分频为例，以原时钟的半周期为单位，可以分频输出1高10低。原理是用计数器循环记数0~10即11个周期，控制输出`clk_1`前6周期高电平，后5周期低电平，然后再使用该计数器得到一下降沿触发的5低6高的输出`clk_2`，最后输出`clk_out = clk_1 & clk_2`。波形图如下图所示\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232041944.png)\n\n现在我们虽然得到了5.5分频后的信号，但占空比不是很理想，是否可以在其基础上进行改进来实现占空比近似50%的分频信号呢？\n\n**2、占空比近似50%**\n\n由上面的波形图我们可以看到，如果`clkx`和`clky`在`cnt`的其它状态(稍微偏大的值)进行状态翻转的话，可能输出的`clk_out = clk_1 & clk_2`就能达到近似50%的占空比。在尝试后发现，`clkx`在`cnt`等于`N+M`和`2N`时进行状态翻转，`clky`在`cnt`等于`N`和`M`时进行状态翻转，此时输出的`clk_out = clk_1 & clk_2`近似50%占空比。其中N为不超过分频系数的最大整数，如5.5分频时`N=5`，当N为奇数时`M=(N-1)/2`，当N为偶数时`M=(N+1)/2`\n\n占空比近似50%的4.5分频的波形图如下所示\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232041417.png)\n\n**半整数分频器代码**\n\n```verilog\n`timescale 1ns/1ns\nmodule clk_div_half #(\n    parameter N = 5             //5.5分频时N=5,以此类推\n) (\n    input wire clk,\n    input wire rstn,\n    output wire clk_div\n);\n\n    //localparam M = 0;                                           //占空比非50%，高电平仅有半周期\n    localparam M = N[0] ? ((N - 1) >> 1) : ((N + 1) >> 1);        //占空比近似50%\n    reg [31:0] cnt;\n    reg clkx,clky;\n\n    always @(posedge clk or negedge rstn) begin\n       if(~rstn) begin\n           cnt <= 32'd0;\n       end\n       else if(cnt == (N<<1)) begin\n           cnt <= 32'd0;\n       end\n       else begin\n           cnt <= cnt + 1'b1;\n       end\n    end\n\n    always @(posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            clkx <= 1'b0;\n        end\n        else if(cnt == N + M) begin\n            clkx <= 1'b0;\n        end\n        else if(cnt == (N << 1))begin\n            clkx <= 1'b1;\n        end\n    end\n\n    always @(negedge clk or negedge rstn) begin\n        if(~rstn) begin\n            clky <= 1'b0;\n        end\n        else if(cnt == N) begin\n            clky <= 1'b1;\n        end\n        else if(cnt == M) begin\n            clky <= 1'b0;\n        end\n    end\n\n    assign clk_div = clkx & clky;\n    \nendmodule\n```\n\n## 小数分频器\n\n以8.7分频为例来分析小数分频器的设计。因为无法用计数器表示0.7这种数字，所以我们用一个等效的概念来实现8.7分频，原时钟87个周期的总时间等于分频后的时钟10个周期的总时间。\n\n因为8.7分频在8分频和9分频之间，所以我们用8分频和9分频来组合生成8.7分频的时钟。可以列方程组，设8分频共x个周期，9分频共y个周期，则\n\n- x+y=10\t\t\t\t\t(1)\n- 8*x + 9 *y = 87\t  (2)\n\n解得x=3，y=7。\n\n即通过3次8分频和7次9分频可得到8.7分频。但如果是按序先输出3个8分频再输出7次9分频的时钟用处不大，我们还得乱序**使其均匀输出，不然会造成时钟频率均匀性不好，相位抖动大的问题**。\n\n此处我们介绍脉冲删除小数分频，该方法相对比较简单。什么意思呢？就是说我在87个输入时钟里删掉77个时钟周期，这样不就输出了10个时钟周期了吗？也就实现了8.7分频，那么该怎么删呢？查阅论文后得到结论：\n\n1. 设置寄存器cnt位宽自定，初始值为0；\n2. 在`clk`的上升沿`cnt=cnt+分母`，并判断`cnt`是否大于分子，若大于分子则在下一周期减去分子；\n3. `cnt`小于分子时，输出脉冲信号为0，`cnt`大于分子时，输出脉冲信号为1；\n\n说起来比较乱，我们以7/3分频为例来看\n\n| 时钟序号 |   cnt   | 输出脉冲 |\n| :------: | :-----: | :------: |\n|    0     |    3    |    0     |\n|    1     |    6    |    0     |\n|    2     |    9    |    1     |\n|    3     | (12->)5 |    0     |\n|    4     |    8    |    1     |\n|    5     | (11->)4 |    0     |\n|    6     | (7->)0  |    1     |\n\n从表中可以看到每7个周期输出3个脉冲，刚好满足分频要求。\n\n**小数分频器代码**\n\n```verilog\n`timescale 1ns/1ns\nmodule clk_div_decimal #(\n    parameter fraction = 16'd87,       //分频的分子\n    parameter denominator = 16'd10,    //分频的分母\n    parameter cnt_width = 8            //计数器的位宽\n) (\n    input wire clk,\n    input wire rstn,\n    output reg clk_out\n);\n\n    reg [cnt_width-1:0] cnt;\n    always @(posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            cnt <= 0;\n            clk_out <= 1'b0;\n        end\n        else if(cnt < fraction) begin\n            cnt <= cnt + denominator;\n            clk_out <= 1'b0;\n        end\n        else begin\n            cnt <= cnt + denominator - fraction;\n            clk_out <= 1'b1;\n        end\n    end\n    \nendmodule\n```\n\n8.7分频结果如下\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232042586.png)\n\n3.25分频结果如下\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232042675.png)\n\n## PLL分频\n\n这里就给大家简单介绍一下如何在Vivado中对PLL进行例化。\n\n首先打开`vivado`，新建一个RTL项目，点击`Flow Navigator`窗口中的`IP Catalog`，在`search`处搜索自己想要的IP核的名字，例如输入`clock`就会找到`Clocking Wizard`这个IP核，如下图所示\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045234.png)\n\n双击Clocking Wizard 这个IP核，就能弹出配置窗口；我们简单配置一些信息，输入时钟为100MHz，分频输出两个时钟，一个是30MHz，一个是18MHz，查看分频效果；\n\n![13](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045483.png)\n\n![14](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045206.png)\n\n点击Generate,生成IP核，然后在source窗口就会出现一个文件\n\n![15](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045112.png)\n\n![16](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045177.png)\n\n下面对这个生成的IP进行例化，测试分频效果\n\n![17](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232045911.png)\n\n将这个例化模块的例程添加到自己的顶层仿真代码中，就可以查看分频结果了。\n\n------\n\n本次的博客就讲到这里，其中PLL的使用讲的很浅显，大家要想深入学习PLL的IP使用的话可以学习官方文档。若文章中存在任何错误或不足欢迎大家指正，欢迎大家在博客下方留言交流。","tags":["Basics"],"categories":["IC","Basics"]},{"title":"为什么D触发器需要建立时间和保持时间","url":"/2022/09/29/IC/Basic/为什么D触发器需要建立时间与保持时间/","content":"\n# 为什么D触发器需要建立时间与保持时间\n\n## 定义\n\n**建立时间**：时钟有效沿到来之前的某段时间内，数据必须稳定，这段时间称为建立时间，用Tsetup或者Tsu表示。\n\n**保持时间**：时钟有效沿到来之后的某段时间内，数据必须稳定，这段时间成为保持时间，用Thold或者Th表示。\n\n时序图如下\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048432.png)\n\n## 为什么需要建立时间和保持时间\n\n[从CMOS到建立时间和保持时间](https://zhuanlan.zhihu.com/p/120863919)这篇文章里作者已经讲的很详细了，我就不再赘述锁存器的原理了，大家有疑问的话可以先去看看这篇文章，这里我只简单举例记录一下我个人对建立时间和保持时间的理解。\n\n我们从D触发器的门级电路开始分析，D触发器的门级电路如下：\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048337.png)\n\nD触发器在时钟(上升)边沿进行数据的锁存。我们这里假设原来的输出是1，即从锁存器锁存的数据为1，要锁存的数据是0，来理解建立时间和保持时间。\n\n要让时钟上升沿之后Q输出为0，即让从锁存器的输出变为0，也就是要让主锁存器在时钟上升沿之后稳定地锁存住0。\n\n总结而言，**在上升沿到来及到来之后，主锁存器负责锁存数据，而从锁存器负责传输主锁存器所锁存好的数据。**这样一来，我们重点分析**主锁存器**即可。\n\n主锁存器的门级电路：\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048755.png)\n\n**1、如果数据的建立时间不足，会发生什么？**\n\n按我们的假设，也就是数据(0)相对于时钟上升沿来的晚了。假设在T=0ns的时候，clk从0变成1(为方便分析，假设时钟理想无跳变延时)。我们假设一个数据D1=0在T=-0.7ns(即比时钟上升沿提前0.7s)的时候到达数据的端口，然后另一个数据D2=0在T=-0.3ns的时候才来到数据端口(即D1来得早，而D2来得比较晚不满足建立时间的要求)。我们看看D1的路线，首先经过反相器变为1，然后经过与门(此时时钟还是低电平，该与门的另一个输入为1)变成1，经过或非门之后，将输出Q变成了0。\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048629.png)\n\n但**此时主锁存器输出的Q还不稳定，需要通过反馈改变或非门的输入才能保持输出数据的稳定。**如下图所示，通过反馈使得自己或非门的输入为1才能维持Q的稳定，需要`t1+t2+t3`的时间。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048942.png)\n\n我们再回过头看D2这个数据，它提前于时钟沿的时间不多，刚经过与门时钟沿就来了，**没有成功通过反馈到达或非门的输入**，不能稳定锁存住从锁存器要锁存的0值，这就是建立时间不足引起的锁存不住值导致亚稳态的原因。\n\n**2、如果数据的保持时间不足，会发生什么？**\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232048433.png)\n\n我们看保持时间仍要从主锁存器这边看：\n\n假设T=0时刻时钟Clk发生从0->1的上升沿跳变，Clk的高电平信号首先要经过反相器变成0信号后传到后面的与门，如上图绿线所示路径，假设该路径延迟时间为t2，也就是说t2时刻与门的输入就为低电平0，那么在t2时刻之前，与门的Clk输入端始终保持高电平1。\n\n在t2之前，如果输入端D发生跳变(按我们的假设，从0变为1，即数据的保持时间不足)，变换后的数据端高电平经过t1延迟时间后(上图蓝线所示路径)，到达与门的另一个输入端。\n\n一般情况下，由于时钟信号需要经过反相器，所以`t2>t1`，**那么与门的输出在t1~t2时刻之间的时候输出为1。**也就是SR锁存器的置位端为1，这会导致Q=1，这与我们要锁存的0值不同，导致亚稳态的出现。\n\n## 总结\n\n**建立时间：在时钟上升沿到来之前主锁存器将数据稳定锁存所需的时间。**\n\n**保持时间：在时钟上升沿到来之后主锁存器传输门关断至锁存数据的时间。**\n\n","tags":["Basics"],"categories":["IC","Basics"]},{"title":"Ubuntu开发环境打造","url":"/2022/09/23/Misc/Ubuntu开发环境打造/","content":"\n# Ubuntu开发环境打造\n\n\n\n## 安装ubuntu18.04\n\n下载：\n\n>   https://mirrors.tuna.tsinghua.edu.cn/\n\n\n\n## 配置清华软件源\n\n> https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/\n\n\n\n## 双系统时间不同步问题\n\n```\ntimedatectl set-local-rtc 1 --adjust-system-clock\n```\n\n\n\n## 安装Synaptic包管理器\n\n``` \nsudo apt-get install synaptic\n```\n\n\n\n## 安装编译开发环境\n\n```\nsudo apt-get install build-essential\n```\n\n\n\n## Home下目录改成英文\n\n```\n$ export LANG=en_US\n\n$ xdg-user-dirs-gtk-update\n\n这个时候会弹出一个配置界面，提示是否将中文目录切换为英文目录。选中不再提示，确定\n\n最后再执行如下命令还原到系统之前的设置\n$ export LANG=zh_CN\n```\n\n\n\n## 安装并配置VS Code\n\n下载安装包\n\n> https://code.visualstudio.com/\n\n安装\n\n```\ndpkg -i [安装包文件名]\n```\n\n启动\n\n```\ncode\n```\n\n以超级用户启动\n\n```\nsudo code --user-data-dir=\"/home/wg/.vscode/\"\n```\n\n安装插件\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232124452.png)\n\n## Ubuntu安装pytorch\n\n版本：python3.6.9\n\n安装pip\n\n```\nsudo apt-get install python3-pip\n```\n\n更换阿里源\n修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：\n\n```\n[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n```\n\n升级pip\n\n```\nsudo pip3 install --upgrade pip\n```\n\n安装常用包\n\n```\npip3 install numpy\npip3 install opencv-python\npip3 install torch\npip3 install torchvision\n```\n\n下载离线安装包\ntorch\ttorchvision\t   python\t                cuda\n\n1.5.1\t0.6.1\t       >=3.6\t                9.2, 10.1,10.2\n\n1.5.0\t0.6.0\t       >=3.6\t                9.2, 10.1,10.2\n\n1.4.0\t0.5.0\t       ==2.7, >=3.5, <=3.8\t    9.2, 10.0\n\n1.3.1\t0.4.2\t       ==2.7, >=3.5, <=3.7\t    9.2, 10.0\n\n1.3.0\t0.4.1\t       ==2.7, >=3.5, <=3.7\t    9.2, 10.0\n\n1.2.0\t0.4.0\t       ==2.7, >=3.5, <=3.7\t    9.2, 10.0\n\n1.1.0\t0.3.0\t       ==2.7, >=3.5, <=3.7\t    9.0, 10.0\n\n<1.0.1\t0.2.2\t       ==2.7, >=3.5, <=3.7\t    9.0, 10.0\n\n```\nsudo pip install torch-1.4.0-cp36-cp36m-linux_x86_64.whl\nsudo pip install torchvision-0.5.0-cp36-cp36m-linux_x86_64.whl\n```\n\n\n\n## 安装Vivado 2018.2\n\n下载安装包\n\n> https://china.xilinx.com/support/download.html\n\n解压\n\n```\ntar xvzf xxx.tar.gz\n```\n\n执行安装\n\n```\nsudo ./xsetup\n```\n\n安装路径选择默认\n\n安装JTAG驱动\n\n```\ncd /opt/Vivado/2018.2/data/xicom/cable_drivers/lin64/install_script/install_drivers/\nsudo ./install_drivers\n```\n\n设置环境变量\n\n```\nsudo gedit .bashrc\n```\n\n添加命令别名\n\n```\nalias svvd='source /opt/Xilinx/Vivado/2018.2/settings64.sh'\n```\n\n启动\n\n```\n#启动Vivado\n$ vivado\n\n#启动Vivado HLS\n$ vivado_hls\n\n#启动XSDK\n$ xsdk\n```\n\n\n\n## 安装SSH服务并开机自启\n\n```\nsudo apt-get install openssh-server\nsudo systemctl enable ssh\nsudo systemctl status ssh\n```\n\n\n\n## 安装GHex\n\n```shell\nsudo apt-get install ghex\n```\n\n\n\n## 安装Typora\n\n> https://typora.io/#linux\n\n```shell\n# or run:\n# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n\n# add Typora's repository\nsudo add-apt-repository 'deb https://typora.io/linux ./'\nsudo apt-get update\n\n# install typora\nsudo apt-get install typora\n```\n\n\n\n## 安装坚果云（NutStore）\n\n> https://www.jianguoyun.com/s/downloads/linux\n\n```\nsudo dpkg -i nautilus_nutstore_amd64.deb\nsudo apt-get install -f\n```\n\n\n\n## 安装网易云音乐\n\n> https://music.163.com/#/download\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232125711.png)\n\n```\nsudo dpkg -i xxx.deb\n```\n\n\n\n## 安装FlameShot\n\n下载安装包\n\n> https://github.com/lupoDharkael/flameshot/releases\n\nrpm包是yum的安装文件，.deb包才是Ubuntu安装包\n\n- bionic：Ubuntu18.04的版本名\n\n- jessie：Debian8.6版本的版本名\n\n- stretch：Debian9的版本名\n\n```shell\ndpkg -i flameshot_0.6.0_bionic_x86_64.deb\n```\n\n创建截图快捷键\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232125490.png)\n\n## 破解安装Beyond Compare\n\n> http://www.scootersoftware.com/download.php\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232125626.png)\n\n下载64位的.deb包，\n\n```\ndpkg -i [安装包文件名]\n```\n\n**破解**\n\n```\n转到安装路径：\ncd /usr/lib/beyondcompare/\n```\n\n```\nsudo sed -i \"s/keexjEP3t4Mue23hrnuPtY4TdcsqNiJL-5174TsUdLmJSIXKfG2NGPwBL6vnRPddT7tH29qpkneX63DO9ECSPE9rzY1zhThHERg8lHM9IBFT+rVuiY823aQJuqzxCKIE1bcDqM4wgW01FH6oCBP1G4ub01xmb4BGSUG6ZrjxWHJyNLyIlGvOhoY2HAYzEtzYGwxFZn2JZ66o4RONkXjX0DF9EzsdUef3UAS+JQ+fCYReLawdjEe6tXCv88GKaaPKWxCeaUL9PejICQgRQOLGOZtZQkLgAelrOtehxz5ANOOqCaJgy2mJLQVLM5SJ9Dli909c5ybvEhVmIC0dc9dWH+/N9KmiLVlKMU7RJqnE+WXEEPI1SgglmfmLc1yVH7dqBb9ehOoKG9UE+HAE1YvH1XX2XVGeEqYUY-Tsk7YBTz0WpSpoYyPgx6Iki5KLtQ5G-aKP9eysnkuOAkrvHU8bLbGtZteGwJarev03PhfCioJL4OSqsmQGEvDbHFEbNl1qJtdwEriR+VNZts9vNNLk7UGfeNwIiqpxjk4Mn09nmSd8FhM4ifvcaIbNCRoMPGl6KU12iseSe+w+1kFsLhX+OhQM8WXcWV10cGqBzQE9OqOLUcg9n0krrR3KrohstS9smTwEx9olyLYppvC0p5i7dAx2deWvM1ZxKNs0BvcXGukR+/g\" BCompare\n```\n\n然后打开Beyond Conpare，弹出Trial Mode Error！弹窗\n\n单击右下角按钮“Enter Key”，输入以下秘钥【注意：包括开始和结尾的横线行】\n\n```\n--- BEGIN LICENSE KEY ---\nGXN1eh9FbDiX1ACdd7XKMV7hL7x0ClBJLUJ-zFfKofjaj2yxE53xauIfkqZ8FoLpcZ0Ux6McTyNmODDSvSIHLYhg1QkTxjCeSCk6ARz0ABJcnUmd3dZYJNWFyJun14rmGByRnVPL49QH+Rs0kjRGKCB-cb8IT4Gf0Ue9WMQ1A6t31MO9jmjoYUeoUmbeAQSofvuK8GN1rLRv7WXfUJ0uyvYlGLqzq1ZoJAJDyo0Kdr4ThF-IXcv2cxVyWVW1SaMq8GFosDEGThnY7C-SgNXW30jqAOgiRjKKRX9RuNeDMFqgP2cuf0NMvyMrMScnM1ZyiAaJJtzbxqN5hZOMClUTE+++\n--- END LICENSE KEY -----\n```\n\n破解成功的重要标志\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232126402.png)\n\n务必取消更新检测（否则破解过一段时间就会失效）\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232126083.png)\n\n**破解失效的解决办法**\n\n删除如下的两个文件即可\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232127803.png)\n\n## 安装并配置Synergy\n\n```\nsudo apt install synergy\n```\n\n遇到问题system tray is unavailable, don't close your window，解决：\n\n```bash\nsudo apt-get install sni-qt\n```\n\n> https://vvplus.net/multi-computer-screen-sharing-keyboard-mouse-synergy1-8-8-stable-windows10-mac-linux-download-configuration.html\n\n可用注册码：\n```\n7B76313B70726F3BE5BDAC20E585B33B313B73796E313333323040676D61696C2E636F6D3B3B3B7D\n```\n\n\n\n## 设置开机启动项\n\n```\nsudo apt install gnome-tweak-tool\n```\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232127621.png)\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232128108.png)\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232128032.png)\n\n## 无法识别exfat格式分区\n\n```\nsudo apt install exfat-utils\n```\n\n\n\n## Firefox无法播放bilibili视频\n\n提示未安装flash，实际上是缺少本地解码器，可以通过安装~~mplayer~~解决，（mplayer无界面，转而安装vlc）\n\n```\nsudo apt install vlc\n```\n\n\n\n## vlc无法播放H.264视频\n\n```\nsudo apt-get install ubuntu-restricted-extras\n```\n\n\n\n## 安装搜狗输入法\n\n下载.deb\n\nhttps://pinyin.sogou.com/linux/\n\n安装过程\n\nhttps://pinyin.sogou.com/linux/help.php\n\n安装结束后卸载ibus框架相关组件，只保留fcitx框架\n\n查看日志，搜狗提示libpng12.0.so找不到，（18.04已经安装了libpng16，不能通过apt安装libpng12，只能手动下载deb包安装）\n\n> https://mirrors.ustc.edu.cn/ubuntu/pool/main/libp/libpng/\n\n安装后，搜狗的顶栏图标正常，Xilinx的Docnav也可以打开。\n\n但安装后，出现了两个搜狗输入法的图标，此时对fcitx进行配置，隐藏fcitx的图标。\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232128452.png)\n\n## 解决AIR 14 2020的声音伪输出的问题\n\n本问题可能由于5.4内核对英特尔最新硬件的支持不足导致的。\n\nstep1：对于Ubuntu18.04，升级内核相关的包到最新版本（grub\\*，linux\\*）\n\nstep2：在/etc/modprobe.d/alsa-base.conf添加中\n\n```\noptions snd-hda-intel dmic_detect=0\n或者\noptions snd-intel-dspcfg dsp_driver=1（使用dsp而不是sof）\n```\n\n重启后检查是否有声音，\n\nstep3：重新安装（alsa\\*，不包括alsa-tools等）（pulseaudio\\*）等包，gstreamer1.0-alsa，gstreamer1.0-pulseaudio等包，\n\n重启。\n\n\n\n## 设置GRUB2默认启动操作系统\n\n```\nsudo gedit /etc/default/grub\n```\n\n```\n# 设定默认启动项，推荐使用数字（0代表第1项，1 >0代表第2项的第1子项）\nGRUB_DEFAULT=2\n\n#显示倒计时\nGRUB_TIMEOUT_STYLE=countdown\n\n#超时时间，默认为10秒\nGRUB_TIMEOUT=6\n```\n\n**记得**\n\n```\nsudo update-grub \n```\n\n\n\n## 安装清理工具Bleachbit\n\n```\nsudo apt install bleachbit\n```\n\n\n\n## 安装PDF批注软件Xournal\n\n```\nsudo apt install xournal\n```\n\n\n\n## 安装电子书管理器Calibre\n\n```\nsudo apt install calibre\n```\n\n\n\n## 安装音频编辑软件Audacity\n\n```\nsudo apt install audacity\n```\n\n\n\n## 安装矢量绘图软件Inkscape\n\n```\nsudo apt install inkscape\n```\n\n\n\n## 安装几何画板软件GeoGebra\n\n```\nsudo apt install geogebra\n```\n\n\n\n## 安装科学计算软件Octave\n\n```\nsudo apt install octave\n```\n\n\n\n## 安装utools插件框架\n\n> https://u.tools/\n\n```\nsudo dpkg -i xxx.deb\n```\n\n安装下面的插件\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232129296.png)\n\n## 破解安装Xmind\n\n下载补丁（app.asar），\n\n> https://www.ghpym.com/xmindzen.html\n\n安装官方程序，\n\n> https://www.xmind.cn/download/\n\n然后进入程序目录/opt/XMind ZEN/XMind/resources\n替换此目录的app.asar 文件即可\n\n![13](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232129487.png)\n\n## 安装VMware\n\n> https://www.vmware.com/go/downloadworkstation\n\n```\nsudo sh ./VMware-Workstation-Full-15.5.6.x86_64.bundle\n```\n\n显示Successful则成功\n\n\n\n## 安装Gnome Shell插件\n\n打开Gnome软件中心，选择附加组件，\n\n![14](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232130975.png)\n\n已安装：\n\n- Bing wallpaper\n- Workspace indicator\n- NetSpeed\n\n在这里进行管理，\n\n![15](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232130925.png)\n\n## 屏蔽邮件服务程序的开机自启\n\n```\nsystemctl --user mask evolution-addressbook-factory.service evolution-calendar-factory.service evolution-source-registry.service\n```\n\n\n\n## 查看dpkg安装日志\n\n```\ngrep \"\\ install\\ \" /var/log/dpkg.log\n```\n\n\n\n## 安装Windows字体\n\n从Windows系统中找到相应字体文件；\n\n```\nsudo mkdir /usr/share/fonts/truetype/windows-font\n```\n\n拷贝字体到Windows目录下\n\n```\nsudo chmod -R 777  /usr/share/fonts/truetype/windows-font\ncd /usr/share/fonts/truetype/windows-font\nmkfontscale\nmkfontdir\nfc-cache -fv\n```\n\n\n\n## 配置科学上网（科技熊、光速云）\n\n> https://kejibearstudio.tk/\n\n> https://kejibearstudio.tk/user/tutorial?os=linux&client=clash\n\n下载clash的二进制文件\n\nhttps://github.com/Dreamacro/clash/releases\n\n下载机场的配置文件\n\n```\n光速云\nwget -O gsy-config.yaml \"https://136900.xyz/link/glLP6b5aqiOxa6Xg?clash=1&log-level=info\"\n\n科技熊\nwget -O kjx-config.yaml \"https://service-6wrorr47-1254266595.sh.apigw.tencentcs.com/link/MKKO2wk7drvLpKrp?clash=1&log-level=info\"\n```\n\n对于光速云\n\n需要修改`gsy-config.yaml`\n\n```\n删除 trojan 测试 项\n```\n\n执行\n\n```\n./clash  -d .  -f gsy-config.yaml\n```\n\n> Usage of ./clash:\n>   -d string\n>     \tset configuration directory\n>   -ext-ctl string\n>     \toverride external controller address\n>   -ext-ui string\n>     \toverride external ui directory\n>   -f string\n>     \tspecify configuration file\n>   -secret string\n>     \toverride secret for RESTful API\n>   -t\ttest configuration and exit\n>   -v\tshow current version of clash\n\n使用浏览器访问\n\nhttp://clash.razord.top/#/proxies\n\n打开系统代理\n\n打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 `127.0.0.1:7890`，填写 Socks 主机为 `127.0.0.1:7891`，即可启用系统代理。\n\n![16](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232130527.png)\n\n设置开机启动\n\n```\nsh -c \"(sleep 15 && cd /home/kopera/Tools/ && clash -d . -f gsy-config.yaml)\"\n```\n\n\n\n## GNOME3安装主题与图标包\n\n**theme**：控制窗口样式\n\n**shell theme**：控制顶栏样式（可以不启用）\n\n> https://www.pling.com/p/1334194/\n\n在`home`下建立`.themes`文件夹，放入下载的主题包后，从gnome-tweak-tool中选择\n\n**icon theme**：控制图标样式\n\n> https://www.pling.com/p/1279924/\n\n在`home`下建立`.icons`文件夹，放入下载的图标包后，从gnome-tweak-tool中选择\n\n\n\n## 安装Foxit Reader阅读器\n\n> https://www.foxitsoftware.cn/\n\n![17](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232131679.png)\n\n![18](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232131998.png)\n\n下载`.run`文件，使用sudo权限安装至`/opt/Foxit`下\n\n\n\n## 安装CopyTranslator\n\n> https://github.com/CopyTranslator/CopyTranslator/releases\n\n\n\n## 安装balenaEtcher\n\n> https://www.balena.io/etcher/\n>\n> https://github.com/balena-io/etcher/releases\n\n\n\n## 安装Free Download Manager\n\n> https://www.freedownloadmanager.org/zh/download-fdm-for-linux.htm\n\n\n\n## 基于VScode+Vivado的HDL仿真环境\n\n安装插件：\n\n![19](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133836.png)\n\n配置插件：\n\n![20](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133328.png)\n\n修改插件源码（以支持linux并且去掉无效功能）\n\n![21](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133204.png)\n\n![22](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133260.png)\n\n修改插件源码（修改生成样式）\n\n![23](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232133268.png)\n\nMakefile\n\n```makefile\n#指定综合的顶层模块\nSYNTH_TOP = pc\n\n#指定仿真的顶层模块\nSIM_TOP = $(SYNTH_TOP)_tb\n\n#指定新建工程的序号\nINDEX = $(N)\n\n#指定坚果云同步目录\nCur_Dir = $(shell basename `pwd`)\nNut_Path = /home/wg/Nutstore\\ Files/我的坚果云/Coding/Verilog\n\n#新建文件\ncreate:\n\ttouch src/$(SIM_TOP).v\n\ttouch src/$(SYNTH_TOP).v\n\n#编译\nbuild:\n\tmkdir batch_sim\n\tcd batch_sim && xvlog --work mylib ../src/*.v\n\tcd batch_sim && xelab --debug typical -s simTest mylib.$(SIM_TOP)\n\n#首次仿真（Batch Mode）\nfirst:\n\tcd batch_sim && xsim simTest -gui -wdb wave_data.wdb\n\n#仿真（带波形配置）\ntest:\n\tcd batch_sim && xsim simTest -gui -wdb wave_data.wdb -view ../wave_config.wcfg\n\n#清空输出\nclean:\n\trm -r batch_sim vvd_prj\n\n#调试（Project Mode）\ndebug:\n\tmkdir vvd_prj\n\tcd ./vvd_prj && vivado -mode tcl -source ../run_sim.tcl -tclargs $(SIM_TOP) $(SYNTH_TOP)\n\n#启动Vivado工程\nlaunch:\n\tcd ./vvd_prj && vivado debug_prj.xpr\n\n#另存工作空间\nnew_prj:\n\tmkdir ../demoT_$(INDEX)\n\tcp -r src ../demoT_$(INDEX)\n\tcp Makefile run_sim.tcl ../demoT_$(INDEX)\n\t\n#推送坚果云\npush_Nut:\n\tmkdir $(Nut_Path)/$(Cur_Dir)\n\tcp -r src $(Nut_Path)/$(Cur_Dir)\n\tcp Makefile run_sim.tcl $(Nut_Path)/$(Cur_Dir)\n```\n\nTcl脚本\n\n```tcl\nset sim_top [lindex $argv 0]\nset synth_top [lindex $argv 1]\n\ncreate_project debug_prj\n\nadd_files -fileset sources_1 -norecurse [glob ../src/*.v]\n\nset_property top $synth_top [current_fileset]\nupdate_compile_order -fileset [current_fileset]\n\nset_property top $sim_top [get_filesets sim_1]\nupdate_compile_order -fileset sim_1\n\nset_property -name {xsim.simulate.runtime} -value {30ns} -objects [get_filesets sim_1]\nlaunch_simulation -mode behavioral\nstart_gui\n```\n\n# 致谢\n\n感谢舍友老王的倾力支持\n","tags":["Ubuntu"],"categories":["Misc","Ubuntu"]},{"title":"我的实习小结","url":"/2022/09/12/Interview/实习小结/","content":"\n# 我的实习小结\n\n## 字节跳动\n\n字节跳动开始的比较早，在2月中旬的时候开放投递。我是2月20日晚投递简历，2月21日<u>简历挂</u>，反馈很快。跟内推的字节师兄交流后发现，是我投递的上海部门那边不缺人，所以直接简历挂。然后师兄帮我转日常实习，base北京，算是被捞了。\n\n![图5.png](https://img-blog.csdnimg.cn/img_convert/b74ce162cb73e504052ff197613ce9c2.png)\n\n重新简历评估后，2月23日约我，3.1一面，3.8二面，3.17三面，3.28hr面，3.30offer call。\n\n### 一面技术面（3.1）\n\n1、面试官一上来给我简要介绍了面试的流程，自我介绍5-10min左右，剩下的话是基础知识考核+撕题。（有点慌，没有问一点项目，可能是项目不对口）\n\n2、第一题是简要介绍一下功耗的定义，有哪些降功耗的方式？\n\n3、第二题是两个Reg之间经典的时序分析，逐步加入skew、jitter等因素，写出建立时间和保持时间的计算公式，询问time borrow的概念；\n\n4、撕一道DDS的题。\n$$\ny=sin(\\frac{\\pi}{128}*x)+x\n$$\nx的范围是[0,255]；\n\n1）y的范围，定点数，16位宽的话小数点的位置；2）实现思路；3）RTL code；\n\n最后一题撕的时间有点长，最后也没完整撕出来，不过思路大致给面试官说明白了。整个一面大约用时1h左右。\n\n### 二面技术面（3.8）\n\n1、自我介绍，从本科到硕士的项目和科研经历；\n\n2、项目中跨时钟域部分的处理；\n\n3、异步FIFO中binary转gray的原因；\n\n4、multicycle和max delay的区别；\n\n5、单bit信号要跨时钟域并进行取反操作，问反相器放置的位置；\n\n6、异步复位、同步复位的优缺点；\n\n7、异步复位同步释放的做法；\n\n8、对芯片工艺和频率的一些讨论；面试官认为40nm工艺可以跑更高的时钟频率；\n\n9、简单介绍一下AXI协议，协议转换如何做；\n\n10、介绍一下AXI中的outstanding功能；\n\n11、源同步输出的时序约束；\n\n12、问一下项目的代码量；\n\n13、最后撕一道题，在一段数据序列中找最大次大值；\n\n### 三面技术面（3.17）\n\n面试官在美国，约了早8点的面试，年龄比较大，面试官很和蔼，有什么不明白的地方也会循循善诱，引导你讲出来，面试体验很好。首先寒暄了一下，没有让自我介绍，问了一下实习时间，实习地点，询问一下职业规划。最后评价说书本知识掌握的不错，但还不够深究，希望以后在实习中继续加深理解。整体流程大概25min\n\n1、SRAM、DRAM的区别；\n\n2、DRAM为什么需要动态刷新？\n\n3、介绍一下功耗；\n\n4、以DRAM为例解释一下静态功耗；\n\n5、方波怎么得到正弦波？\n\n6、时钟经过一段路径会失真吗？为什么？\n\n7、二分频电路；\n\n8、环路振荡器；\n\n9、了解Power Domain吗？\n\n### 四面HR面（3.28）\n\n1、对实习地点是否有要求？是否有倾向性？\n\n2、秋招还会考虑其他公司吗？\n\n3、别人对你的评价？有哪些事例证明？\n\n4、确认实习时间；\n\n5、工作内容，方向确认；\n\n## 乐鑫科技\n\n乐鑫科技的领跑者计划在21年12月就开始了，然后网上说去年的面试体验不是很好，**自己亲身体验了一下发现面试体验非常非常好**，非常推荐各位同学投递。2.28简历投递，3.1通知笔试，3.7完成笔试，3.14一面技术面，3.21二面HR面，3.24offer call。\n\n### 一面技术面（3.14）\n\n乐鑫面试的风格与字节完全不同，紧紧围绕项目，主要询问TW二号项目，大部分是我讲面试官听，问的问题也是项目强相关，这里主要记录一下面试官的关注的点；\n\n1、系统最大吞吐率，工作模式有哪些；\n\n2、组帧、组包的必要性；\n\n3、接口信号的介绍；\n\n4、跨时钟域的方式；\n\n5、FIFO深度的设计，是否有流控机制。\n\n6、FIFO会溢出吗？如果不会是如何保证的？如果会的话如何应对？\n\n7、航空航天领域如何抗单粒子翻转？\n\n8、ASIC项目是如何验证的？\n\n9、自己会做一些综合看面积吗？面积有要求吗？\n\n10、简要介绍一下低功耗的方法，自己在ASIC项目中用到了哪些低功耗方式？\n\n11、设计ASIC时有没有考虑插门控时钟，门控时钟有哪几种方式？\n\n### 二面HR面（3.21）\n\n乐鑫的HR看着比较年轻，比我们大不了几岁，上来寒暄了一会。\n\n1、简单的自我介绍；\n\n2、询问学习教育经历；\n\n3、你觉得数字IC设计的最重要的三点能力，你哪点比较擅长，哪点比较不足？\n\n4、为什么选择数字IC？是父母做的决定吗？\n\n5、你想象中二十年后的你是什么样的角色？\n\n6、参与那么多竞赛有什么收获？\n\n7、现在有明确的职业规划吗？\n\n反问：\n\n1、后续的面试流程；（如果切换base的话会加主管面）\n\n2、去年网上乐鑫的面试过程评价不高，今年的面试体验很好，公司是否做了相应调整，及时倾听应届生反馈？\n\n**乐鑫今年的面试体验巨巨巨巨巨好**，我字节的HR面在乐鑫Offer的截止日期之前，在与HR说明情况后HR能帮忙延迟一下签Offer的时间。最后没有签HR也会打电话跟你确认，还给秋招直通终面的机会，总之**体验非常不错，墙裂推荐！！！**\n\n---\n\n4.7日更新一波阿平面经\n\n## 平头哥\n\n### 一面技术面（3.30）\n\n我觉得平头哥的面试官比较在意的是你项目中的亮点，这是我面试中收获比较大的一点。项目不要上来就深入细节，面试官应该也不是很care，**上来把项目框架介绍完之后直接给面试官介绍亮点即可**，面试官也可以通过你总结的亮点大概摸清你的技术深度这样。\n\n问题主要是紧紧围绕项目展开的，大家仅做参考即可，八股比较少：\n\n1、ASIC与FPGA功能划分的依据；\n\n2、ASIC的验证是怎么做的？\n\n3、关注TW2项目中的数据反压，时钟复位信号的生成；\n\n4、项目中FIFO深度的设置依据；\n\n5、跨复位域的一些问题，复位的释放顺序等；\n\n6、Verilog的四值逻辑，仿真中使用什么语法可以使X态进行传播；\n\n### 二面技术面（4.7）\n\n二面被安排在上午9点，面试官应该在海外，然后整体交流过程中夹带英文比较多，有的时候我可能听不太懂。我面的组是做GPGPU的，整体流程与上面类似，问题也与上面类似，主要记录一下问的不同的点：\n\n1、时钟级联的难点及必要性；\n\n2、源同步输入/输出的时序约束，实现方法；如何保证时钟与数据的偏移关系？\n\n3、ASIC与FPGA功能的划分原因？ASIC的验证方式是什么？\n\n4、设计可靠性是如何保障的？\n\n5、数据反压是如何做的？\n\n反问：公司内部对HLS工具是什么看法？答：使用起来很保守，Debug不便，或许过几年成熟了才会大规模使用；\n\n## 其他公司\n\n奕斯伟我是2.20申请，直到3.28那边才有工作人员打电话跟我确认时间，那边要求实习时间6个月，保证之后安排面试，这个实习时间我是达不到要求的，于是拒之；\n## 待补充\n今年实习开始的早，结束的也早，后续应该不会再投递其他公司的实习了，没有集邮的兴趣，秋招再说。","tags":["interview"],"categories":["interview"]},{"title":"HDLBits答案汇总","url":"/2022/09/12/IC/HDLBits/HDLBits答案汇总/","content":"\n# 前言\n\n该博客为本人做HDLBits习题时的心得记录总结，欢迎大家一起交流进步。\n\n[HDLBits网站链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n## Verilog Language\n\n[Basics](https://david-luge.cn/2022/09/02/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(1)_Verilog%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/)\n\n[Vectors](https://david-luge.cn/2022/09/03/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(2)_Verilog%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80/)\n\n[Modules:Hierarchy](https://david-luge.cn/2022/09/03/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(3)_Verilog%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BE%8B%E5%8C%96%E4%B8%8E%E8%B0%83%E7%94%A8/)\n\n[Procedures](https://david-luge.cn/2022/09/03/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(4)_%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E6%88%90%E9%94%81%E5%AD%98%E5%99%A8/)\n\n[More Verilog Features](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(5)_Generate%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9D%97/)\n\n## Circuits\n\n### Combinational Logic\n\n[Basic gates](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(6)_%E7%A1%AC%E4%BB%B6%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/)\n\n[Multiplexers](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(7)_Verilog%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8/)\n\n[Arithmetic Circuits](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(8)_Verilog%E5%8D%8A%E5%8A%A0%E5%99%A8%E3%80%81%E5%85%A8%E5%8A%A0%E5%99%A8%E5%92%8C%E8%A1%8C%E6%B3%A2%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/)\n\n[Karnaugh Map to Circuit](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(9)_%E5%8D%A1%E8%AF%BA%E5%9B%BE%E4%B8%8E%E6%9C%80%E7%AE%80SOP%E5%BC%8F/)\n\n### Sequential Logic\n\n[Latches and Flip-Flops](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(10)_D%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D%E3%80%81%E8%84%89%E5%86%B2%E8%BE%B9%E6%B2%BF%E6%A3%80%E6%B5%8B/)\n\n[Counters](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(11)_Verilog%E8%AE%A1%E6%95%B0%E5%99%A8/)\n\n[Shift Registers](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(12)_Verilog%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/)\n\n[More Circuits](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(13)_Verilog%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E9%99%84%E5%8A%A0%E9%A2%98/)\n\n#### Finite State Machines\n\n[Simple FSM 1—Simple state transitions 3](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(14)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(1)/)\n\n[Simple one-hot state transitions 3—Design a Moore FSM](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(15)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(2)/)\n\n[Lemmings 1-4](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(16)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(3)/)\n\n[One-hot FSM—PS/2 packet parser and datapath](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(17)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(4)/)\n\n[Serial receiver—Serial receiver with parity checking](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(18)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(5)/)\n\n[Q8—Q5b](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(19)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(6)/)\n\n[Q3a—Q6](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(20)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(7)/)\n\n[Q2a—Q2b](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(21)_Verilog%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA(8)/)\n\n[Building Larger Circuits](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(22)_%E5%9F%BA%E4%BA%8E%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8/)\n\n## Verification:Reading Simulations\n\n[Finding bugs in code](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(23)_%E6%89%BEBUG/)\n\n[Build a circuit from a simulation waveform](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(24)_%E7%94%B1%E6%B3%A2%E5%BD%A2%E5%9B%BE%E6%8F%8F%E8%BF%B0%E7%94%B5%E8%B7%AF/)\n\n[Verification:Writing Testbenches](https://david-luge.cn/2022/09/12/IC/HDLBits/HDLBits%E7%AD%94%E6%A1%88(25)_%E7%BC%96%E5%86%99Testbench/)","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(25)_编写TestBench","url":"/2022/09/12/IC/HDLBits/HDLBits答案(25)_编写Testbench/","content":"\n# 编写TestBench\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新HDLBits最后一章的习题：编写Testbench。\n\n------\n\n## 题库\n\n### Clock\n\n提供了如下描述的模块：\n\n```verilog\nmodule dut ( input clk ) ;\n```\n\n要求传入频率为10ps的时钟，初始为0，如下图所示。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232209621.png)\n\n**Solution**：\n\n```verilog\nmodule top_module ();\n\n    reg clk;\n    initial begin\n        clk = 1'b0;\n    end\n    always #5 clk = ~clk;\n    \n    dut u0(clk);\n    \nendmodule\n```\n\n### Testbench 1\n\n产生如下图所示的A,B激励。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232209771.png)\n\n**Solution**：\n\n```verilog\nmodule top_module ( output reg A, output reg B );//\n\n    // generate input patterns here\n    initial begin\n\t\tA = 1'b0;\n        B = 1'b0;\n        #10 A = 1'b1;\n        #5 B = 1'b1;\n        #5 A = 1'b0;\n        #20 B = 1'b0;\n    end\n\nendmodule\n```\n\n### AND gate\n\n写测试激励测试and模块，波形图如下图所示。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232209459.png)\n\n提供的AND模块声明如下：\n\n```verilog\nmodule andgate (\n    input [1:0] in,\n    output out\n);\n```\n\n**Solution**：\n\n```verilog\nmodule top_module();\n\n    reg in_0,in_1;\n    reg out;\n    \n    initial begin\n        in_0 = 1'b0;\n        in_1 = 1'b0;\n        #10 in_0 = 1'b1;\n        #10 \n        in_0 = 1'b0;\n        in_1 = 1'b1;\n        #10 in_0 = 1'b1;\n    end\n    \n    andgate u0(.in({in_1,in_0}),.out(out));\n    \nendmodule\n```\n\n### Testbench 2\n\n产生如下图波形图所示的激励信号，激励模块q7；\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232209501.png)\n\n模块q7的描述如下：\n\n```verilog\nmodule q7 (\n    input clk,\n    input in,\n    input [2:0] s,\n    output out\n);\n```\n\n**Solution**：\n\n```verilog\nmodule top_module();\n\n    reg clk,in,out;\n    reg [2:0] s;\n    \n    initial begin\n        clk = 1'b0;\n        in = 1'b0;\n        s = 3'd2;\n        #10 s = 3'd6;\n        #10\n        s = 3'd2;\n        in = 1'b1;\n        #10\n        s = 3'd7;\n        in = 1'b0;\n        #10\n        s = 3'd0;\n        in = 1'b1;\n        #30\tin = 1'b0;\n    end\n    \n    always #5 clk = ~clk;\n    \n    q7 u0(.clk(clk),\n          .in(in),\n          .s(s),\n          .out(out));\n    \nendmodule\n```\n\n### T flip-flop\n\n该题作者给出了一个T触发器的module，我们仅需将其复位，然后切回到状态1就可以了。\n\n**Solution**：\n\n```verilog\nmodule top_module ();\n    reg clk,reset,t;\n    wire q;\n    \n    tff u0(\n        .clk\t(clk    ),\n        .reset\t(reset  ),\n        .t      (t      ),\n        .q      (q      )\n    );\n\n    initial begin\n        clk = 1'b0;\n        reset = 1'b0;\n        #3;\n        reset = 1'b1;\n        #10;\n        reset = 1'b0;   \n    end\n    \n    always #5 clk = ~clk;\n    \n    always@(posedge clk)begin\n        if(reset)begin\n            t <= 1'b0;\n        end\n        else begin\n            t <= 1'b1;\n        end\n    end\n \nendmodule\n```\n\n## 结语\n\nHDLBits系列总算是更新结束了，非常感谢该网站的作者！自己立的flag总算完成了，在寒假收假前刷完了。如果代码有错误的地方欢迎大家指正。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(24)_由波形图描述电路","url":"/2022/09/12/IC/HDLBits/HDLBits答案(24)_由波形图描述电路/","content":"\n# 由波形图描述电路\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新HDLBits习题由波形图描述电路的部分，看图写代码。\n\n------\n\n## 题库\n\n### Combinational circuit 1\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207128.png)\n\n由图可见，`q=a&b`\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input a,\n    input b,\n    output q );//\n\n    assign q = a & b; // Fix me\n\nendmodule\n```\n\n### Combinational circuit 2\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207980.png)\n\n由图列出卡诺图描述出来即可。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output q );//\n\n    assign q = ~a & ~b & ~c & ~d | ~a & ~b & c & d | ~a & b & ~c & d | ~a & b & c & ~d | a & ~b & ~c & d | a & ~b & c & ~d | a & b & ~c & ~d | a & b & c & d; // Fix me\n\nendmodule\n```\n\n### Combinational circuit 3\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208100.png)\n\n由波形图列出卡诺图化简可得。\n\n**Solution**:\n\n```verilog\nmodule top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output q );//\n\n    assign q = b & d | b & c | a & d | a & c; // Fix me\n\nendmodule\n```\n\n### Combinational circuit 4\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208388.png)\n\n与上题同理\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output q );//\n\n    assign q = b | c; // Fix me\n\nendmodule\n```\n\n### Combinational circuit 5\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208020.png)\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208045.png)\n\n由波形图可见这是个多路选择器，通过c路信号进行信号选择；\n\n**Solution**:\n\n```verilog\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input [3:0] d,\n    input [3:0] e,\n    output [3:0] q );\n\n    always @(*) begin\n        case(c)\n            4'd0:\tq <= b;\n            4'd1:\tq <= e;\n            4'd2:\tq <= a;\n            4'd3:\tq <= d;\n            default:q <= 4'hf;\n        endcase\n    end\n    \nendmodule\n```\n\n### Combinational circuit 6\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208479.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [2:0] a,\n    output [15:0] q ); \n\n    always @(*) begin\n        case(a)\n            3'd0:\tq <= 16'h1232;\n            3'd1:\tq <= 16'haee0;\n            3'd2:\tq <= 16'h27d4;\n            3'd3:\tq <= 16'h5a0e;\n            3'd4:\tq <= 16'h2066;\n            3'd5:\tq <= 16'h64ce;\n            3'd6:\tq <= 16'hc526;\n            default:q <= 16'h2f19;\n        endcase\n    end\n    \nendmodule\n```\n\n### Sequential circuit 7\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208047.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input a,\n    output q );\n\n    always @(posedge clk) begin\n        q <= ~a;\n    end\n    \nendmodule\n```\n\n### Sequential circuit 8\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232208231.png)\n\n由图可见，p为a在clock为高电平时的选通信号，q为clock下降沿触发的信号，存放p的值。\n\n**Solution**:\n\n```verilog\nmodule top_module (\n    input clock,\n    input a,\n    output p,\n    output q );\n\n    reg clk_0;\n    assign p = clock ? a : p;\n    \n    always @(negedge clock) begin\n        q <= p;\n    end\n    \nendmodule\n```\n\n### Sequential circuit 9\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232209779.png)\n\n由图可见，q应当是一个从0-6的计数器，当a为高电平时，q保持为4，直到a为低电平时，再继续计数；\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input a,\n    output [3:0] q );\n\n    always @(posedge clk) begin\n        if(a) begin\n            q <= 4'd4;\n        end\n        else if(q == 4'd6) begin\n            q <= 4'd0;\n        end\n        else begin\n            q <= q + 4'd1;\n        end\n    end\n    \nendmodule\n```\n\n### Sequential circuit 10\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232209486.png)\n\nq为a,b和state的组合逻辑，列出真值表即可；\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state  );\n\n    assign q = a ^ b ^ state;\n    \n    always @(posedge clk) begin\n        if(a & b) begin\n            state <= 1'b1;\n        end\n        else if(~a & ~b) begin\n            state <= 1'b0;\n        end\n        else begin\n            state <= state;\n        end\n    end\n    \nendmodule\n```\n\n## 结语\n\n该小结就算更新结束了，胜利就在眼前，哈哈哈！本章的解法并不唯一，大家有什么其他思路欢迎在评论区讨论交流。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(23)_Finding bugs in code","url":"/2022/09/12/IC/HDLBits/HDLBits答案(23)_找BUG/","content":"\n# Finding bugs in code\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新HDLBits习题部分找BUG部分，比较简单，大家看一下即可。\n\n------\n\n## 题库\n\n### 8bit_2_1_Mux\n\n原Code：\n\n```verilog\nmodule top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output out  );\n\n    assign out = (~sel & a) | (sel & b);\n\nendmodule\n```\n\n从上面的代码中我们可以看到，输出的out信号位宽不对，其次多路选择的表达式有误，按上图代码中的取法只能取出1bit。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] out);\n\n    assign out = sel ? a : b;\n\nendmodule\n```\n\n### NAND\n\n用5与非来实现3与非\n\n可供调用的5与模块：\n\n```verilog\nmodule andgate ( output out, input a, input b, input c, input d, input e );\n```\n\n原Code:\n\n```verilog\nmodule top_module (input a, input b, input c, output out);//\n\n    andgate inst1 ( a, b, c, out );\n\nendmodule\n```\n\n由上面可供调用的模块可见，输入输出的对应关系不对，且参数数量也不对，代码改正如下：\n\n**Solution**:\n\n```verilog\nmodule top_module (input a, input b, input c, output out);//\n    \n\twire and_out;\n    \n    andgate inst1 ( and_out, a, b, c, 1, 1);\n    \n    assign out = ~and_out;\n\nendmodule\n```\n\n### 8bit_4_1_Mux\n\n提供了一个无BUG的2_1_Mux\n\n```verilog\nmodule mux2 (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] out\n);\n```\n\n待改代码：\n\n```verilog\nmodule top_module (\n    input [1:0] sel,\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output [7:0] out  ); //\n\n    wire mux0, mux1;\n    mux2 mux0 ( sel[0],    a,    b, mux0 );\n    mux2 mux1 ( sel[1],    c,    d, mux1 );\n    mux2 mux2 ( sel[1], mux0, mux1,  out );\n\nendmodule\n```\n\n分析：sel[1]区分不了c和d，此处应该还是sel[0]。此外例化名与变量名不能重复；且wire信号的位宽也不对。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [1:0] sel,\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output [7:0] out  ); //\n\n    wire [7:0] mux00, mux11;\n    mux2 mux0 ( sel[0],    a,    b, mux00 );\n    mux2 mux1 ( sel[0],    c,    d, mux11 );\n    mux2 mux2 ( sel[1], mux00, mux11,  out );\n\nendmodule\n```\n\n### Add/Sub\n\n原代码：\n\n```verilog\n// synthesis verilog_input_version verilog_2001\nmodule top_module ( \n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);//\n\n    always @(*) begin\n        case (do_sub)\n          0: out = a+b;\n          1: out = a-b;\n        endcase\n\n        if (~out)\n            result_is_zero = 1;\n    end\n\nendmodule\n```\n\n因为`result_is_zero`为reg型，当其为1后一直为1，因为没有其他状态能使其改变，且需锁存状态，因为if未遍历所有状态。\n\n**Solution**:\n\n```verilog\n// synthesis verilog_input_version verilog_2001\nmodule top_module ( \n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);//\n\n    always @(*) begin\n        case (do_sub)\n          0: out = a+b;\n          1: out = a-b;\n        endcase\n\n        if (out == 8'd0) begin\n            result_is_zero = 1;\n        end\n        else begin\n            result_is_zero = 0;\n        end\n    end\n\nendmodule\n```\n\n### Case statement\n\n原代码：\n\n```verilog\nmodule top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid=1 );//\n\n     always @(*)\n        case (code)\n            8'h45: out = 0;\n            8'h16: out = 1;\n            8'h1e: out = 2;\n            8'd26: out = 3;\n            8'h25: out = 4;\n            8'h2e: out = 5;\n            8'h36: out = 6;\n            8'h3d: out = 7;\n            8'h3e: out = 8;\n            6'h46: out = 9;\n            default: valid = 0;\n        endcase\n\nendmodule\n```\n\n分析：默认输出valid=1不能按上图所示的编写代码，默认的输入可以；其次进制`8'd26`需改成8进制。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid);//\n\n     always @(*) begin\n         case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: begin\n                out = 4'd0;\n            end\n        endcase\n\n         if(out == 4'd0 && code!= 8'h45) begin\n            valid = 1'b0;\n        end\n        else begin\n            valid = 1'b1;\n        end\n     end\n     \t\t              \nendmodule\n```\n\n## 结语\n\n该小结就算更新结束了，找BUG部分的习题还挺简单的，有误的地方欢迎大家指正。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(22)_基于有限状态机的计数器","url":"/2022/09/12/IC/HDLBits/HDLBits答案(22)_基于有限状态机的计数器/","content":"\n\n\n# 基于有限状态机的计数器\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新搭建更大的电路部分的习题，内容主要跟计数器和有限状态机有关。\n\n------\n\n## 题库\n\n### Counter with period 1000\n\n构造一个0-999的计数器，同步高电平复位。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    output [9:0] q);\n\n    always @(posedge clk) begin\n        if(reset) begin\n            q <= 10'd0;\n        end\n        else if(q == 10'd999) begin\n            q <= 10'd0;\n        end\n        else begin\n            q <= q + 1'b1;\n        end\n    end\n\nendmodule\n```\n\n### 4-bit shift register and down counter\n\n构造一个4bit的移位寄存器，同时也可以做倒数的计数器使用。其中当`shift_ena`为1时数据data的高位先进到移位寄存器中；当`count_ena`为1时，计数器从寄存器中存储的数开始逐时钟递减；`shift_ena`和`count_ena`没有重要级先后顺序，因为他们不会同时使能。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232206423.png)\n\n**Solution**:\n\n```verilog\nmodule top_module (\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output [3:0] q);\n\n    reg [3:0] q_temp;\n\n    always @(posedge clk) begin\n        if(shift_ena) begin\n            q_temp <= {q_temp[2:0],data};\n        end\n        else if(count_ena) begin\n            if(q_temp == 4'd0) begin\n                q_temp <= 4'd15;\n            end\n            else begin\n                q_temp <= q_temp - 1'b1;\n            end\n        end\n    end\n\n    assign q = q_temp;\n\nendmodule\n```\n\n我以为计数器到0时停止计数，本来按这个逻辑写的，然后在线提交时出错。作者的意思是0后面下一个状态是15，这个大家做题时需注意。\n\n### FSM:Sequence 1101 recognizer\n\n构造一个有限状态机检测`data`中的1101序列，如果检测到该序列，则将输出一直拉高直到同步复位信号为高。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232206706.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous reset\n    input data,\n    output start_shifting);\n\n    parameter IDLE = 3'd0, S1 = 3'd1, S2 = 3'd2;\n    parameter S3 = 3'd3, OUT = 3'd4;\n    reg [2:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            IDLE:       next_state = data ? S1 : IDLE;\n            S1:         next_state = data ? S2 : IDLE;\n            S2:         next_state = data ? S2 : S3;\n            S3:         next_state = data ? OUT : IDLE;\n            OUT:        next_state = OUT;\n            default:    next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign start_shifting = current_state == OUT;\n\nendmodule\n```\n\n### FSM：Enable shift register\n\n当有限状态机被复位时，将`shift_ena`拉高4个周期，之后保持为0直到再次复位。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207220.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous reset\n    output shift_ena);\n\n    parameter IDLE = 2'd0, ENA = 2'd1, STOP = 2'd2;\n    reg [1:0] current_state, next_state;\n    reg [2:0] counter;\n\n    always @(*) begin\n        case(current_state)\n            IDLE:       next_state = ENA;\n            ENA:        next_state = (counter == 3'd3) ? STOP : ENA;\n            STOP:       next_state = STOP;\n            default:    next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            counter <= 3'd0;\n        end\n        else begin\n            case(next_state)\n                IDLE:       counter <= 3'd0;\n                ENA:        counter <= counter + 1'b1;\n                STOP:       counter <= 3'd0;\n                default:    counter <= 3'd0;\n            endcase\n        end      \n    end\n\n    assign shift_ena = current_state == ENA | current_state == IDLE;\n\nendmodule\n```\n\n需注意的是复位一直为高的时候输出也一直为高电平；\n\n### FSM：The complete FSM\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207885.png)\n\n官方提供的状态转移图\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207451.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous reset\n    input data,\n    output shift_ena,\n    output counting,\n    input done_counting,\n    output done,\n    input ack );\n\n    parameter S = 4'd0, S1 = 4'd1, S11 = 4'd2, S110 = 4'd3;\n    parameter B0 = 4'd4, B1 = 4'd5, B2 = 4'd6, B3 = 4'd7;\n    parameter Count = 4'd8, Wait = 4'd9;\n    reg [3:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            S:          next_state = data ? S1 : S;\n            S1:         next_state = data ? S11 : S;\n            S11:        next_state = data ? S11 : S110;\n            S110:       next_state = data ? B0 : S;\n            B0:         next_state = B1;\n            B1:         next_state = B2;\n            B2:         next_state = B3;\n            B3:         next_state = Count;\n            Count:      next_state = done_counting ? Wait : Count;\n            Wait:       next_state = ack ? S : Wait;\n            default:    next_state = S;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            current_state <= S;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign shift_ena = current_state == B0 | current_state == B1 | current_state == B2 | current_state == B3;\n    assign counting = current_state == Count;\n    assign done = current_state == Wait;\n\nendmodule\n```\n\n标准的FSM格式，没啥说的，画出状态转移表写就行了。\n\n### The complete timer\n\n该道状态机就是前面几道状态机的组合，大家需注意的是计数那边的部分；之前我将计数子的位宽设置不当，导致这题卡的挺久，希望大家做题分析时注意。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207129.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous reset\n    input data,\n    output [3:0] count,\n    output counting,\n    output done,\n    input ack );\n\n    parameter IDLE = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3;\n    parameter C0 = 4'd4, C1 = 4'd5, C2 = 4'd6, C3 = 4'd7;\n    parameter Count_1000 = 4'd8, Done = 4'd9;\n    \n    reg [3:0] current_state, next_state;\n    reg [15:0] num;\n    reg [3:0] delay;\n    reg [3:0] already_count;\n\n    wire count_state;\n    assign count_state = (num == (delay + 1'b1)*1000) ? 1'b1 : 1'b0;\n\n    always @(*) begin\n        if(num <= 16'd1000) begin\n            already_count = 4'd0;\n        end\n        else if(num > 16'd1000 && num <= 16'd2000) begin\n            already_count = 4'd1;\n        end\n        else if(num > 16'd2000 && num <= 16'd3000) begin\n            already_count = 4'd2;\n        end\n        else if(num > 16'd3000 && num <= 16'd4000) begin\n            already_count = 4'd3;\n        end\n        else if(num > 16'd4000 && num <= 16'd5000) begin\n            already_count = 4'd4;\n        end\n        else if(num > 16'd5000 && num <= 16'd6000) begin\n            already_count = 4'd5;\n        end\n        else if(num > 16'd6000 && num <= 16'd7000) begin\n            already_count = 4'd6;\n        end\n        else if(num > 16'd7000 && num <= 16'd8000) begin\n            already_count = 4'd7;\n        end\n        else if(num > 16'd8000 && num <= 16'd9000) begin\n            already_count = 4'd8;\n        end\n        else if(num > 16'd9000 && num <= 16'd10000) begin\n            already_count = 4'd9;\n        end\n        else if(num > 16'd10000 && num <= 16'd11000) begin\n            already_count = 4'd10;\n        end\n        else if(num > 16'd11000 && num <= 16'd12000) begin\n            already_count = 4'd11;\n        end\n        else if(num > 16'd12000 && num <= 16'd13000) begin\n            already_count = 4'd12;\n        end\n        else if(num > 16'd13000 && num <= 16'd14000) begin\n            already_count = 4'd13;\n        end\n        else if(num > 16'd14000 && num <= 16'd15000) begin\n            already_count = 4'd14;\n        end\n        else begin\n            already_count = 4'd15;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            num <= 16'd0;\n        end\n        else if(next_state == Done) begin\n            num <= 16'd0;\n        end\n        else if(next_state == Count_1000) begin\n            num <= num + 16'd1;\n        end\n    end\n\n    always @(*) begin\n        case(current_state)\n            IDLE:       next_state = data ? S1 : IDLE;\n            S1:         next_state = data ? S2 : IDLE;\n            S2:         next_state = data ? S2 : S3;\n            S3:         next_state = data ? C0 : IDLE;\n            C0:begin\n                        next_state = C1;\n                        delay[3] = data;\n            end         \n            C1:begin\n                        next_state = C2;    \n                        delay[2] = data;\n            end         \n            C2:begin\n                        next_state = C3;    \n                        delay[1] = data;\n            end         \n            C3:begin\n                        next_state = Count_1000;    \n                        delay[0] = data;\n            end         \n            Count_1000: next_state = count_state ? Done : Count_1000;\n            Done:       next_state = ack ? IDLE : Done;\n            default:    next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign count = (current_state == Count_1000) ? (delay - already_count) : 4'd0;\n    assign counting = (current_state == Count_1000);\n    assign done = current_state == Done;\n\nendmodule\n```\n\n### FSM：One-hot logic equations\n\n用one-hot编码的状态写出状态转移代码。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232207395.png)\n\n**Solution**：\n\n```verilog\nmodule top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n); //\n\n    // You may use these parameters to access state bits using e.g., state[B2] instead of state[6].\n    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n    assign B3_next = state[B2];\n    assign S_next = ~d & state[S] | ~d & state[S1] | ~d & state[S110] | ack & state[Wait];\n    assign S1_next = d & state[S];\n    assign Count_next = state[B3] | ~done_counting & state[Count];\n    assign Wait_next = done_counting & state[Count] | ~ack & state[Wait];\n    assign done = state[Wait];\n    assign counting = state[Count];\n    assign shift_ena = state[B0] | state[B1] | state[B2] | state[B3];\n\nendmodule\n```\n\n## 结语\n\n该小结就算更新结束了，下面剩的也不多了。如有不对的还望大家指正。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(21)_Verilog有限状态机(8)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(21)_Verilog有限状态机(8)/","content":"\n# Verilog有限状态机(8)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天继续更新状态机小节的习题。\n\n------\n\n## 题库\n\n### Q2a:FSM\n\n正宗的FSM题，没啥说的，看图写代码。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232206848.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input w,\n    output z\n);\n\n    parameter A = 3'd0, B = 3'd1, C = 3'd2;\n    parameter D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            A:      next_state = w ? B : A;\n            B:      next_state = w ? C : D;\n            C:      next_state = w ? E : D;\n            D:      next_state = w ? F : A;\n            E:      next_state = w ? E : D;\n            F:      next_state = w ? C : D;\n            default:next_state = A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            current_state <= A;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign z = (current_state == E) | (current_state == F);\n\nendmodule\n```\n\n### Q2b:One-hot FSM equations\n\n状态使用独热编码，将状态中的y[1]和y[3]表示出来。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    assign Y1 = y[0] & w;\n    assign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n    \nendmodule\n```\n\n### Q2a:FSM\n\n本题是用状态机实现一个判优器。其中r1、r2、r3分别表示三种设备的request，g1、g2、g3表示资源的分配情况。由下面的状态图可见，设备1,2,3的优先级依次递减。当设备请求到资源时，需等其完成任务才能释放资源。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232206772.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,    // active-low synchronous reset\n    input [3:1] r,   // request\n    output [3:1] g   // grant\n);\n\n    parameter A = 2'd0, B = 2'd1;\n    parameter C = 2'd2, D = 2'd3;\n    reg [1:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            A:begin\n                if(r[1] == 1'b1) begin\n                    next_state = B;\n                end\n                else if(r[2] == 1'b1) begin\n                    next_state = C;\n                end\n                else if(r[3] == 1'b1) begin\n                    next_state = D;\n                end\n                else begin\n                    next_state = A;\n                end\n            end\n            B:       next_state = r[1] ? B : A;\n            C:       next_state = r[2] ? C : A;\n            D:       next_state = r[3] ? D : A;\n            default: next_state = A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(~resetn) begin\n            current_state <= A;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign g[1] = current_state == B;\n    assign g[2] = current_state == C;\n    assign g[3] = current_state == D;\n\nendmodule\n```\n\n### Q2b:Another FSM\n\n该题的状态机共2输入2输出；当复位信号撤销时，在下一个周期内将f输出为1，需留意f为1持续一个周期；然后状态机取决于x的值，当x在连续的三个周期中产生值为1、0、1时，下一周期将g输出为1，<u>在保持g为1时判断y的输入</u>，如果y在两个周期中有任意一个周期为1了，那么g永久保持1；如果两个周期都没有1，那么g将永久保持0。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,    // active-low synchronous reset\n    input x,\n    input y,\n    output f,\n    output g\n); \n\n    parameter IDLE = 4'd0, FOUT = 4'd1, S1 = 4'd2;\n    parameter S2 = 4'd3, S3 = 4'd4, S4 = 4'd5;\n    parameter S5 = 4'd6, ALL_ONE = 4'd7, ALL_ZERO = 4'd8;\n    reg [3:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            IDLE:       next_state = FOUT;\n            FOUT:       next_state = S1;\n            S1:         next_state = x ? S2 : S1;\n            S2:         next_state = x ? S2 : S3;\n            S3:         next_state = x ? S4 : S1;\n            S4:         next_state = y ? ALL_ONE : S5;\n            S5:         next_state = y ? ALL_ONE : ALL_ZERO;\n            ALL_ONE:    next_state = ALL_ONE;\n            ALL_ZERO:   next_state = ALL_ZERO;\n            default:    next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(~resetn) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign f = current_state == FOUT;\n    assign g = current_state == S4 | current_state == S5 | current_state == ALL_ONE;\n\nendmodule\n```\n\n心得：状态机设计的好坏决定代码的难易程度，在画状态转移图时可以多留点时间。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232206654.png)\n\n## 结语\n\n状态机这部分题目终于更新完了，自己在做这些题目的过程中收获也非常大，很感谢该网站的作者。如果代码哪里有误，请大家指正，评论区也欢迎大家交流不同的解题思路。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(20)_Verilog有限状态机(7)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(20)_Verilog有限状态机(7)/","content":"\n# Verilog有限状态机(7)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天继续更新状态机小节的习题。\n\n------\n\n## 题库\n\n### Q3a:FSM\n\n题目里说当s为0时，进入B状态，然后会检查w的值，如果在接下来的三个周期中w值恰好有两个周期都为1，那么z输出1，否则z输出0。注意，由示例的波形图看应该是不重叠检测。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204786.png)\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204239.png)\n\n**Solution**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous reset\n    input s,\n    input w,\n    output z\n);\n    parameter S0 = 1'd0, S1 = 1'd1;\n    reg current_state, next_state;\n    reg [1:0] counter,num_one;\n\n    always @(*) begin\n        case(current_state)\n            S0:     next_state = s ? S1 : S0;\n            S1:     next_state = S1;\n            default:next_state = S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            current_state <= S0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            counter <= 2'd0;\n        end\n        else if(counter == 2'd2) begin\n            counter <= 2'd0;\n        end\n        else if(current_state == S1) begin\n            counter <= counter + 1'd1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset) begin\n            num_one <= 1'd0;\n        end\n        else begin\n            if(counter == 2'd0)begin\n                num_one <= w ? 1'd1 : 1'd0;\n            end\n            else if(current_state == S1) begin\n                num_one <= w ? (num_one+1'd1) : num_one;\n            end   \n        end          \n    end\n\n    assign z = (current_state == S1 && num_one == 2'd2 && counter == 2'd0);\n\nendmodule\n```\n\n此题中我用了两个计数器来完成，需特别注意的是，在满足哪种条件时计数器清零或者自加，一定注意！\n\n### Q3b:FSM\n\n该题让实现下图所示的状态机，其中复位信号让状态转移至000；\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204468.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous reset\n    input x,\n    output z\n);\n\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010;\n    parameter S3 = 3'b011, S4 = 3'b100;\n    reg [2:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            S0:     next_state = x ? S1 : S0;\n            S1:     next_state = x ? S4 : S1;\n            S2:     next_state = x ? S1 : S2;\n            S3:     next_state = x ? S2 : S1;\n            S4:     next_state = x ? S4 : S3;\n            default:next_state = S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            current_state <= S0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            z <= 1'b0;\n        end\n        else begin\n            case(next_state)\n                S3:     z <= 1'b1;\n                S4:     z <= 1'b1;\n                default:z <= 1'b0;\n            endcase\n        end      \n    end\n\nendmodule\n```\n\n心得：第三段状态机输出用到`next_state`做条件时，记得要将`reset`条件加上，因为`reset`影响的是`current_state`，不影响`next_state`。\n\n### Q3c:FSM logic\n\n由下面的状态转移表将Y[0]与z表示出来。\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204847.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input [2:0] y,\n    input x,\n    output Y0,\n    output z\n);\n\n    assign Y0 = ((~y[2]&y[0])|(y==3'b100))&~x | (~y[2]&~y[0])&x;\n    assign z = (y == 3'b011) | (y == 3'b100);\n\nendmodule\n```\n\n### Q6b：FSM next-state logic\n\n通过下面的状态转移表将Y[2]的下一状态表示出来，其中w为输入。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232205665.png)\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232205948.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [3:1] y,\n    input w,\n    output Y2);\n\n    assign Y2 = (y == 3'b001 | y == 3'b101) & ~w | (y == 3'b001 | y == 3'b010 | y == 3'b100 | y == 3'b101) & w;\n    \nendmodule\n```\n\n按上面我列的状态转移表将Y2表示出来即可。\n\n### Q6c:FSM one-hot next-state logic\n\n这里使用了one-hot编码，将Y2和Y4输出出来，思路与上题类似，这里不再赘述。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4);\n    \n    assign Y2 = ~w & y[1];\n    assign Y4 = (w & y[2])|(w & y[3])|(w & y[5])|(w & y[6]);\n\nendmodule\n```\n\n### Q6：FSM\n\n这是个正宗的FSM题，照着图列状态即可。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232205569.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,     // synchronous reset\n    input w,\n    output z);\n\n    parameter A = 3'd0, B = 3'd1, C=3'd2;\n    parameter D = 3'd3, E = 3'd4, F=3'd5;\n    reg [2:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            A:      next_state = w ? A : B;\n            B:      next_state = w ? D : C;\n            C:      next_state = w ? D : E;\n            D:      next_state = w ? A : F;\n            E:      next_state = w ? D : E;\n            F:      next_state = w ? D : C;\n            default:next_state = A;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            current_state <= A;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign z = (current_state == E | current_state == F);\n\nendmodule\n```\n\n## 结语\n\n今天先更新这几题吧，FSM这部分题目都算比较基础的题目，代码有不足之处还望指正，状态机部分的题终于要结束了。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(19)_Verilog有限状态机(6)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(19)_Verilog有限状态机(6)/","content":"\n# Verilog有限状态机(6)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天继续更新状态机小节的习题。\n\n------\n\n## 题库\n\n### Fsm hdlc\n\n同步帧检测涉及对数据的连续位流进行解码，以寻找指示帧（数据包）开始和结束的位模式。 6个连续的1（即01111110）是表示帧边界的“标志”。 为了避免数据流意外包含“标志”，发送方必须在接收方必须检测并丢弃的每5个连续的1秒后插入一个零。 如果连续7个或更多1，我们还需要发出错误信号。\n\n可以通过状态机来识别下面三种序列：\n\n0111110：表示5个1后面的0bit需被忽略；\n\n01111110：表示一帧的开始或结束；\n\n01111111...：错误\n\n当状态机被复位时，它应当表现为之前的输入为0；\n\n下面是三种波形示例：\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232203111.png)\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232203892.png)\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232203681.png)\n\n官方提供的状态机设计提示：\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232203790.png)\n\n**Solution**:\n\n```verilog\n//----------------way1----------------------\nmodule top_module(\n    input clk,\n    input reset,    // Synchronous reset\n    input in,\n    output disc,\n    output flag,\n    output err);\n\n    parameter NONE = 4'd0,ONE = 4'd1,TWO = 4'd2;\n    parameter THREE = 4'd3,FOUR = 4'd4,FIVE = 4'd5;\n    parameter SIX = 4'd6,ERROR = 4'd7;\n    parameter DISC = 4'd8,FLAG = 4'd9;\n\n    reg [3:0] current_state,next_state;\n\n    always @(*) begin\n        case(current_state)\n            NONE:begin\n                next_state = in ? ONE : NONE;\n            end\n            ONE:begin\n                next_state = in ? TWO : NONE;\n            end\n            TWO:begin\n                next_state = in ? THREE : NONE;\n            end\n            THREE:begin\n                next_state = in ? FOUR : NONE;\n            end\n            FOUR:begin\n                next_state = in ? FIVE : NONE;\n            end\n            FIVE:begin\n                next_state = in ? SIX : DISC;\n            end\n            SIX:begin\n                next_state = in ? ERROR : FLAG;\n            end\n            DISC:begin\n                next_state = in ? ONE : NONE;\n            end\n            FLAG:begin\n                next_state = in ? ONE : NONE;\n            end\n            ERROR:begin\n                next_state = in ? ERROR : NONE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            current_state <= NONE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            disc <= 1'd0;\n            flag <= 1'd0;\n            err  <= 1'd0;\n        end\n        else begin\n            case(next_state)\n                DISC:begin\n                    disc <= 1'd1;\n                    flag <= 1'd0;\n                    err  <= 1'd0;\n                end\n                FLAG:begin\n                    disc <= 1'd0;\n                    flag <= 1'd1;\n                    err  <= 1'd0;\n                end\n                ERROR:begin\n                    disc <= 1'd0;\n                    flag <= 1'd0;\n                    err  <= 1'd1;\n                end\n                default:begin\n                    disc <= 1'd0;\n                    flag <= 1'd0;\n                    err  <= 1'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n//----------------way2----------------------\nmodule top_module(\n    input clk,\n    input reset,    // Synchronous reset\n    input in,\n    output disc,\n    output flag,\n    output err);\n\n    parameter NONE = 3'd0,DATA = 3'd1;\n    parameter DISC = 3'd2,FLAG = 3'd3,ERROR = 3'd4;\n\n    reg [2:0] current_state,next_state;\n    reg [2:0] counter;\n\n    always @(*) begin\n        case(current_state)\n            NONE:begin\n                next_state = in ? DATA : NONE;\n            end\n            DATA:begin\n                case(counter)\n                    3'd5:   next_state = in ? DATA : DISC;\n                    3'd6:   next_state = in ? ERROR : FLAG;\n                    default:next_state = in ? DATA : NONE;\n                endcase\n            end\n            DISC:begin\n                next_state = in ? DATA : NONE;\n            end\n            FLAG:begin\n                next_state = in ? DATA : NONE;\n            end\n            ERROR:begin\n                next_state = in ? ERROR : NONE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            current_state <= NONE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            disc <= 1'd0;\n            flag <= 1'd0;\n            err  <= 1'd0;\n            counter <= 3'd0;\n        end\n        else begin\n            case(next_state)\n                DATA:begin\n                    disc <= 1'd0;\n                    flag <= 1'd0;\n                    err  <= 1'd0;\n                    counter <= counter + 1'd1;\n                end\n                DISC:begin\n                    disc <= 1'd1;\n                    flag <= 1'd0;\n                    err  <= 1'd0;\n                    counter <= 3'd0;\n                end\n                FLAG:begin\n                    disc <= 1'd0;\n                    flag <= 1'd1;\n                    err  <= 1'd0;\n                    counter <= 3'd0;\n                end\n                ERROR:begin\n                    disc <= 1'd0;\n                    flag <= 1'd0;\n                    err  <= 1'd1;\n                    counter <= 3'd0;\n                end\n                default:begin\n                    disc <= 1'd0;\n                    flag <= 1'd0;\n                    err  <= 1'd0;\n                    counter <= 3'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n\n其中way1与题目提示的思路相同，其中第三段状态机一开始忘记加reset的那种情况，果然还是长时间没接触verilog手生了，以后继续练习；\n\nway2使用counter去掉中间状态，靠输入和counter的值来决定状态转移，是一种米利状态机的思想；状态转移图如下(手绘有点丑，见谅)：\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204068.png)\n\n### 米利型状态机\n\n检测输入的X中”101“是否出现，出现的话输出Z为1，否则为0。复位为异步低电平复位；只允许出现3种状态；允许交叠检测：即输入若为10101时，Z应该在时刻3和时刻5各输出一次1；\n\n代码中主要妙在两处：一是如何用3种状态表示，需在第三种状态中将输出与输入关联起来；二是如何进行交叠检测，状态的转移有妙处；\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input aresetn,    // Asynchronous active-low reset\n    input x,\n    output z ); \n\n    parameter S0 = 2'd0,S1 = 2'd1,S2 = 2'd2;\n    reg [1:0] current_state,next_state;\n\n    always @(*) begin\n        case(current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n        endcase\n    end\n\n    always @(posedge clk or negedge aresetn) begin\n        if(~aresetn)begin\n            current_state <= S0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        z = (current_state == S2) ? x : 1'b0;\n    end\n\nendmodule\n```\n\n### Q5a:Serial two's complementer(Moore FSM)\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204746.png)\n\n作者这里假设我们这边输入的都是负数，不用管符号位的问题；即补码全部都是取反加1求得。\n\n以上图为例，输入的左边为低位数据，右边为高位数据；即输入为00110100，则取反加1后得输出为11001100；\n\n取反操作好进行，主要麻烦在加一的操作上，不知道进位到哪一位为止，此时我们用状态机来解决；<u>若最前面的输入都是0的话，取反均为1，低位加1的时候一直进位，则输出都是0，直到输入有个1为止(取反加1不进位)，这一阶段我们用一个状态S1来表示；后面阶段就将输入取反进行输出即可，因为进位链在S1状态已结束；</u>\n\n因为是摩尔型状态机，输出的结果与输入无关，仅与状态有关。所以我们这里用到3个状态，代码如下所示：\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n); \n\n    parameter S0 = 2'd0, S1 = 2'd1, S2 = 2'd2;\n    reg [1:0] current_state, next_state;\n\n    always @(*) begin\n        case(current_state)\n            S0:     next_state = x ? S1 : S0;\n            S1:     next_state = x ? S2 : S1;\n            S2:     next_state = x ? S2 : S1;\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if(areset)begin\n            current_state <= S0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign z = (current_state == S1);\n\nendmodule\n```\n\n### Q5b:Serial two's complementer(Mealy FSM)\n\n题意与上题相同，此时用米利型状态机实现。下面是官方提供的状态转移提示：\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232204552.png)\n\n```verilog\nmodule top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n); \n\n    parameter S0 = 1'b0, S1 = 1'b1;\n    reg current_state,next_state;\n\n    always @(*) begin\n        case(current_state)\n            S0:     next_state = x ? S1 : S0;\n            S1:     next_state = S1;\n        endcase\n    end\n\n    always @(posedge clk or posedge areset) begin\n        if(areset)begin\n            current_state <= S0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign z = ((current_state == S0) && x) || ((current_state == S1) && ~x);\n\nendmodule\n```\n\n## 结语\n\n今天先更新这几题吧，大家如果对转补码的题目还有什么疑问欢迎评论交流，代码有不足之处还望指正。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(18)_Verilog有限状态机(5)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(18)_Verilog有限状态机(5)/","content":"\n# Verilog有限状态机(5)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天继续更新状态机小节的习题。\n\n------\n\n## 题库\n\n**题目描述1：**\n\n第一道题目比较容易，题目中的in信号包含了一个起始位（0），8个数据位和一个停止位（1），开始in为1，也就是IDLE状态，当in为0时，进入START状态，然后经过8个周期，如果in为1，则进入STOP状态，接着如果in为0，进入第二轮START状态，否则进入IDLE状态。\n\n这里我用了很多个状态，实际上可以用计数器来代替中间的8个状态，这里是8个周期，如果是100个、200个周期，那么需要100个、200个状态，显然不现实。这道题目是三道题目中的基础题，大家不用考虑那么多，直接完成就好了。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232203628.png)\n\n**Solution1：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input in,\n    input reset,    // Synchronous reset\n    output done\n); \n    parameter [3:0] START = 4'd0;\n    parameter [3:0] ONE = 4'd1;\n    parameter [3:0] TWO = 4'd2;\n    parameter [3:0] THREE = 4'd3;\n    parameter [3:0] FOUR = 4'd4;\n    parameter [3:0] FIVE = 4'd5;\n    parameter [3:0] SIX = 4'd6;\n    parameter [3:0] SEVEN = 4'd7;\n    parameter [3:0] EIGHT = 4'd8;\n    parameter [3:0] STOP = 4'd9;\n    parameter [3:0] IDLE = 4'd10;\n    parameter [3:0] WAIT = 4'd11;\n    \n    reg [3:0] state,next_state;\n    \n    always @(*)begin\n        case(state)\n            START:begin\n                next_state = ONE;\n            end\n            ONE:begin\n                next_state = TWO;\n            end\n            TWO:begin\n                next_state = THREE;\n            end\n            THREE:begin\n                next_state = FOUR;\n            end\n            FOUR:begin\n                next_state = FIVE;\n            end\n            FIVE:begin\n                next_state = SIX;\n            end\n            SIX:begin\n                next_state = SEVEN;\n            end\n            SEVEN:begin\n                next_state = EIGHT;\n            end\n            EIGHT:begin\n                if(in)begin\n                    next_state = STOP;\n                end\n                else begin\n                    next_state = WAIT;\n                end\n            end\n            STOP:begin\n                if(in)begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = START;\n                end\n            end\n            WAIT:begin\n                if(in)begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = WAIT;\n                end\n            end\n            IDLE:begin\n                if(~in)begin\n                    next_state = START;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    assign done = (state == STOP);\n\nendmodule\n```\n\n**题目描述2：**\n\n这道题目是上一道题目的扩展，不仅需要输出done信号，还需要输出数据。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232203720.png)\n\n**Solution2：**\n\n```verilog\n/* way 1*/\nmodule top_module(\n    input clk,\n    input in,\n    input reset,    // Synchronous reset\n    output [7:0] out_byte,\n    output done\n); //\n    \n    parameter [3:0] START = 4'd0;\n    parameter [3:0] ONE = 4'd1;\n    parameter [3:0] TWO = 4'd2;\n    parameter [3:0] THREE = 4'd3;\n    parameter [3:0] FOUR = 4'd4;\n    parameter [3:0] FIVE = 4'd5;\n    parameter [3:0] SIX = 4'd6;\n    parameter [3:0] SEVEN = 4'd7;\n    parameter [3:0] EIGHT = 4'd8;\n    parameter [3:0] STOP = 4'd9;\n    parameter [3:0] IDLE = 4'd10;\n    parameter [3:0] WAIT = 4'd11;\n    \n    reg [3:0] state,next_state;\n    \n    reg [7:0]\tpar_in;\n    \n    always @(*)begin\n        case(state)\n            START:begin\n                next_state = ONE;\n                par_in[0] = in;\n            end\n            ONE:begin\n                next_state = TWO;\n                par_in[1] = in;\n            end\n            TWO:begin\n                next_state = THREE;\n                par_in[2] = in;\n            end\n            THREE:begin\n                next_state = FOUR;\n                par_in[3] = in;\n            end\n            FOUR:begin\n                next_state = FIVE;\n                par_in[4] = in;\n            end\n            FIVE:begin\n                next_state = SIX;\n                par_in[5] = in;\n            end\n            SIX:begin\n                next_state = SEVEN;\n                par_in[6] = in;\n            end\n            SEVEN:begin\n                next_state = EIGHT;\n                par_in[7] = in;\n            end\n            EIGHT:begin\n                if(in)begin\n                    next_state = STOP;\n                end\n                else begin\n                    next_state = WAIT;\n                end\n            end\n            STOP:begin\n                if(in)begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = START;\n                end\n            end\n            WAIT:begin\n                if(in)begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = WAIT;\n                end\n            end\n            IDLE:begin\n                if(~in)begin\n                    next_state = START;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    assign done = (state == STOP);\n    assign out_byte = (state == STOP) ? par_in : 8'd0;\n\nendmodule\n\n/* way 2 */\nmodule top_module(\n    input clk,\n    input in,\n    input reset,    // Synchronous reset\n    output [7:0] out_byte,\n    output done\n); \n\tparameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2;\n    parameter STOP = 3'd3, WAIT = 3'd4;\n    reg [3:0]\tcurrent_state;\n    reg [3:0]\tnext_state;\n    reg [3:0]\tcounter;\n    reg [7:0]\tpar_in;\n    // Use FSM from Fsm_serial\n    always @(*)begin\n        case(current_state)\n            IDLE:begin\n                if(~in)begin\n                    next_state = START;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            START:begin\n                next_state = DATA;\n            end\n            DATA:begin\n                if(counter == 4'd8)begin\n                    next_state = in? STOP:WAIT;\n                end\n                else begin\n                    next_state = DATA;\n                end\n            end\n            STOP:begin\n                next_state = in? IDLE:START;\n            end\n            WAIT:begin\n                next_state = in? IDLE:WAIT;\n            end\n            default:begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk)begin\n        if(reset)begin\n            done <= 1'd0;\n            out_byte <= 8'd0;\n            counter <= 4'd0;\n        end\n        else begin\n            case(next_state)\n                IDLE:begin\n                    done <= 1'd0;\n           \t\t    out_byte <= 8'd0;\n            \t\tcounter <= 4'd0;\n                end\n                START:begin\n                    done <= 1'd0;\n           \t\t    out_byte <= 8'd0;\n            \t\tcounter <= 4'd0;\n                end\n                DATA:begin\n                    done <= 1'd0;\n           \t\t    out_byte <= 8'd0;\n                    par_in[counter] <= in;\n            \t\tcounter <= counter + 1'd1;\n                end\n                STOP:begin\n                    done <= 1'd1;\n           \t\t    out_byte <= par_in;\n            \t\tcounter <= 4'd0;\n                end\n                WAIT:begin\n                    done <= 1'd0;\n           \t\t    out_byte <= 8'd0;\n            \t\tcounter <= 4'd0;\n                end\n            endcase\n        end\n    end\n    // New: Datapath to latch input bits.\n\nendmodule\n```\n\n上述第一种解法虽然正确，但是会生成锁存器，并且这里只有1个字节数据还好，用8个状态是可以的，如果换成了10个字节、100个字节，难道要80、800个状态吗？这是不可能的，于是便诞生了**方法二**博主最想让大家使用的方法。大家可以好好看一下，这里将8个数据状态定义成了一个DATA状态，不用定义S1、S2、S3什么的了，在状态机的第三段，将除了**DATA状态的其他状态时的counter都清零**，只有到了**DATA状态时开始计数**，顺便将**par_in中的位数用counter代替**，这样只需要增加counter和out_byte的位宽，就可以实现任意宽度数据的输出，实用性强。\n\n**题目描述3：**\n\n较上题添加了奇偶校验位。\n\n```verilog\nmodule top_module(\n    input clk,\n    input in,\n    input reset,    // Synchronous reset\n    output [7:0] out_byte,\n    output done\n); //\n\t\n    parameter IDLE = 3'd0,START = 3'd1,DATA = 3'd2;\n    parameter STOP = 3'd3,WAIT = 3'd4;\n\n    reg [2:0] current_state,next_state;\n    reg [3:0] counter;\n    reg [8:0] data_in;\n    reg odd_temp;\n    wire Isdone;\n\n    // Modify FSM and datapath from Fsm_serialdata\n    always @(*) begin\n        case(current_state)\n            IDLE:begin\n                if(~in)begin\n                    next_state = START;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            START:begin\n                next_state = DATA;\n            end\n            DATA:begin\n                if(counter == 4'd9)begin\n                    next_state = in ? STOP : WAIT;\n                end\n                else begin\n                    next_state = DATA;\n                end\n            end\n            STOP:begin\n                next_state = in ? IDLE : START;\n            end\n            WAIT:begin\n                next_state = in ? IDLE : WAIT;\n            end\n            default:begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            done <= 1'd0;\n            out_byte <= 8'd0;\n            counter <= 4'd0;\n        end\n        else begin\n            case(next_state)\n                IDLE:begin\n                    done <= 1'd0;\n                    out_byte <= 8'd0;\n                    counter <= 4'd0;\n                end\n                START:begin\n                    done <= 1'd0;\n                    out_byte <= 8'd0;\n                    counter <= 4'd0;\n                end\n                DATA:begin\n                    done <= 1'd0;\n                    out_byte <= 8'd0;\n                    counter <= counter + 1'd1;\n                    data_in[counter] <= in;\n                end\n                STOP:begin\n                    done <= odd_temp ? 1'd1 : 1'd0;\n                    out_byte <= odd_temp ? data_in[7:0] : 8'd0;\n                    counter <= 4'd0;\n                end\n                WAIT:begin\n                    done <= 1'd0;\n                    out_byte <= 8'd0;\n                    counter <= 4'd0;\n                end\n            endcase\n        end\n    end\n    // New: Add parity checking.\n    assign Isdone = (next_state == START);\n    parity u0(clk,Isdone,in,odd_temp);\n\nendmodule\n```\n\n该题答案与上题类似，这里我将奇偶校验位数据也计算在DATA状态内，判断起来相对较容易，大家可以借鉴一下。\n\n**注意作者在题目中给了奇偶校验的模块，大家直接调用即可。**\n\n## 结语\n\n好久没更新HDLBits了，寒假在家闲来无事，希望勉励自己把HDLBits刷完吧，加油！有问题的地方欢迎大家与我讨论交流。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(17)_Verilog有限状态机(4)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(17)_Verilog有限状态机(4)/","content":"\n# Verilog有限状态机(4)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天继续更新状态机小节的习题。\n\n------\n\n## 题库\n\n**题目描述1：**\n\nOne-hot FSM\n\n独热编码，根据状态转移图输出下一状态与结果。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232202048.png)\n\n**Solution1：**\n\n```verilog\nmodule top_module(\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n    \n    parameter S0 = 4'd0;\n    parameter S1 = 4'd1;\n    parameter S2 = 4'd2;\n    parameter S3 = 4'd3;\n    parameter S4 = 4'd4;\n    parameter S5 = 4'd5;\n    parameter S6 = 4'd6;\n    parameter S7 = 4'd7;\n    parameter S8 = 4'd8;\n\tparameter S9 = 4'd9;\n    \n    assign next_state[0] = ~in & (state[S0] | state[S1] | state[S2] | state[S3] | state[S4] | state[S7] | state[S8] | state[S9]);\n    assign next_state[1] = in & (state[S0] | state[S8] | state[S9]);\n    assign next_state[2] = in & state[S1];\n    assign next_state[3] = in & state[S2];\n    assign next_state[4] = in & state[S3];\n    assign next_state[5] = in & state[S4];\n    assign next_state[6] = in & state[S5];\n    assign next_state[7] = in & (state[S6] | state[S7]);\n    assign next_state[8] = ~in & state[S5];\n    assign next_state[9] = ~in & state[S6];\n    \n    assign out1 = (state[S8] | state[S9]);\n    assign out2 = (state[S7] | state[S9]);\n    \nendmodule\n```\n\n**题目描述2：**\n\n PS/2 packet parser\n\n首先，这道题目中作者表明in的第3位为1时，状态机启动，其他两位可能为1或0，注意，这里不允许重叠检测，根据作者给出的时序图，大家应该就可以写出状态机了。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232202256.png)\n\n**Solution2：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input [7:0] in,\n    input reset,    // Synchronous reset\n    output done); //\n\n    parameter BYTE_FIRST = 2'd0;\n    parameter BYTE_SECOND = 2'd1;\n    parameter BYTE_THIRD = 2'd2;\n    parameter WAIT = 2'd3;\n    \n    reg [1:0] state,next_state;\n    // State transition logic (combinational)\n    always @(*)begin\n        case(state)\n            BYTE_FIRST:begin\n                next_state = BYTE_SECOND;\n            end\n            BYTE_SECOND:begin\n                next_state = BYTE_THIRD;\n            end\n            BYTE_THIRD:begin\n                if(in[3] == 1'b1)begin\n                    next_state = BYTE_FIRST;\n                end\n                else begin\n                    next_state = WAIT;\n                end\n            end\n            WAIT:begin\n                if(in[3] == 1'b1)begin\n                    next_state = BYTE_FIRST;\n                end\n                else begin\n                    next_state = WAIT;\n                end\n            end\n        endcase\n    end\n    \n    // State flip-flops (sequential)\n    always @(posedge clk)begin\n        if(reset)begin\n            state <= WAIT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    // Output logic\n    assign done = (state == BYTE_THIRD);\n\nendmodule\n```\n\n**题目描述3：**\n\nPS/2 packet parser and datapath\n\n这道题目相比上一道多了数据位输出，当done信号为1时，输出24bit的数据，这24bit的数据高8位，中8位，低8位分别从in[3]为1开始计起，依次输出。done信号为0的时候不关心数据信号。高8位输出仅当下一状态为`BYTE_SECOND`才开始，此处可以简化判断逻辑，大家可以注意一下。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232202630.png)\n\n**Solution3：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input [7:0] in,\n    input reset,    // Synchronous reset\n    output [23:0] out_bytes,\n    output done); //\n\n    parameter BYTE_FIRST = 2'd0;\n    parameter BYTE_SECOND = 2'd1;\n    parameter BYTE_THIRD = 2'd2;\n    parameter DONE = 2'd3;\n    \n    reg [1:0] state,next_state;\n    reg [23:0] out_bytes_reg;\n    // FSM from fsm_ps2\n    always @(posedge clk)begin\n        if(reset)begin\n            state <= BYTE_FIRST;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    always @(*)begin\n        case(state)\n            BYTE_FIRST:begin\n                if(in[3])begin\n                    next_state = BYTE_SECOND;\n                end\n                else begin\n                    next_state = BYTE_FIRST;\n                end\n            end\n            BYTE_SECOND:begin\n                next_state = BYTE_THIRD;\n            end\n            BYTE_THIRD:begin\n                next_state = DONE;\n            end\n            DONE:begin\n                if(in[3])begin\n                    next_state = BYTE_SECOND;\n                end\n                else begin\n                    next_state = BYTE_FIRST;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk)begin\n        if(next_state == BYTE_SECOND)begin\n            out_bytes_reg[23:16] <= in;\n        end\n        else if(next_state == BYTE_THIRD)begin\n            out_bytes_reg[15:8] <= in;\n        end\n        else if(next_state == DONE)begin\n            out_bytes_reg[7:0] <= in;\n        end\n        else begin\n            out_bytes_reg <= 24'd0;\n        end\n    end\n    // New: Datapath to store incoming bytes.\n    assign done = (state == DONE);\n    assign out_bytes = out_bytes_reg;\n\nendmodule\n```\n\n------\n\n## 结语\n\n今天就先更新这三题吧，若代码有错误希望大家及时指出，我会尽快改正。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(16)_Verilog有限状态机(3)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(16)_Verilog有限状态机(3)/","content":"\n# Verilog有限状态机(3)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天继续更新状态机小节的习题，本章主要编写Lemmings Game部分。\n\n------\n\n## 题库\n\n**题目描述10：**\n\nGame Lemmings1：有个小人左右走，它只有两种状态：向左走和向右走；左边碰到东西之后它就向右走，右边碰到东西之后它就向左走，两边都碰到东西就跟当前方向的反方向走；复位时小人向左走\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232201455.png)\n\n**Solution10：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,    // Freshly brainwashed Lemmings walk left.\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right); //  \n\n    parameter LEFT=1'b0, RIGHT=1'b1;\n    reg state, next_state;\n    wire [1:0] bump;\n    assign bump = {bump_left,bump_right};\n\n    always @(*) begin\n        case(state)\n        \tLEFT:begin\n                if((bump == 2'b10) || (bump == 2'b11))begin\n                    next_state = RIGHT;\n                end\n                else begin\n                    next_state = LEFT;\n                end\n            end\n            RIGHT:begin\n                if((bump == 2'b01) || (bump == 2'b11))begin\n                    next_state = LEFT;\n                end\n                else begin\n                    next_state = RIGHT;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk, posedge areset) begin\n        if(areset)begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule\n```\n\n**题目描述11：**\n\nGame Lemmings2：有个小人左右走，它只有两种状态：向左走和向右走；左边碰到东西之后它就向右走，右边碰到东西之后它就向左走，两边都碰到东西就跟当前方向的反方向走；复位时小人向左走；\n\n添加ground信号，ground=1时规则与上述规则相同；ground=0时，记录当前走的方向，并将aaah信号置1，直到ground=1时，走与掉落之前相同的方向。\n\n**Solution11：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,    // Freshly brainwashed Lemmings walk left.\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah ); \n    \n    parameter LEFT = 2'b0;\n    parameter RIGHT = 2'b1;\n    parameter AH_LEFT = 2'b10;\n    parameter AH_RIGHT = 2'b11;\n    reg [1:0] state,next_state;\n    wire [1:0] bump;\n    assign bump = {bump_left,bump_right};\n    \n    always @(*)begin\n        case(state)\n        \tLEFT:begin\n                if(ground == 1'b0)begin\n                \tnext_state = AH_LEFT;\n                end\n                else if((bump == 2'b10) || (bump == 2'b11))begin\n                    next_state = RIGHT;\n                end\n                else begin\n                    next_state = LEFT;\n                end\n            end\n            RIGHT:begin\n                if(ground == 1'b0)begin\n                    next_state = AH_RIGHT;\n                end\n                else if((bump == 2'b01) || (bump == 2'b11))begin\n                    next_state = LEFT;\n                end\n                else begin\n                \tnext_state = RIGHT;\n                end\n            end\n            AH_LEFT:begin\n                if(ground == 1'b0)begin\n                \tnext_state = AH_LEFT;\n                end\n                else begin\n                \tnext_state = LEFT;\n                end\n            end\n            AH_RIGHT:begin\n                if(ground == 1'b0)begin\n                \tnext_state = AH_RIGHT;\n                end\n                else begin\n                \tnext_state = RIGHT;\n                end\n            end\n        endcase\n    end\n    \n    always@(posedge clk,posedge areset)begin\n        if(areset)begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = ((state == AH_LEFT) | (state == AH_RIGHT));\n\nendmodule\n```\n\n**题目描述12：**\n\nGame Lemmings3：有个小人左右走，它只有两种状态：向左走和向右走；左边碰到东西之后它就向右走，右边碰到东西之后它就向左走，两边都碰到东西就跟当前方向的反方向走；复位时小人向左走；\n\n添加ground信号，ground=1时规则与上述规则相同；ground=0时，记录当前走的方向，并将aaah信号置1，直到ground=1时，走与掉落之前相同的方向。\n\n添加dig信号，ground=1时一直挖，ground=0时，进入aaah状态，直到ground再次为1，方向与dig开始的方向相同。\n\n优先级：fall>dig>switch direction\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232201905.png)\n\n**Solution12：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,    // Freshly brainwashed Lemmings walk left.\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging ); \n\n    parameter LEFT = 3'b0;\n    parameter RIGHT = 3'b1;\n    parameter DIG_LEFT = 3'b10;\n    parameter DIG_RIGHT = 3'b11;\n    parameter FALL_LEFT = 3'b100;\n    parameter FALL_RIGHT = 3'b101;\n    \n    reg [2:0] state,next_state;\n    wire [1:0] bump;\n    assign bump = {bump_left,bump_right};\n    \n    always @(*)begin\n        case(state)\n            LEFT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_LEFT;\n                end\n                else if(dig == 1'b1)begin\n                    next_state = DIG_LEFT;\n                end\n                else if((bump == 2'b10) || (bump == 2'b11))begin\n                    next_state = RIGHT;\n                end\n                else begin\n                \tnext_state = LEFT;\n                end\n            end\n            RIGHT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_RIGHT;\n                end\n                else if(dig == 1'b1)begin\n                    next_state = DIG_RIGHT;\n                end\n                else if((bump == 2'b01) || (bump == 2'b11))begin\n                    next_state = LEFT;\n                end\n                else begin\n                \tnext_state = RIGHT;\n                end\n            end\n            DIG_LEFT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_LEFT;\n                end\n                else begin\n                    next_state = DIG_LEFT;\n                end\n            end\n            DIG_RIGHT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_RIGHT;\n                end\n                else begin\n                    next_state = DIG_RIGHT;\n                end\n            end\n            FALL_LEFT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_LEFT;\n                end\n                else begin\n                    next_state = LEFT;\n                end\n            end\n            FALL_RIGHT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_RIGHT;\n                end\n                else begin\n                    next_state = RIGHT;\n                end\n            end\n        endcase\n    end\n    \n    always @(posedge clk,posedge areset)begin\n        if(areset)begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign digging = ((state == DIG_LEFT) | (state == DIG_RIGHT));\n    assign aaah = ((state == FALL_LEFT) | (state == FALL_RIGHT));\n    \nendmodule\n```\n\n**题目描述13：**\n\nGame Lemmings4：小人行动规则与上述规则相同，添加小人会die的规则：\n\n如果小人fall超过20cycles，则当其接触地面时直接die（未接触地面时不会die）。dig，fall，left和right输出全部置零，直到reset信号来临。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232201725.png)\n\n手绘状态转移图：(Dead状态少个自己到自己的状态)\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232201610.png)\n\n**Solution13：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,    // Freshly brainwashed Lemmings walk left.\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging ); \n    \n    parameter LEFT = 3'b0;\n    parameter RIGHT = 3'b1;\n    parameter DIG_LEFT = 3'b10;\n    parameter DIG_RIGHT = 3'b11;\n    parameter FALL_LEFT = 3'b100;\n    parameter FALL_RIGHT = 3'b101;\n    parameter DEAD = 3'b110;\n    parameter SPLATTER = 3'b111;\n    \n    reg [2:0] state,next_state;\n    reg [4:0] Cycle_Count;\n    \n    wire [1:0] bump;\n    assign bump = {bump_left,bump_right};\n    \n    always @(*)begin\n        case(state)\n            LEFT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_LEFT;\n                end\n                else if(dig == 1'b1)begin\n                    next_state = DIG_LEFT;\n                end\n                else if((bump == 2'b10) || (bump == 2'b11))begin\n                    next_state = RIGHT;\n                end\n                else begin\n                    next_state = LEFT;\n                end\n            end\n            \n            RIGHT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_RIGHT;\n                end\n                else if(dig == 1'b1)begin\n                    next_state = DIG_RIGHT;\n                end\n                else if((bump == 2'b01) || (bump == 2'b11))begin\n                    next_state = LEFT;\n                end\n                else begin\n                    next_state = RIGHT;\n                end\n            end\n            \n            DIG_LEFT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_LEFT;\n                end\n                else begin\n                    next_state = DIG_LEFT;\n                end\n            end\n            \n            DIG_RIGHT:begin\n                if(ground == 1'b0)begin\n                    next_state = FALL_RIGHT;\n                end\n                else begin\n                    next_state = DIG_RIGHT;\n                end\n            end\n            \n            FALL_LEFT:begin\n                if((ground == 1'b0) && (Cycle_Count < 5'd20))begin\n                    next_state = FALL_LEFT;\n                end\n                else if((ground == 1'b0) && (Cycle_Count >= 5'd20))begin\n                    next_state = SPLATTER;\n                end\n                else begin\n                    next_state = LEFT;\n                end\n            end\n            \n            FALL_RIGHT:begin\n                if((ground == 1'b0) && (Cycle_Count < 5'd20))begin\n                    next_state = FALL_RIGHT;\n                end\n                else if((ground == 1'b0) && (Cycle_Count >= 5'd20))begin\n                    next_state = SPLATTER;\n                end\n                else begin\n                    next_state = RIGHT;\n                end\n            end\n            \n            SPLATTER:begin\n                if(ground == 1'b1)begin\n                    next_state = DEAD;\n                end\n                else begin\n                    next_state = SPLATTER;\n                end\n            end\n            \n            DEAD:begin\n                next_state = DEAD;\n            end\n            \n        endcase\n    end\n    \n    always @(posedge clk,posedge areset)begin\n        if(areset)begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    always @(posedge clk,posedge areset)begin\n        if(areset)begin\n            Cycle_Count <= 5'd0;\n        end\n        else if((next_state == FALL_LEFT) || (next_state == FALL_RIGHT)) begin\n            Cycle_Count <= Cycle_Count + 1'b1;\n        end\n        else begin\n            Cycle_Count <= 5'd0;\n        end\n    end\n    \n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = ((state == FALL_LEFT) || (state == FALL_RIGHT) || (state == SPLATTER));\n    assign digging = ((state == DIG_LEFT) || (state == DIG_RIGHT));\n\nendmodule\n```\n\n------\n\n## 结语\n\n今天更新的几道旅鼠题非常有意思，大家可以先自己尝试。代码若有问题的话可以与我交流。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(15)_Verilog有限状态机(2)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(15)_Verilog有限状态机(2)/","content":"\n\n\n# Verilog有限状态机(2)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n继续更新状态机小节的习题。\n\n------\n\n## 题库\n\n**题目描述6：**\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232200542.png)\n\n**Solution6：**\n\n```verilog\nmodule top_module(\n    input in,\n    input [3:0] state,\n    output [3:0] next_state,\n    output out); //\n\n    parameter A=0, B=1, C=2, D=3;\n\n    // State transition logic: Derive an equation for each state flip-flop.\n    assign next_state[A] = (state[A]&~in) | (state[C] & ~in);\n    assign next_state[B] = (state[A]&in) | (state[D]&in) | (state[B]&in);\n    assign next_state[C] = (state[B]&~in) | (state[D]&~in);\n    assign next_state[D] = (state[C]&in);\n\n    // Output logic: \n    assign out = (state[D]);\n\nendmodule\n```\n\n本题中作者想让我们以one-hot(独热码)的编码逻辑来完成。一般状态机为了方便编码都是设置为二进制；但若状态转移是**按顺序进行转移**的话，我们可以使用**格雷码**，因为两相邻状态之间只变化1bit，这样可以节约功耗；若想**提升速度**，可以使用**one-hot编码**，因为每次仅需判断一位，这是用**寄存器资源换组合逻辑资源**，以达到**更高的速度**。\n\n**题目描述7：**\n\n题目与上题相同，区别为异步复位，复位至状态A。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232200918.png)\n\n**Solution7：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input in,\n    input areset,\n    output out); //\n\n    parameter A=2'd0,B=2'd1,C=2'd2,D=2'd3;\n    reg [1:0] state,next_state;\n    \n    always @(*)begin\n        case(state)\n            A:begin\n                if(in == 0)begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            B:begin\n            \tif(in == 0)begin\n                    next_state = C;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            C:begin\n            \tif(in == 0)begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = D;\n                end\n            end\n            D:begin\n                if(in == 0)begin\n                    next_state = C;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk,posedge areset)begin\n        if(areset)begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    assign out = (state == D);\n\nendmodule\n```\n\n**题目描述8：**\n\n题目同上题，将复位改为同步复位。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232200315.png)\n\n**Solution8：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input in,\n    input reset,\n    output out); //\n\nparameter A=2'd0,B=2'd1,C=2'd2,D=2'd3;\n    reg [1:0] state,next_state;\n    \n    always @(*)begin\n        case(state)\n            A:begin\n                if(in == 0)begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            B:begin\n            \tif(in == 0)begin\n                    next_state = C;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            C:begin\n            \tif(in == 0)begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = D;\n                end\n            end\n            D:begin\n                if(in == 0)begin\n                    next_state = C;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk)begin\n        if(reset)begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    assign out = (state == D);\n\nendmodule\n```\n\n**题目描述9：**\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232201397.png)\n\n**Solution9：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output fr3,\n    output fr2,\n    output fr1,\n    output dfr\n); \n    \n    parameter A2=3'd0,B1=3'd1,B2=3'd2,C1=3'd3,C2=3'd4,D1=3'd5;\n    reg [2:0] state,next_state;\n    \n    always @(*)begin\n        case(state)\n            A2:next_state = s[1]?B1:A2;\n            B1:next_state = s[2]?C1:(s[1]?B1:A2);\n            B2:next_state = s[2]?C1:(s[1]?B2:A2);\n            C1:next_state = s[3]?D1:(s[2]?C1:B2);\n            C2:next_state = s[3]?D1:(s[2]?C2:B2);\n            D1:next_state = s[3]?D1:C2;\n            default:next_state = 'x;\n        endcase\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n        \tstate <= A2;\n        end\n        else begin\n        \tstate <= next_state;\n        end\n    end\n    \n    always @(*)begin\n        case(state)\n            A2:{fr3,fr2,fr1,dfr} = 4'b1111;\n            B1:{fr3,fr2,fr1,dfr} = 4'b0110;\n            B2:{fr3,fr2,fr1,dfr} = 4'b0111;\n            C1:{fr3,fr2,fr1,dfr} = 4'b0010;\n            C2:{fr3,fr2,fr1,dfr} = 4'b0011;\n            D1:{fr3,fr2,fr1,dfr} = 4'b0000;\n            default:{fr3,fr2,fr1,dfr} = 'x;\n        endcase\n    end\n\nendmodule\n```\n\n------\n\n## 小结\n\n今天先更新这几道题目，重点是one-hot编码部分，了解其与格雷码的优缺点。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(14)_Verilog有限状态机(1)","url":"/2022/09/12/IC/HDLBits/HDLBits答案(14)_Verilog有限状态机(1)/","content":"\n\n\n# Verilog有限状态机(1)\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天来到了重要的部分：状态机。对该部分内容，可能不会一次更新一个小节；一方面是题目难度，另一方面是代码量过大；所以该节会分批更新，大家见谅。\n\n------\n\n## 题库\n\n**题目描述1：**\n\n实现下图所示的摩尔状态机，复位为异步复位。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232159453.png)\n\n**Solution1：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,    // Asynchronous reset to state B\n    input in,\n    output out);//  \n\n    parameter A=0, B=1; \n    reg state, next_state;\n\n    always @(*) begin    // This is a combinational always block\n        case(state)\n            A:begin\n                if(in == 1'b1)begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            B:begin\n                if(in == 1'b1)begin\n                    next_state = B;\n                end\n                else begin\n                    next_state = A;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk, posedge areset) begin    // This is a sequential always block\n        if(areset)begin\n            state <= B;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule\n```\n\n**题目描述2：**\n\n实现下图所示的摩尔状态机，复位为同步复位。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232159568.png)\n\n**Solution2：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,    // Asynchronous reset to state B\n    input in,\n    output out);//  \n\n    parameter A=0, B=1; \n    reg state, next_state;\n\n    always @(*) begin    // This is a combinational always block\n        case(state)\n            A:begin\n                if(in == 1'b1)begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            B:begin\n                if(in == 1'b1)begin\n                    next_state = B;\n                end\n                else begin\n                    next_state = A;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin    // This is a sequential always block\n        if(reset)begin\n            state <= B;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule\n```\n\n**题目描述3：**\n\n2个输入1个输出，异步复位状态机，如下图所示。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232200570.png)\n\n**Solution3：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,    // Asynchronous reset to OFF\n    input j,\n    input k,\n    output out); //  \n\n    parameter OFF=0, ON=1; \n    reg state, next_state;\n\n    always @(*) begin\n        case(state)\n            OFF:begin\n                if(j == 0)begin\n                    next_state = OFF;\n                end\n                else begin\n                    next_state = ON;\n                end\n            end\n            ON:begin\n                if(k == 0)begin\n                    next_state = ON;\n                end\n                else begin\n                    next_state = OFF;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk, posedge areset) begin\n        if(areset)begin\n            state <= OFF;\n        end\n        else begin\n        \tstate <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule\n```\n\n**题目描述4：**\n\n2个输入1个输出，同步复位状态机，如下图所示。\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232200594.png)\n\n**Solution4：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,    // Synchronous reset to OFF\n    input j,\n    input k,\n    output out); //  \n\n    parameter OFF=0, ON=1; \n    reg state, next_state;\n\n    always @(*) begin\n        case(state)\n            OFF:begin\n                if(j == 0)begin\n                    next_state = OFF;\n                end\n                else begin\n                \tnext_state = ON;\n                end\n            end\n            ON:begin\n                if(k == 0)begin\n                    next_state = ON;\n                end\n                else begin\n                \tnext_state = OFF;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(reset)begin\n            state <= OFF;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule\n```\n\n**题目描述5：**\n\n实现下面的摩尔状态机，下表是状态转移图，1输入1输出4状态。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232200717.png)\n\n**Solution5：**\n\n```verilog\nmodule top_module(\n    input in,\n    input [1:0] state,\n    output [1:0] next_state,\n    output out); //\n\n    parameter A=0, B=1, C=2, D=3;\n\n    always @(*)begin\n        case(state)\n            A:begin\n                if(in == 0)begin\n                \tnext_state = A;\n                end\n                else begin\n                \tnext_state = B;\n                end\n            end\n            B:begin\n                if(in == 0)begin\n                \tnext_state = C;\n                end\n                else begin\n                \tnext_state = B;\n                end\n            end\n            C:begin\n                if(in == 0)begin\n                \tnext_state = A;\n                end\n                else begin\n                \tnext_state = D;\n                end\n            end\n            D:begin\n                if(in == 0)begin\n                \tnext_state = C;\n                end\n                else begin\n                \tnext_state = B;\n                end\n            end\n        endcase\n    end\n\n    assign out = (state == D);\n\nendmodule\n```\n\n------\n\n## 小结\n\n今天先更新这五道题，主要是熟悉三段式状态机的编写。\n\n若是代码有误请大家提醒我，我一定尽快改正。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(13)_Verilog移位寄存器","url":"/2022/09/12/IC/HDLBits/HDLBits答案(13)_Verilog移位寄存器附加题/","content":"\n\n\n# Verilog移位寄存器\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新一节内容，该小节题目不多，共三道，但技巧性挺强。\n\n------\n\n## 题库\n\n**题目描述1：**各单元的下一状态是此时当前单元相邻两位的异或。\n\n在这个电路中，创建一个512单元系统(q(511:0))，并在每个时钟周期中前进一个时间步长。加载(load)表明系统的状态应该加载data[511:0]至q中,假设边界(q[0]和q[512])都为零。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232159622.png)\n\n**Solution1：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output [511:0] q ); \n\n    always @(posedge clk)begin\n        if(load)begin\n            q <= data;\n        end\n        else begin\n            q <= {1'b0,q[511:1]}^{q[510:0],1'b0};\n        end\n    end\n    \nendmodule\n```\n\n**题目描述2：**\n\n与题目一类似，状态转移条件发生变化，如下图所示：\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232159099.png)\n\n**Solution2：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output [511:0] q\n); \n\n    always @(posedge clk)begin\n        if(load)begin\n        \tq <= data;\n        end\n        else begin \n            q <= (~{1'b0,q[511:1]} & q) | (q & ~{q[510:0],1'b0}) | {~{1'b0,q[511:1]} & {q[510:0],1'b0}} | {~q & {q[510:0],1'b0}};\n        end\n    end\n    \nendmodule\n```\n\ntips：进行卡诺图化简后可看懂q状态转移的含义。\n\n**题目描述3：**\n\n一个中心点周围有8个邻居，如果周围的邻居中1的数目为0-1个，那么中心点变为0；如果周围邻居中1的数目为2个，那么中心点状态不变；如果周围邻居中1的数目为3个，中心点变为1；如果周围邻居中1的数目大于3个，中心点变为0。\n\n我们可以将周围的8个邻居的值都加起来来判断周围邻居中1的个数，值得注意的是，这里我们在**for中使用了阻塞赋值**，因需要**当前拍（本周期）得到结果在当前拍（本周期）就去判断**。\n\n建议大家做该题的时候花一个16*16的方阵，分析边界条件，达到事半功倍的效果。\n\n*生命游戏之父约翰·康威因感染新冠于2020年4月11日去世，享年83岁，在此表示哀悼。*\n\n**Solution3：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output [255:0] q );\n    \n    reg [3:0] count[255:0];\n    integer i;\n    \n    always @(*) begin\n        for(i=0;i<256;i++)begin\n            if(i == 0)begin\n                count[i] = q[255] + q[240] + q[241] + q[15] + q[1] + q[31] + q[16] + q[17];\n            end\n            else if(i == 15)begin\n                count[i] = q[254] + q[255] + q[240] + q[14] + q[0] + q[30] + q[31] + q[16];\n            end\n            else if(i == 240)begin\n                count[i] = q[239] + q[224] + q[225] + q[255] + q[241] + q[15] + q[0] + q[1];\n            end\n            else if(i == 255)begin\n                count[i] = q[238] + q[239] + q[224] + q[254] + q[240] + q[15] + q[0] + q[14];\n            end\n            else if( i>0 && i<15)begin\n                count[i] = q[239+i]+q[240+i]+q[241+i]+q[i-1]+q[i+1]+q[i+15]+q[i+16]+q[i+17];\n            end\n            else if(i>240 && i<255)begin\n                count[i] = q[i-17]+q[i-16]+q[i-15]+q[i-1]+q[i+1]+q[i-239]+q[i-240]+q[i-241];\n            end\n            else if( i%16 == 0)begin\n                count[i] = q[i-1]+q[i-16]+q[i-15]+q[i+15]+q[i+1]+q[i+31]+q[i+16]+q[i+17];\n            end\n            else if(i % 16 == 15)begin\n                count[i] = q[i-17]+q[i-16]+q[i-31]+q[i-1]+q[i-15]+q[i+15]+q[i+16]+q[i+1];\n            end\n            else begin\n                count[i] = q[i-17]+q[i-16]+q[i-15]+q[i-1]+q[i+1]+q[i+15]+q[i+16]+q[i+17];\n            end\n        end\n    end\n    \n    always @(posedge clk)begin\n        if(load)begin\n        \tq <= data;\n        end\n        else begin\n            for(i=0;i<256;i++)begin\n                case(count[i])\n                    4'd2:q[i] <= q[i];\n                    4'd3:q[i] <= 1'b1;\n                    default:q[i] <= 1'b0;\n                endcase\n            end\n        end\n    end\n\nendmodule\n```\n\n------\n\n## 小结\n\n希望自己以后遇到问题能够慢慢划分解决，徐图缓进。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(12)_Verilog移位寄存器","url":"/2022/09/12/IC/HDLBits/HDLBits答案(12)_Verilog移位寄存器/","content":"\n# Verilog移位寄存器\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新一节寄存器相关内容，其中涉及CRC校验的内容是用线性反馈移位寄存器搭建而成的。\n\n------\n\n## 题库\n\n**题目描述1：**\n\n构建一个4bit的移位寄存器(右移)，含异步复位、同步加载和使能\n\n- areset：让寄存器复位为0\n- load：加载4bit数据到移位寄存器中，不移位\n- ena：使能右移\n- q：移位寄存器中的内容\n\n**Solution1：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q); \n    \n    always @(posedge clk or posedge areset)begin\n        if(areset)begin\n            q <= 4'b0;\n        end\n        else if(load) begin\n            q <= data;\n        end\n        else if(ena)begin\n            q <= {1'b0,q[3:1]};\n        end\n        else begin\n            q <= q;\n        end\n    end\n\nendmodule\n```\n\n**题目描述2：**\n\n构建一个100位的左右旋转器，同步load，左右旋转需使能。旋转器从另一端输入移位的位元，不像移位器那样丢弃移位的位元而以零位移位。如果启用，旋转器就会旋转这些位，而不会修改或丢弃它们。\n\n- load：加载100位的移位寄存器数据\n- ena[1:0]：2'b01 右转1bit； 2'b10 左转1bit；其他情况不转\n- q：旋转器内容\n\n**Solution2：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n    \n    always @(posedge clk) begin\n        if(load) begin\n            q <= data;\n        end\n        else begin\n            case (ena)\n                2'b01:q <= {q[0],q[99:1]};\n                2'b10:q <= {q[98:0],q[99]};\n                default:q <= q;\n            endcase\n        end\n    end\n\nendmodule\n```\n\n**题目描述3：**\n\n建立一个64位算术移位寄存器，同步加载。移位器可以左右移位，并按数量选择1位或8位的移位。\n\n- load：加载数据\n- ena：决定是否移位\n- amount：决定移位方向与数量：2'b00：左移1位；2'b01：左移8位；2'b10：右移1位；2'b11：右移8位\n- q：寄存器内容（输出）\n\n**Solution3：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q); \n    \n    always @(posedge clk)begin\n        if(load)begin\n            q <= data;\n        end\n        else begin\n            if(ena)begin\n                case(amount)\n                    2'b00: q <= {q[62:0],1'b0};\n                    2'b01: q <= {q[55:0],8'b0};\n                    2'b10: q <= {q[63],q[63:1]};\n                    2'b11: q <= {{8{q[63]}},q[63:8]};\n                endcase\n            end\n            else begin\n                q <= q;\n            end\n        end\n    end\n\nendmodule\n```\n\n**题目描述4：**\n\n构造线性移位寄存器，reset应当使LFSR归1。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232158306.png)\n\n**Solution4：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,    // Active-high synchronous reset to 5'h1\n    output [4:0] q\n); \n    \n    always @(posedge clk)begin\n        if(reset)begin\n            q <= 5'h1;\n        end\n        else begin\n            q[4] <= 1'b0 ^ q[0];\n            q[3] <= q[4];\n            q[2] <= q[3] ^ q[0];\n            q[1] <= q[2];\n            q[0] <= q[1];\n        end\n    end\n\nendmodule\n```\n\n**题目描述5：**\n\n为这个序列电路编写Verilog代码。假设你要在DE1-SoC板上实现这个电路。将R输入连接到SW开关，将时钟连接到密钥[0]，将L连接到密钥[1]，将Q输出连接到红灯LEDR上。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232158220.png)\n\n**Solution5：**\n\n```verilog\nmodule top_module (\n\tinput [2:0] SW,      // R\n\tinput [1:0] KEY,     // L and clk\n\toutput [2:0] LEDR);  // Q\n\n    wire clk;\n    assign clk = KEY[0];\n    \n    always @(posedge clk)begin\n        if(KEY[1])begin\n            LEDR[0] <= SW[0];\n            LEDR[1] <= SW[1];\n            LEDR[2] <= SW[2];\n        end\n        else begin\n            LEDR[0] <= LEDR[2];\n            LEDR[1] <= LEDR[0];\n            LEDR[2] <= LEDR[2] ^ LEDR[1];\n        end\n    end\n\nendmodule\n```\n\n**题目描述5：**\n\n构建一个32位的Galois LFSR，其taps位置为32、22、2和1。\n\n**Solution5：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,    // Active-high synchronous reset to 32'h1\n    output [31:0] q\n); \n    integer i;\n    always @(posedge clk)begin\n        if(reset)begin\n            q <= 32'h1;\n        end\n        else begin\n            for(i=0;i<32;i++)begin\n                if((i==21)||(i==1)||(i==0))begin\n                    q[i] <= q[i+1] ^ q[0];\n                end\n                else if(i==31)begin\n                    q[31] <= 1'b0 ^ q[0];\n                end\n                else begin\n                    q[i] <= q[i+1];\n                end  \n            end\n        end\n    end\n\nendmodule\n```\n\n**题目描述6：**实现如下电路图\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232158765.png)\n\n**Solution6：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,   // synchronous reset\n    input in,\n    output out);\n\n    reg [3:0] tmp;\n    assign out = tmp[3];\n    \n    always @(posedge clk)begin\n        if(!resetn)begin\n            tmp <= 4'h0;\n        end\n        else begin\n            tmp <= {tmp[2:0],in};\n        end\n    end\n    \nendmodule\n```\n\n**题目描述7：**实现如下电路图\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232159971.png)\n\n- Connect the *R* inputs to the *SW* switches,\n- *clk* to *KEY[0]*,\n- *E* to *KEY[1]*,\n- *L* to *KEY[2]*, and\n- *w* to *KEY[3]*.\n- Connect the outputs to the red lights *LEDR[3:0]*.\n\n**Solution7：**\n\n```verilog\nmodule top_module (\n    input [3:0] SW,\n    input [3:0] KEY,\n    output [3:0] LEDR\n); \n    \n    MUXDFF u1(.clk(KEY[0]),\n               .w(KEY[3]),\n               .R(SW[3]),\n               .E(KEY[1]),\n               .L(KEY[2]),\n               .Q(LEDR[3]));\n    \n    MUXDFF u2(.clk(KEY[0]),\n               .w(LEDR[3]),\n               .R(SW[2]),\n               .E(KEY[1]),\n               .L(KEY[2]),\n               .Q(LEDR[2]));\n    \n    MUXDFF u3(.clk(KEY[0]),\n               .w(LEDR[2]),\n               .R(SW[1]),\n               .E(KEY[1]),\n               .L(KEY[2]),\n               .Q(LEDR[1]));\n    \n    MUXDFF u4(.clk(KEY[0]),\n               .w(LEDR[1]),\n               .R(SW[0]),\n               .E(KEY[1]),\n               .L(KEY[2]),\n               .Q(LEDR[0]));\n    \nendmodule\n\nmodule MUXDFF (\n    input clk,\n    input w,R,E,L,\n    output Q\n);\n    wire tmp;\n    assign tmp = E ? w : Q;\n    always @(posedge clk)begin\n        Q <= L? R : tmp;\n    end\n\nendmodule\n```\n\n**题目描述8：**\n\n在这个问题中，你将为一个8x1存储器设计一个电路，在这个电路中，写入到存储器是通过移位来完成的，而读取是“随机访问”，就像在一个典型的RAM中一样。然后您将使用该电路实现一个3输入逻辑功能。\n\n首先，用8个d类型触发器创建一个8位移位寄存器。标记为Q[0]到Q[7]。移位寄存器输入称为S，输入Q[0] (MSB先移位)。使能输入enable控制是否移位，扩展电路使其有3个额外的输入A,B,C和一个输出Z。电路的行为应该如下:当ABC为000时，Z=Q[0]，当ABC为001时，Z=Q[1]，以此类推。你的电路应该只包含8位移位寄存器和多路复用器。(这个电路称为3输入查找表(LUT))。\n\n**Solution8：**\n\n```Verilog\nmodule top_module (\n    input clk,\n    input enable,\n    input S,\n    input A, B, C,\n    output Z ); \n    \n    reg [7:0] Q;\n    always @(posedge clk)begin\n        if(enable)begin\n            Q <= {Q[6:0],S};\n        end\n        else begin\n            Q <= Q;\n        end\n    end\n    \n    assign Z = Q[{A,B,C}];\n\nendmodule\n```\n\n------\n\n## 小结\n\n今天更新了部分移位寄存器部分的答案，注意最后一题用了一些技巧来简化代码书写，但实现时电路并无差异，体现了HDL中Describe的特性。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(11)_Verilog计数器","url":"/2022/09/12/IC/HDLBits/HDLBits答案(11)_Verilog计数器/","content":"\n# Verilog计数器\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 前言\n\n今天更新一个小节内容：计数器。计数器可以说是我们接触数字电路以后用的最频繁的模块之一了，无论是项目、应聘还是将来的工作，计数器都无处不在。\n\n------\n\n## 题库\n\n**题目描述1：**\n\n构建一个从0到15的4位二进制计数器，周期为16。同步复位，复位应该将计数器重置为0。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232156509.png)\n\n**Solution1：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output [3:0] q);\n\n    always @(posedge clk)begin\n        if(reset)begin\n            q<=4'b0;\n        end\n        else begin\n            q<=q+1'b1;\n        end\n    end\n    \nendmodule\n```\n\n**题目描述2：**\n\n构建一个从0到9(包括9)的十进制计数器，其周期为10。同步复位，复位应该将计数器重置为0。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232156617.png)\n\n**Solution2：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,        // Synchronous active-high reset\n    output [3:0] q);\n\n    always @(posedge clk)begin\n        if(reset || q >= 4'd9)begin\n            q<=4'b0;\n        end\n        else begin\n            q<=q+1'b1;\n        end\n    end\n    \nendmodule\n```\n\n**题目描述3：**\n\n制作一个从1到10的10进制计数器。同步复位，复位应该将计数器复位为1。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232156406.png)\n\n**Solution3：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    output [3:0] q);\n\n    always @(posedge clk)begin\n        if(reset || q>=4'd10)begin\n            q<=4'b1;\n        end\n        else begin\n            q<=q+1'b1;\n        end\n    end\n    \nendmodule\n```\n\n**题目描述4：**\n\n构建一个从0到9(包括9)的十进制计数器，其周期为10。同步复位，复位应该将计数器重置为0。我们希望能够暂停计数器，而不是总是在每个时钟周期中递增，因此`slowena`输入指示计数器应该何时递增。\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232156120.png)\n\n**Solution4:**\n\n```verilog\nmodule top_module (\n    input clk,\n    input slowena,\n    input reset,\n    output [3:0] q);\n\n    always @(posedge clk)begin\n        if(reset)begin\n            q<=4'b0;\n        end\n        else if(slowena)begin\n            if(q==4'd9)begin\n                q<=4'b0;\n            end\n            else begin\n                q<=q+1'b1;\n            end\n        end\n    end\n    \nendmodule\n```\n\n**题目描述4：**\n\n设计一个1-12计数器\n\n**Solution4：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input enable,\n    output [3:0] Q,\n    output c_enable,\n    output c_load,\n    output [3:0] c_d\n); \n    \n    assign c_enable = enable;\n    assign c_load = reset | ((Q == 4'd12) && (enable == 1'b1));\n    assign c_d = c_load ? 4'd1 : 4'd0;\n    \n    count4 the_counter (clk, c_enable, c_load, c_d , Q);\n\nendmodule\n```\n\n**题目描述5：**\n\n例化BCD模块实现降频操作，1kHz->1Hz。\n\n**Solution5：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    output OneHertz,\n    output [2:0] c_enable\n); //\n\twire[3:0]\tone, ten, hundred;\n    assign c_enable = {one == 4'd9 && ten == 4'd9, one == 4'd9, 1'b1};\n    assign OneHertz = (one == 4'd9 && ten == 4'd9 && hundred == 4'd9);\n    \n    bcdcount counter0 (clk, reset, c_enable[0], one);\n    bcdcount counter1 (clk, reset, c_enable[1], ten);\n    bcdcount counter2 (clk, reset, c_enable[2], hundred);\n\nendmodule\n```\n\n**题目描述6：**\n\n构建一个4位BCD(二进制编码的十进制)计数器。每个十进制数字使用4位进行编码:q[3:0]是个位，q[7:4]是十位，以此类推。各进制上的进位时也需输出一个使能信号，指示三位数字何时应该增加。\n\n**Solution6：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output [3:1] ena,\n    output [15:0] q);\n    \n    reg [3:0] ones;\n    reg [3:0] tens;\n    reg [3:0] hundreds;\n    reg [3:0] thousands;\n    \n    always @(posedge clk) begin\n        if(reset)begin\n            ones <= 4'b0;\n        end\n        else if(ones == 4'd9)begin\n            ones <=4'b0;\n        end\n        else begin\n            ones <= ones + 4'd1;\n        end\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n            tens <= 4'b0;\n        end\n        else if(tens == 4'd9 && ones == 4'd9)begin\n            tens <= 4'b0;\n        end\n        else if(ones == 4'd9)begin\n            tens <= tens + 4'd1;\n        end\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n            hundreds <= 4'b0;\n        end\n        else if(hundreds == 4'd9 && tens == 4'd9 && ones == 4'd9)begin\n            hundreds <= 4'b0;\n        end\n        else if(tens == 4'd9 && ones == 4'd9) begin\n            hundreds <= hundreds + 4'd1;\n        end\n    end\n    \n    always @(posedge clk)begin\n        if(reset)begin\n            thousands <= 4'b0;\n        end\n        else if(thousands == 4'd9 && hundreds == 4'd9 && tens == 4'd9 && ones == 4'd9)begin\n            thousands <= 4'b0;\n        end\n        else if(hundreds == 4'd9 && tens == 4'd9 && ones == 4'd9)begin\n            thousands <= thousands + 4'd1;\n        end\n    end\n    \n    assign q = {thousands,hundreds,tens,ones};\n    assign ena[1] = (ones == 4'd9) ? 1'b1 : 1'b0;\n    assign ena[2] = ((ones == 4'd9) && (tens == 4'd9)) ? 1'b1 : 1'b0;\n    assign ena[3] = ((ones == 4'd9) && (tens == 4'd9) && (hundreds == 4'd9)) ? 1'b1 : 1'b0;\n\nendmodule\n```\n\n**题目描述7：**\n\n创建一组适合作为12小时的时钟使用的计数器(带有am/pm指示器)。你的计数器是由一个快速运行的clk驱动，每次时钟增加时ena必须为1。reset将时钟重置到中午12点。上午时pm=0，下午时pm=0。hh，mm和ss分别是小时(01-12)、分钟(00-59)和秒(00-59)的两个BCD(二进制编码的十进制)数字。\n\nReset比enable具有更高的优先级，并且即使在没有启用时也会发生。\n\n下面的时序图显示了从11:59:59 AM到12:00:00 PM的翻转行为以及同步的Reset和enable行为。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232158544.png)\n\n**Solution7：**\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,\n    input ena,\n    output pm,\n    output [7:0] hh,\n    output [7:0] mm,\n    output [7:0] ss); \n    \n    reg pm_temp;\n    reg [3:0] ss_ones;\n    reg [3:0] ss_tens;\n    reg [3:0] mm_ones;\n    reg [3:0] mm_tens;\n    reg [3:0] hh_ones;\n    reg [3:0] hh_tens;\n    \n    wire\t\tadd_ss_ones;\n    wire\t\tend_ss_ones;\n    wire\t\tadd_ss_tens;\n    wire\t\tend_ss_tens;\n    wire\t\tadd_mm_ones;\n    wire\t\tend_mm_ones;\n    wire\t\tadd_mm_tens;\n    wire\t\tend_mm_tens;\n    wire\t\tadd_hh_ones;\n    wire\t\tend_hh_ones_0;\n    wire\t\tend_hh_ones_1;\n    wire\t\tadd_hh_tens;\n    wire\t\tend_hh_tens_0;\n    wire\t\tend_hh_tens_1;\n    wire\t\tpm_ding;\n    \n    assign add_ss_ones = ena;\n    assign end_ss_ones = add_ss_ones && (ss_ones == 4'd9);\n    always @(posedge clk)begin\n        if(reset)begin\n            ss_ones <= 4'b0;\n        end\n        else if(add_ss_ones)begin\n            if(end_ss_ones)begin\n                ss_ones <= 4'b0;\n            end\n            else begin\n                ss_ones <= ss_ones + 4'b1;\n            end\n        end\n    end\n    \n    assign add_ss_tens = end_ss_ones;\n    assign end_ss_tens = add_ss_tens && (ss_tens == 4'd5);\n    always @(posedge clk)begin\n        if(reset)begin\n            ss_tens <= 4'b0;\n        end\n        else if(add_ss_tens)begin\n            if(end_ss_tens)begin\n                ss_tens <= 4'b0;\n            end\n            else begin\n                ss_tens <= ss_tens + 4'b1;\n            end\n        end\n    end\n    \n    assign add_mm_ones = end_ss_tens;\n    assign end_mm_ones = add_mm_ones && (mm_ones == 4'd9);\n    always @(posedge clk)begin\n        if(reset)begin\n            mm_ones <= 4'b0;\n        end\n        else if(add_mm_ones)begin\n            if(end_mm_ones)begin\n                mm_ones <= 4'b0;\n            end\n            else begin\n                mm_ones <= mm_ones + 4'b1;\n            end\n        end\n    end\n    \n    assign add_mm_tens = end_mm_ones;\n    assign end_mm_tens = add_mm_tens && (mm_tens == 4'd5);\n\talways @(posedge clk)begin\n        if(reset)begin\n            mm_tens <= 4'b0;\n        end\n        else if(add_mm_tens)begin\n            if(end_mm_tens)begin\n                mm_tens <= 4'b0;\n            end\n            else begin\n                mm_tens <= mm_tens + 4'b1;\n            end\n        end\n    end\n    \n    assign add_hh_ones = end_mm_tens;\n    assign end_hh_ones_0 = add_hh_ones && (hh_ones == 4'd9);\n    assign end_hh_ones_1 = add_hh_ones && ((hh_ones == 4'd2) && (hh_tens == 4'd1));\n    always @(posedge clk)begin\n        if(reset)begin\n            hh_ones <= 4'd2;\n        end\n        else if(add_hh_ones)begin\n            if(end_hh_ones_0)begin\n                hh_ones <= 4'b0;\n            end\n            else if(end_hh_ones_1)begin\n                hh_ones <= 4'b1;\n            end\n            else begin\n                hh_ones <= hh_ones+4'b1;\n            end\n        end\n    end\n\n    assign add_hh_tens = end_mm_tens;\n    assign end_hh_tens_0 = add_hh_tens && end_hh_ones_1;\n    assign end_hh_tens_1 = add_hh_tens && end_hh_ones_0;\n    always @(posedge clk)begin\n        if(reset)begin\n            hh_tens <= 4'b1;\n        end\n        else if(add_hh_tens)begin\n            if(end_hh_tens_0)begin\n                hh_tens <= 4'b0;\n            end\n            else if(end_hh_tens_1)begin\n                hh_tens <= hh_tens + 4'b1;\n            end\n        end\n    end\n    \n    always@(posedge clk)begin\n        if(reset)begin\n            pm_temp <= 1'b0;\n        end\n        else if(pm_ding)begin\n            pm_temp <= ~pm_temp;\n        end\n    end\n    \n    assign pm_ding = hh_tens == 4'd1 && hh_ones == 4'd1 && end_mm_tens;\n    \n    assign ss = {ss_tens, ss_ones};\n    assign mm = {mm_tens, mm_ones};\n    assign hh = {hh_tens, hh_ones};\n    assign pm = pm_temp;\n    \nendmodule\n```\n\n------\n\n## 总结\n\n- 熟悉了基本计数器的代码编写。\n- 时钟的进位条件应单独用assign列出，这样层次感更加清晰。\n\n","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(10)_卡诺图与最简SOP式","url":"/2022/09/12/IC/HDLBits/HDLBits答案(10)_D触发器、同步与异步复位、脉冲边沿检测/","content":"\n# D触发器、同步与异步复位、脉冲边沿检测\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## D触发器\n\n**定义：**\n\nD触发器是一个具有记忆功能的，具有两个稳定状态的信息存储器件，触发器具有两个稳定状态，即\"0\"和\"1\"，在一定的外界信号作用下，可以从一个稳定状态翻转到另一个稳定状态。在这里解释边沿触发的D触发器，D触发器在时钟脉冲CP的前沿（正跳变0→1）发生翻转，触发器的次态（下一个状态）取决于CP的脉冲上升沿到来之前D端的状态，即次态Q=D。因此，它具有置0、置1两种功能。由于在CP=1期间电路具有维持阻塞作用（即触发器的输出不变），所以在CP=1期间，D端的数据状态变化，不会影响触发器的输出状态，故边沿D触发器受干扰的可能性就降低了。\n\n**功能表：**\n\n|  D   |    CLK     |   Q    |   QN    |\n| :--: | :--------: | :----: | :-----: |\n|  0   | 时钟上升沿 |   0    |    1    |\n|  1   | 时钟上升沿 |   1    |    0    |\n|  ×   |     0      | last Q | last QN |\n|  ×   |     1      | last Q | last QN |\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232154055.png)\n\n------\n\n## 同步复位与异步复位\n\n**同步复位：**\n\n顾名思义，同步复位就是指复位信号只有在时钟上升沿到来时，才能有效。否则，无法完成对系统的复位工作。用Verilog描述如下：\n\n```verilog\nalways @ (posedge clk) begin\n\tif (!Rst_n)\n\t\t...\nend\n```\n\n**异步复位：**\n\n指无论时钟沿是否到来，只要复位信号有效，就对系统进行复位。用Verilog描述如下：\n\n```verilog\nalways @ (posedge clk or negedge Rst_n) begin\n\tif (!Rst_n)\n\t\t...\nend\n```\n\n------\n\n## D触发器巩固练习\n\n**题目描述1**：\n\n创建一个D触发器。\n\n**Solution1**：\n\n```verilog\nmodule top_module (\n    input clk,    \n    input d,\n    output reg q );\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n```\n\ntips：时序的always块使用非阻塞赋值。\n\n**题目描述2**：\n\n创建8个D触发器，每个都由时钟的上升沿触发。\n\n**Solution2**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n    \nendmodule\n```\n\n**题目描述3**：\n\n创建8个d触发器与主动高同步复位。所有D触发器由clk的上升沿触发。\n\n**Solution3**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,            // Synchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\n    always @(posedge clk) begin\n        if(reset)\n            q <=8'd0;\n        else\n            q <= d;\n    end\n    \nendmodule\n```\n\n**题目描述4**：\n\n创建8个D触发器与主动高同步复位。触发器必须被重置为0x34，而不是0。所有D触发器应由clk的下降沿触发。\n\n**Solution4：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\n    always @(negedge clk) begin\n        if(reset)\n            q <= 8'h0x34;\n        else\n            q <= d;\n    end\n    \nendmodule\n```\n\n**题目描述5**：\n\n创建8个D触发器与主动高异步复位。所有D触发器应由clk的上升沿触发。\n\n**Solution5**:\n\n```verilog\nmodule top_module (\n    input clk,\n    input areset,   // active high asynchronous reset\n    input [7:0] d,\n    output [7:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            q <= 8'd0;\n        end\n        else begin\n            q <= d;\n        end\n    end\n    \nendmodule\n```\n\ntips：使用`posedge areset`时，只能使用`if(areset)`首先进行判断而不能用`if(!areset)`，否则会报错。\n\n**题目描述6**：\n\n创建一个16D触发器，有时我们仅需要修改部分触发器中的值。字节使能信号控制当前时钟周期中16个寄存器中哪个字节需被修改。`byteena[1]`控制高字节`d[15:8]`，而`byteena[0]`控制低字节d[7:0]。\n\n`resetn`是一个同步，低复位信号。\n\n所有的D触发器由时钟的上升沿触发。\n\n**Solution6**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output [15:0] q\n);\n\n    always @(posedge clk) begin\n        if(!resetn) begin\n            q <= 16'd0;\n        end\n        else begin\n            if(byteena[1])\n                q[15:8] <= d[15:8];\n            if(byteena[0])\n                q[7:0] <= d[7:0];\n        end\n    end\n    \nendmodule\n```\n\n**题目描述7：**\n\n实现下面的电路(锁存器)\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232154514.png)\n\n**Solution7**：\n\n```verilog\nmodule top_module (\n    input d, \n    input ena,\n    output q);\n    \n    always@(*)begin\n        if(ena)begin\n            q = d;\n        end\n    end\n \nendmodule\n```\n\n**题目描述8：**\n\n实现下面的电路\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232154371.png)\n\n**Solution8**：\n\n```verilog\nmodule top_module (\n    input clk,\n    input d, \n    input ar,   // asynchronous reset\n    output q);\n\n    always @(posedge clk or posedge ar) begin\n        if(ar) begin\n            q<=1'b0;\n        end\n        else begin\n            q<=d;\n        end\n    end\n    \nendmodule\n```\n\n**题目描述9：**\n\n实现下面的电路\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232154954.png)\n\n**Solution9：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input d, \n    input r,   // synchronous reset\n    output q);\n\n    always @(posedge clk) begin\n        if(r) begin\n            q<=1'b0;\n        end\n        else begin\n            q<=d;\n        end\n    end\n    \nendmodule\n```\n\n**题目描述10：**\n\n实现下面的电路\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232154405.png)\n\n**Solution10：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input in, \n    output out);\n\n    always @(posedge clk) begin\n        out <= (in ^ out);\n    end\n    \nendmodule\n```\n\n**题目描述11：**\n\n考虑下图的电路：\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232154377.png)\n\n假设要为这个电路实现分层的Verilog代码，使用一个子模块的三个实例，该子模块中有一个触发器和多路选择器。为这个子模块编写一个名为top_module的Verilog模块(包含一个触发器和多路选择器)\n\n**Solution11**：\n\n```verilog\nmodule top_module (\n\tinput clk,\n\tinput L,\n\tinput r_in,\n\tinput q_in,\n\toutput reg Q);\n    \n    always @(posedge clk) begin\n        Q <= L ? r_in : q_in;\n    end\n\nendmodule\n```\n\n**题目描述12：**\n\n考虑下图的n-bit移位寄存器\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232155901.png)\n\n为该电路的一个阶段编写一个Verilog模块顶层模块，包括触发器和多路选择器。\n\n**Solution12：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input w, R, E, L,\n    output Q\n);\n\n    always @(posedge clk) begin\n        case({E,L})\n            2'b00:Q<=Q;\n            2'b01:Q<=R;\n            2'b10:Q<=w;\n            2'b11:Q<=R;\n        endcase\n    end\n    \nendmodule\n```\n\n**题目描述13：**\n\n给定如图所示的有限状态机电路，假设D触发器在机器开始之前被初始重置为零\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232155110.png)\n\n**Solution13：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input x,\n    output z\n); \n\n    reg Q1,Q2,Q3;\n    always @(posedge clk) begin\n        Q1 <= (x ^ Q1);\n        Q2 <= (x & ~Q2);\n        Q3 <= (x | ~Q3);\n    end\n    \n    assign z = ~(Q1|Q2|Q3);\n    \nendmodule\n```\n\n**题目描述14：**\n\nJK触发器有下面的真值表。只使用D触发器和逻辑门实现JK触发器。注:Qold是时钟上升沿前的D触发器的输出。\n\n|  J   |  K   |   Q   |\n| :--: | :--: | :---: |\n|  0   |  0   | Qold  |\n|  0   |  1   |   0   |\n|  1   |  0   |   1   |\n|  1   |  1   | ~Qold |\n\n**Solution14:**\n\n```verilog\nmodule top_module (\n    input clk,\n    input j,\n    input k,\n    output Q); \n\n    always @(posedge clk) begin\n        case({j,k})\n            2'b00:Q<=Q;\n            2'b01:Q<=1'b0;\n            2'b10:Q<=1'b1;\n            2'b11:Q<=~Q;\n        endcase\n    end\n    \nendmodule\n```\n\n------\n\n## 脉冲边沿检测\n\n**原理：**\n\n脉冲边沿的特性：**两侧电平发生了变化**。\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232155355.png)\n\n若检测的是下降沿，那就是高电平变低电平。\n\n若检测的是上升沿，那就是低电平变高电平。\n\n若检测脉冲边沿，只需将前后进来的信号做异或运算，即两个电平不相同则是发生边沿。\n\n**思路：**\n\n设计寄存器用来接收被检测的信号；若`{先进reg，后进reg}=2'b10`，则是下降沿；\n\n若`{先进reg，后进reg}=2'b01`，则为上升沿。\n\n注：使用多个寄存器可以更好的检测边沿，防止干扰脉冲。具体看下例：\n\n```verilog\nalways @ (posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        rs232_rx0 <= 1'b0;\n        rs232_rx1 <= 1'b0;\n        rs232_rx2 <= 1'b0;\n        rs232_rx3 <= 1'b0;\n\tend\n    else begin\n        rs232_rx0 <= rs232_rx;\n        rs232_rx1 <= rs232_rx0;\n        rs232_rx2 <= rs232_rx1;\n        rs232_rx3 <= rs232_rx2;\n    end\nend\n//这种方法可以滤除毛刺\nassign neg_rs232_rx = rs232_rx3 & rs232_rx2 & ~rs232_rx1 & ~rs232_rx0;\n```\n\n易分析，信号`rs232_rx0`，`rs232_rx1`，必须都为0，且信号`rs232_rx3` ，`rs232_rx2`都必须为1，`neg_rs232_rx` 才会为1。此时判断为下降沿。\n\n------\n\n## 边沿检测巩固练习\n\n**题目描述1：**\n\n对于8位向量中的每一位，检测输入信号何时从一个时钟周期的0变化到下一个时钟周期的1(正边缘检测)。输出位应该在发生0到1转换后的周期，如下示意图所示：\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232155061.png)\n\n**Solution1：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] pedge\n);\n\n    reg [7:0] temp_in;\n    \n    always @(posedge clk) begin\n        temp_in <= in;\n        pedge <= ~temp_in & in;\n    end\n    \nendmodule\n```\n\n**题目描述2：**\n\n对于8位向量中的每一位，检测输入信号何时从一个时钟周期变化到下一个时钟周期(检测脉冲边沿)。输出位应该在发生转换后的周期。\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232155289.png)\n\n**Solution2：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\n    reg [7:0] temp_in;\n    always @(posedge clk) begin\n        temp_in <= in;\n        anyedge <= temp_in ^ in;\n    end\n    \nendmodule\n```\n\n**题目描述3：**\n\n对于32位向量中的每一位，当输入信号从一个时钟周期的1变化到下一个时钟周期的0时捕获(捕捉下降沿)，“捕获”意味着输出将保持1直到被reset(同步重置)。\n\n每个输出位的行为就像一个SR触发器:输出位应该在发生1到0转换后的周期被设置(为1)。当复位为高时，输出位应该在正时钟边缘复位(为0)。如果上述两个事件同时发生，则reset具有优先级。\n\n在下面示例波形的最后4个周期中，“reset”事件比“set”事件早一个周期发生，因此这里不存在冲突。\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232155112.png)\n\n**Solution3(1)：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\n    reg [31:0] temp_in;\n    reg [31:0] state;\n    integer i;\n    \n    always @(posedge clk) begin\n        temp_in <= in;\n        for(i=0;i<32;i++) begin\n            case({temp_in[i] & ~in[i],reset})\n                2'b10:out[i]<=1'b1;\n                2'b11:out[i]<=1'b0;\n                2'b01:out[i]<=1'b0;\n                default:out[i]<=out[i];\n            endcase\n        end\n    end\n    \nendmodule\n```\n\n**Solution3(2)：**\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\n    reg [31:0] temp_in;\n    \n    always @(posedge clk) begin\n        temp_in <= in;\n    end\n    \n    always @(posedge clk) begin\n        if(reset)begin\n            out<=32'b0;\n        end\n        else begin\n            out<=temp_in & ~in | out;\n        end\n    end\n     \nendmodule\n```\n\n**题目描述4：**\n\n时钟双沿触发器\n\n~~`always @(posedge clk or negedge clk)`~~\n\n**Solution4(1):**\n\n```verilog\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\n    reg q1,q2;\n    \n    always @(posedge clk) begin\n        q1<=d;\n    end\n    \n    always @(negedge clk) begin\n        q2<=d;\n    end\n    \n    assign q = clk?q1:q2; \n        \nendmodule\n```\n\n**Solution4(2):**\n\n```verilog\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\n    reg q1,q2;\n    \n    always @(posedge clk) begin\n        q1<= d ^ q2;\n    end\n    \n    always @(negedge clk) begin\n        q2<= d ^ q1;\n    end\n    \n    assign q = q1 ^ q2; \n        \nendmodule\n```\n\n我们知道任何一个数异或一个数再异或同一个数，将得到本身。这就是最简单的加密与解密原理。\n\nSolution2相较于Solution1少了使用clk信号进行选择，**可以避免产生毛刺**。推荐使用Solution2进行双边检测。\n\n------\n\n## 总结\n\n- 学习了D触发器与同步异步复位的概念\n- 学会了实际工程中常用的边沿检测电路","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(9)_卡诺图与最简SOP式","url":"/2022/09/12/IC/HDLBits/HDLBits答案(9)_卡诺图与最简SOP式/","content":"\n# 卡诺图与最简SOP式\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 真值表\n\n### 定义\n\n真值表是表征逻辑事件输入和输出之间全部可能状态的表格。以1表示真，0表示假。\n\n### 从真值表到标准式\n\n- **SOP标准式**：找出真值表中所有输出为1的表项，按照输入的情况，为1用变量表示，为0则用反变量表示，得出若干乘积项，然后求和。\n- **POS标准式**：找出真值表中所有输出为0的表项，按照输入的情况，为1用反变量表示，为0则用原变量表示，得出若干求和项，然后求积。\n\n**举例说明**\n\n有如下真值表\n\n|  A   |  B   |  C   |  D   |\n| :--: | :--: | :--: | :--: |\n|  0   |  0   |  0   |  0   |\n|  0   |  0   |  1   |  0   |\n|  0   |  1   |  0   |  0   |\n|  0   |  1   |  1   |  1   |\n|  1   |  0   |  0   |  1   |\n|  1   |  0   |  1   |  0   |\n|  1   |  1   |  0   |  1   |\n|  1   |  1   |  1   |  1   |\n\n若针对所有F=1的表项，可轻松写出**SOP标准式**如下：\n\nF=ABC+AB<u>C</u>+A<u>BC</u>+<u>A</u>BC\n\n若针对所有F=0的表项，可轻松写出**POS标准式**如下：\n\nF=(<u>A</u>+B+<u>C</u>)(A+<u>B</u>+C)(A+B+<u>C</u>)(A+B+C)\n\n### 从标准SOP式到最简SOP式\n\n标准表达式并非最简表达式，从标准SOP式到最简SOP式为一个标准的逻辑化简的过程。\n\n此时可以引入卡诺图，来寻找最小项的合并规律，从而可以轻易的进行化简工作，此处仅介绍系统化简法。\n\n**1、求出函数的SOP标准式**\n\n例如，对于函数：\n\nF=ABC+AB<u>C</u>+D+<u>A</u>BCD\n\n可写出其标准的SOP式为\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232152139.png)\n\n**2、求出函数的全部主要项**\n\n首先，将最小项按其内部包含1的个数多少进行排列、分组，可得下表：\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232152239.png)\n\n其次，根据该表，可以发现能合并的两个最小项必定位于相邻的两组，因此从最低组开始，和相邻高位组逐个运算合并，并按乘积项中1的个数进行排列得到的新表如下：(注：1、在合并的同时，需在之前的表中用勾标注出被使用过的最小项；2、如果合并结果与之前某次一样，则无需列出。)\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232152034.png)\n\n第三，参考前两个步骤，继续对表项合并，直至无法合并为止。之后的合并过程需注意的是“—”的位置要相同，继续合并的结果如下：\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232152177.png)\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232152682.png)\n\n第四，上述各表中，凡是没被“√”标记的合并项，就是主要项。对于该例，主要项就是：P0=AB和P1=D。\n\n**3、求出必要项、列出化简结果**\n\n如果某一个主要项中，至少包含一个其他项不包含的最小项，则它必然是必要项。\n\n得到主要项后再进行验证是否存在等价主要项，并将其删除。\n\n------\n\n## 巩固练习\n\n**题目描述1**：\n\n实现下面卡诺图所描述的电路。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232152506.png)\n\n**Solution1**：\n\n```verilog\nmodule top_module(\n    input a,\n    input b,\n    input c,\n    output out  ); \n    assign out = ~((~a)&(~b)&(~c));\nendmodule\n```\n\n**题目描述2**：\n\n实现下面卡诺图所描述的电路。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232153201.png)\n\n**Solution2**：\n\n```verilog\nmodule top_module(\n    input a,\n    input b,\n    input c,\n    input d,\n    output out  ); \n\n    assign out = ~a & ~d | ~b & ~c | b & c & d | a & c & d;\n    \nendmodule\n\n```\n\n**题目描述3**：\n\n实现下面卡诺图所描述的电路。\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232153035.png)\n\ntips：d可以根据化简需求自己制定为0或是1。\n\n**Solution3**：\n\n```verilog\nmodule top_module(\n    input a,\n    input b,\n    input c,\n    input d,\n    output out  ); \n\n    assign out =  a | (~a&~b&c);\n    \nendmodule\n```\n\n**题目描述4**：\n\n实现下面卡诺图所描述的电路。\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232153111.png)\n\n**Solution4**：\n\n```verilog\nmodule top_module(\n    input a,\n    input b,\n    input c,\n    input d,\n    output out  ); \n\n    assign out = a ^ b ^ c ^ d;\n    \nendmodule\n```\n\n**题目描述5**：\n\n实现一个有四输入(a.b,c,d)的单输出数字系统，当2、7或15出现在输入端时，生成逻辑1，当0、1、4、5、6、9、10 13或14出现时，生成逻辑0。数字3、8、11和12的输入不会出现在这个系统中。例如，7对应于a和b。c,d分别被设为0,1,1,1。\n\n确定最小SOP格式的输出out_sop和最小POS格式的输出out_pos。\n\n**Solution5**：\n\n```verilog\nmodule top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n); \n\n    assign out_sop = c & d | ~a & ~b & c;\n    assign out_pos = ~((~c | ~d) & (a | b | ~c));\n    \nendmodule\n```\n\ntips：这道题是最大项和最小项的问题，我们常用的是最小项，也就是积之和，但是最大项也需要了解一下，一般使用最小项就好了。\n\n**题目描述6**：\n\n实现下面卡诺图所描述的电路。\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232153758.png)\n\n**Solution6**：\n\n```verilog\nmodule top_module (\n    input [4:1] x, \n    output f );\n\n    assign f = ~x[1]&x[3] | x[2]&x[4];\n    \nendmodule\n```\n\n**题目描述7**：\n\n实现下面卡诺图所描述的电路。\n\n![11](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232153102.png)\n\n**Solution7**：\n\n```verilog\nmodule top_module (\n    input [4:1] x,\n    output f\n); \n\n    assign f = ~x[2]&~x[4] | ~x[1]&x[3] | x[2]&x[3]&x[4];\n    \nendmodule\n```\n\n**题目描述8**：\n\n对于下面的卡诺图，用一个4-1多路选择器和不限的2-1多路选择器，但2-1多路选择器的使用要尽可能少。你不允许使用任何其他逻辑门，你必须使用a和b作为多路复用器选择器的输入，如下面的4- 1多路复用器所示。\n\n![12](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232153765.png)\n\n**Solution8**：\n\n```verilog\nmodule top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    \n    always @(*) begin\n        case({c,d})\n            2'b0:\n                mux_in = 4'b0100;\n            2'b1:\n                mux_in = 4'b0001;\n            2'b11:\n                mux_in = 4'b1001;\n            default:\n                mux_in = 4'b0101;\n        endcase\n    end\n\nendmodule\n```\n\n------\n\n## 总结\n\n- 熟悉了卡诺图和基本的计算单元\n- 熟悉了卡诺图的化简方式，了解了SOP和POS的区别与联系，以及如何求得SOP最简式。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(8)_半加器、全加器和行波进位加法器原理与设计","url":"/2022/09/12/IC/HDLBits/HDLBits答案(8)_Verilog半加器、全加器和行波进位加法器原理与设计/","content":"\n# 半加器、全加器和行波进位加法器原理与设计\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 半加器\n\n**定义**：\n\n半加器用于计算2个单比特二进制数a与b的和，输出结果sum（s）和进位carry（c）。在多比特数的计算中，进位c将作为下一相邻比特的加法运算中。其真值表如下所示。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232150420.png)\n\n**题目描述**：实现一个半加器。半加器将两位比特相加(不带进位)并产生一个1bit结果和一个进位。\n\n**Solution**：\n\n```verilog\nmodule top_module( \n    input a, b,\n    output cout, sum );\n    assign {cout,sum} = a + b;\nendmodule\n\n```\n\n------\n\n## 全加器\n\n**定义**：\n\n全加器不同于半加器的地方是，全加器带有进位cin。输入为a,b,cin, 输出为sum（s）和carry*（cout），均是单比特信号。s为a,b,cin三个单比特数的和，cout为a,b,cin三个数超过2后的进位。\n\n**题目描述**：实现一个全加器。全加器将两位比特相加(带进位)并产生一个1bit结果和一个进位。\n\n**Solution**：\n\n```verilog\nmodule top_module( \n    input a, b, cin,\n    output cout, sum );\n    assign {cout,sum} = a + b + cin;\nendmodule\n```\n\n------\n\n## 行波进位加法器\n\n**定义**：N-bit加法器可以根据1-bit全加器组合而成。每个全加器的输出进位cout作为下一个全加器的输入进位cin，这种加法器称为行波进位加法器(Ripple-carry adder，简称RCA)。\n\n**题目描述**：现在我们已经知道如何实现一个全加器，我们将使用它的3个实例来创建一个3位二进制的行波进位加法器。\n\n行波进位加法器将两个3位数字和一个进位相加以产生一个3位结果和一个进位输出。\n\n**Solution**：\n\n```verilog\nmodule top_module( \n    input [2:0] a, b,\n    input cin,\n    output [2:0] cout,\n    output [2:0] sum );\n    assign {cout[0],sum[0]} = a[0] + b[0] +cin;\n    assign {cout[1],sum[1]} = a[1] + b[1] +cout[0];\n    assign {cout[2],sum[2]} = a[2] + b[2] +cout[1];\nendmodule\n```\n\n------\n\n## 巩固练习\n\n**题目描述1**：实现下图所示电路，其中“FA”指全加器(Full Adder)。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232151524.png)\n\n**Solution1**：\n\n```verilog\nmodule top_module (\n    input [3:0] x,\n    input [3:0] y, \n    output [4:0] sum);\n    \n    wire [2:0] cout;\n    \n    assign {cout[0],sum[0]} = x[0] + y[0];\n    assign {cout[1],sum[1]} = x[1] + y[1] + cout[0];\n    assign {cout[2],sum[2]} = x[2] + y[2] + cout[1];\n    assign {sum[4],sum[3]} = x[3] + y[3] + cout[2];\n    \nendmodule\n```\n\n**题目描述2**：\n\n假设有两个8位数字的补码，a[7:0]和b[7:0]。这俩数字相加产生s[7:0]。模块中需计算是否发生了(有符号的)溢出。\n\ntips：当两个正数相加产生一个负结果，或两个负数相加产生一个正结果时，会发生符号溢出现象。有几种检测溢出的方法:可以通过比较输入和输出数字的符号来计算溢出，或者从n位和n-1位的进位来判断是否溢出。\n\n**Solution2**：\n\n```verilog\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n); \n \n    assign s = a + b;\n    assign overflow = (a[7]&b[7]&~s[7]) | ((~a[7])&(~b[7])&s[7]);\n\nendmodule\n```\n\n**题目描述3**：创建一个100位的二进制加法器。加法器将两个100位的数和一个进位相加产生一个100位的结果和一个进位。\n\n**Solution3**：\n\n```verilog\nmodule top_module( \n    input [99:0] a, b,\n    input cin,\n    output cout,\n    output [99:0] sum );\n    \n    assign {cout,sum[99:0]} = a + b + cin;\n    \nendmodule\n```\n\n**题目描述4**：\n\n已有一个BCD(二进制编码的十进制)数加法器，名为`bcd_fadd`，它将两个BCD数字和进位信号相加，生成结果和进位信号。\n\n```verilog\nmodule bcd_fadd {\n    input [3:0] a,\n    input [3:0] b,\n    input     cin,\n    output   cout,\n    output [3:0] sum );\n```\n\n实例化`bcd_fadd`的4个副本，以创建一个4位BCD行波进位加法器。\n\n**Solution4**：\n\n```verilog\nmodule top_module( \n    input [15:0] a, b,\n    input cin,\n    output cout,\n    output [15:0] sum );\n    \n    wire [2:0] cout_temp;\n    \n    bcd_fadd bcd_1(a[3:0],b[3:0],cin,cout_temp[0],sum[3:0]);\n    bcd_fadd bcd_2(a[7:4],b[7:4],cout_temp[0],cout_temp[1],sum[7:4]);\n    bcd_fadd bcd_3(a[11:8],b[11:8],cout_temp[1],cout_temp[2],sum[11:8]);\n    bcd_fadd bcd_4(a[15:12],b[15:12],cout_temp[2],cout,sum[15:12]);\n\nendmodule\n```\n\n------\n\n## 总结\n\n- 学习了常见加法器的原理与设计\n- 学习了带进位加法器的级联","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(7)_Verilog多路选择器","url":"/2022/09/12/IC/HDLBits/HDLBits答案(7)_Verilog多路选择器/","content":"\n# Verilog多路选择器\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n## 定义\n\n多路选择器(Multiplexer)简称多路器，它是一个多输入、单输出的组合逻辑电路，在数字系统中有着广泛的应用。它可以根据地址码(选择码)的不同，从多个输入数据流中选取一个，让其输出到公共的输出端。\n\n------\n\n## 部分练习题\n\n**题目描述1**：实现一个位宽为1的2-1的多路选择器。当sel=0，选择a，当sel=1，选择b。\n\n**Solution1**：\n\n```verilog\nmodule top_module( \n    input a, b, sel,\n    output out ); \n\tassign out = sel ? b : a;\nendmodule\n```\n\n**题目描述2**：实现一个位宽为100的2-1的多路选择器。当sel=0，选择a，当sel=1，选择b。\n\n**Solution2**：\n\n```verilog\nmodule top_module( \n    input [99:0] a, b,\n    input sel,\n    output [99:0] out );\n\tassign out = sel ? b : a;\nendmodule\n```\n\n**题目描述3**：创建一个位宽为16的9-1的多路选择器。sel=0选择a, sel=1选择b，以此类推。对于未使用的sel值(sel=9~15)，将所有输出位设置为1。\n\n**Solution3**：\n\n```verilog\nmodule top_module( \n    input [15:0] a, b, c, d, e, f, g, h, i,\n    input [3:0] sel,\n    output [15:0] out );\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default:out = 16'hffff;\n        endcase\n    end\n    \nendmodule\n```\n\n**题目描述4**：创建一个位宽为1的256-1的多路选择器。256个输入都被打包成一个256位的输入向量。sel=0表示选择in[0]，sel=1表示选择in[1]，以此类推。\n\n**Solution4**：\n\n```verilog\nmodule top_module( \n    input [255:0] in,\n    input [7:0] sel,\n    output out );\n    assign out = in[sel];\nendmodule\n```\n\n**题目描述5**：创建一个位宽为4的256-1的多路选择器。256个4位输入都被打包成一个1024位的输入向量。sel=0选择in[3:0]，sel=1选择in[7:4]，sel=2选择in[11:8]，以此类推。\n\n**Solution5**：\n\n```verilog\nmodule top_module( \n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out );\n    assign out = in[sel*4+3 -: 4];\nendmodule\n```\n\ntips：\n\n```verilog\ndata[0 +: 8]  <--等价于--> data[7:0]\ndata[15 +: 2] <--等价于--> data[16:15]\ndata[7 -: 8]  <--等价于--> data[7:0]\ndata[15 -: 2] <--等价于--> data[15:14]\n```\n\n------\n\n## 总结\n\n- 学习了多路选择器的相关知识。\n- 学习了可以根据向量索引进行数据的选择，要注意的是被选取数据的位宽是否为常数，合理使用 +=、-=语法。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(6)_硬件模块设计的思考方式","url":"/2022/09/12/IC/HDLBits/HDLBits答案(6)_硬件模块设计的思考方式/","content":"\n# 硬件模块设计的思考方式\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 基本的逻辑门操作\n\n**题目描述1**：将输入端口in和输出端口out连接。\n\n**Solution1**：\n\n```verilog\nmodule top_module (\n    input in,\n    output out);\n\tassign out = in;\nendmodule\n```\n\n**题目描述2**：将输出out接地。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232148143.png)\n\n**Solution2**：\n\n```verilog\nmodule top_module (\n    output out);\n\tassign out = 1'b0;\nendmodule\n```\n\n**题目描述3**：实现或非门操作。\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232148889.png)\n\n**Solution3**：\n\n```verilog\nmodule top_module (\n    input in1,\n    input in2,\n    output out);\n    assign out =~(in1 | in2);\nendmodule\n```\n\n**题目描述4**：实现下图所示的逻辑操作。\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232148719.png)\n\n**Solution4**：\n\n```verilog\nmodule top_module (\n    input in1,\n    input in2,\n    output out);\n    assign out = in1 & (~in2);\nendmodule\n```\n\n**题目描述5**：实现下图所示的逻辑操作。\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232148746.png)\n\n**Solution5**：\n\n```verilog\nmodule top_module (\n    input in1,\n    input in2,\n    input in3,\n    output out);\n\twire temp;\n    assign temp = ~(in1^in2);\n    assign out = temp ^ in3;\nendmodule\n```\n\n**题目描述6**：尝试同时建立几个逻辑门，建立一个两输入的组合电路。\n\n共7个输出如下：\n\n- out_and: a and b\n- out_or: a or b\n- out_xor: a xor b\n- out_nand: a nand b\n- out_nor: a nor b\n- out_xnor: a xnor b\n- out_anotb: a and-not b\n\n**Solution6**：\n\n```verilog\nmodule top_module( \n    input a, b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\tassign out_and = a&b;\n    assign out_or = a|b;\n    assign out_xor = a^b;\n    assign out_nand = ~(a&b);\n    assign out_nor = ~(a|b);\n    assign out_xnor = ~(a^b);\n    assign out_anotb = a&(~b);\nendmodule\n```\n\n**题目描述7**：\n\n7400系列集成电路是一个数字芯片系列，每个都由几个基本的逻辑门构成。7420是一个带有两个4输入与非门的芯片。\n\n实现一个具有与7420芯片相同功能的模块，共8个输入和2个输出。\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232148054.png)\n\n**Solution7**：\n\n```verilog\nmodule top_module ( \n    input p1a, p1b, p1c, p1d,\n    output p1y,\n    input p2a, p2b, p2c, p2d,\n    output p2y );\n    assign p1y=~(p1a&p1b&p1c&p1d);\n    assign p2y=~(p2a&p2b&p2c&p2d);\nendmodule\n```\n\n------\n\n## 真值表\n\n在前面的练习中，我们使用简单的逻辑门和几个逻辑门的组合，这些电路是组合电路的例子。\n\n**组合电路的意思是电路的输出仅取决于输入**，这意味着对于任何给定的输入值，只有一个可能的输出值。因此，描述组合函数行为的一种方法是明确地列出所有可能的输入所对应的输出值，即真值表。\n\n对一个有N个输入的布尔函数而言，有2^N种可能的输入组合。真值表的每一行都列出了一个输入组合，因此总有2^N行。output列显示了每个输入值对应的输出。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232149665.png)\n\n那么我们如何只用标准逻辑门来实现查找表的功能呢？\n\n一种简单的方法是将真值表中所有的真值写为乘积求和项的形式。**求和即为或操作，乘积即为与操作**。先使用一个N-输入的与门来决定是否输入的向量与真值表匹配，然后再用一个或门来选择满足匹配条件的结果进行输出。\n\n**题目描述**：构建一个模块实现上述真值表的功能。\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232150748.png)\n\n**Solution**：\n\n```verilog\nmodule top_module( \n    input x3,\n    input x2,\n    input x1,  // three inputs\n    output f   // one output\n);\n    assign f = (x1&x3)|(x2&~x3);\nendmodule\n```\n\n------\n\n## 部分考题\n\n**题目描述1**：\n\n创建一个有两个2位输入A[1:0]和B[1:0]的电路，产生一个输出z。若A=B，则z=1，否则z=0。\n\n**Solution1**：\n\n```verilog\nmodule top_module ( input [1:0] A, input [1:0] B, output z ); \n    assign z=(A==B)?1'b1:1'b0;\nendmodule\n```\n\n**题目描述2**：\n\n构建模块实现函数`z = (x^y) & x`\n\n**Solution2**:\n\n```verilog\nmodule top_module (input x, input y, output z);\n    assign z=(x^y)&x;\nendmodule\n```\n\n**题目描述3**：\n\n构建模块实现如下波形图的输入输出关系\n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232150470.png)\n\n**Solution3**：\n\n```verilog\nmodule top_module ( input x, input y, output z );\n    assign z=~(x^y);\nendmodule\n```\n\n**题目描述4**：\n\nA模块实现的功能如上述题二所示，B模块实现的功能如题三所示。搭建模块实现下图所示功能：\n\n![9](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232150779.png)\n\n**Solution4**：\n\n```verilog\nmodule top_module (input x, input y, output z);\n\t\n    wire za;\n    wire zb;\n    \n    assign za = (x ^ y) & x;\n    assign zb = ~(x ^ y);\n    assign z = (za | zb) ^ (za & zb);\n    \nendmodule\n```\n\n------\n\n## 硬件工程师的思考方式\n\ntips：当进行模块设计时，我们最好反向思考问题，如何从输出到输入。这与我们平时顺序式地思考编程问题不同，在编程时我们一般首先看输入如何决定输出，即输入为XX时输出为XX；**对硬件工程师而言，通常的思路为输出为XX时输入是XX**？\n\n在硬件设计中，在两种思路间思考与切换是很重要的技能。\n\n**题目描述1**：设计一种电路来控制手机的铃声和振动马达。当有来电输入信号时(input **ring**)，电路必须打开铃声(output **ringer**= 1)或电机(output **motor**= 1)，但不能同时打开。如果手机处于振动模式(input **vibrate_mode** = 1)，打开电机。否则打开铃声。\n\n![10](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232149798.png)\n\n**Solution1**：\n\n```verilog\nmodule top_module (\n    input ring,\n    input vibrate_mode,\n    output ringer,       // Make sound\n    output motor         // Vibrate\n);\n    assign ringer = ring & (~vibrate_mode);\n    assign motor = ring & vibrate_mode;\nendmodule\n```\n\n**题目描述2**：加热/冷却恒温器同时控制加热器(冬季)和空调(夏季)。设计一个电路，根据需要打开或关闭加热器、空调和鼓风机。\n\n恒温器有两种模式:加热模式(mode= 1)和冷却模式(mode= 0)。在加热模式下，当温度过低时打开加热器(too_cold = 1)但是不要使用空调。在冷却模式下，当温度太高(too_hot= 1)时打开空调，但不要打开加热器。\n\n当暖气或空调打开时。同时打开风扇让空气流通。此外。用户也可以仅要求风扇打开(fan_on = 1)，即使加热器和空调关闭。\n\n**Solution2**：\n\n```verilog\nmodule top_module (\n    input too_cold,\n    input too_hot,\n    input mode,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n); \n\tassign heater = mode & too_cold;\n    assign aircon = (~mode) & too_hot;\n    assign fan = (mode & too_cold) | ((~mode) & too_hot) | fan_on;\nendmodule\n```\n\n------\n\n## 对单向量的各bit进行操作\n\n**题目描述1**：为3位输入向量构造一个数1的计数电路。\n\n**Solution1**：\n\n```verilog\nmodule top_module( \n    input [2:0] in,\n    output [1:0] out );\n    integer i;\n    always @(*) begin\n        out = 2'b0;\n        for(i=0;i<3;i++) begin\n            out = out + in[i];\n        end\n    end\nendmodule\n```\n\n**题目描述2**：输入一个4位的输入向量in[3:0]，输出每个比特和它相邻比特之间的一些关系:\n\n- out_both:这个输出向量的每一位应该表示对应的输入位和它左边的比特位(左边比特具有更高的索引)**是否均为“1”**。举例说明，out_both[2]应该指示出in[2]和in[3]是否均为1。\n- out_any:这个输出向量的每一位都应该表示相应的输入位和它右边的比特位**是否存在“1”**。\n- out_different:这个输出向量的每一位都应该表明相应的输入位是否与其左边的比特位**不同**。\n\n**Solution2**：\n\n思路一：\n\n```verilog\nmodule top_module( \n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different );\n    \n\tinteger i;\n    \n    always @(*) begin\n        for(i=0;i<3;i++) begin\n            out_both[i] = in[i] & in[i+1];\n            out_any[i+1] = in[i+1] | in[i];\n            out_different[i] = in[i] ^ in[i+1];\n        end\n        out_different[3] = in[0] ^ in[3];\n    end\n    \nendmodule\n```\n\n思路二：\n\n```verilog\nmodule top_module( \n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different );\n\n    assign out_both = in[2:0] & in[3:1];\n    assign out_any = in[3:1] | in[2:0];\n    assign out_different = in[3:0] ^ {in[0],in[3:1]};\n    \nendmodule\n```\n\n**题目描述3**：题目同上，但输入向量变为100位。\n\n**Solution3**：\n\n思路一：\n\n```verilog\nmodule top_module( \n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different );\n\n\tinteger i;\n    \n    always @(*) begin\n        for(i=0;i<99;i++) begin\n            out_both[i] = in[i] & in[i+1];\n            out_any[i+1] = in[i+1] | in[i];\n            out_different[i] = in[i] ^ in[i+1];\n        end\n        out_different[99] = in[0] ^ in[99];\n    end\n    \nendmodule\n```\n\n思路二：\n\n```verilog\nmodule top_module( \n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different );\n\n    assign out_both = in[98:0] & in[99:1];\n    assign out_any = in[99:1] | in[98:0];\n    assign out_different = in[99:0] ^ {in[0],in[99:1]};\n    \nendmodule\n```\n\n------\n\n## 总结\n\n- 熟悉了基本的逻辑门操作。\n- 学习了硬件工程师的设计思维：由输出到输入。\n- 学习了用标准的逻辑门实现查找表的功能。\n- 合理使用assign或for循环对向量的各bit位进行操作。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(5)_Generate实例化模块","url":"/2022/09/12/IC/HDLBits/HDLBits答案(5)_Generate实例化模块/","content":"\n# Generate实例化模块\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 三目运算符(形式：condition ? if_true : if_false)\n\nverilog中有跟c语言类似的三目运算符，这可以用于**在一行中**根据条件选择两个值中的一个，而不用在组合always块中使用if-then。下面给出一些示例：\n\n```verilog\n(0 ? 3 : 5)     // This is 5 because the condition is false.\n(sel ? b : a)   // A 2-to-1 multiplexer between a and b selected by sel.\n\nalways @(posedge clk)         // A T-flip-flop.\n  q <= toggle ? ~q : q;\n\nalways @(*)                   // State transition logic for a one-input FSM\n  case (state)\n    A: next = w ? B : A;\n    B: next = w ? A : B;\n  endcase\n\nassign out = ena ? q : 1'bz;  // A tri-state buffer\n\n((sel[1:0] == 2'h0) ? a :     // A 3-to-1 mux\n (sel[1:0] == 2'h1) ? b :\n                      c )\n```\n\n**题目描述**：\n\n给定4个无符号数，求最小值。无符号数可以用比较运算符(a <b)进行比较。\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [7:0] a, b, c, d,\n    output [7:0] min);\n\n    wire [7:0] mintemp1;\n    wire [7:0] mintemp2;\n    assign mintemp1 = (a<b)? a:b;\n    assign mintemp2 = (c<mintemp1)?c:mintemp1;\n    assign min = (d<mintemp2)?d:mintemp2;\n\nendmodule\n```\n\n------\n\n## 缩位运算符\n\n缩位运算符可以对向量的各个位进行和、或和异或操作，产生1位的输出:\n\n```verilog\n& a[3:0]     // AND: a[3]&a[2]&a[1]&a[0]. Equivalent to (a[3:0] == 4'hf)\n| b[3:0]     // OR:  b[3]|b[2]|b[1]|b[0]. Equivalent to (b[3:0] != 4'h0)\n^ c[2:0]     // XOR: c[2]^c[1]^c[0]\n```\n\n我们可以通过翻转上述缩位运算的输出来获得NAND、NOR和XNOR缩位运算的输出。\n\n**题目描述1**：奇偶校验经常被用作传输数据时检测错误的简单方法。创建一个电路，为一个8位字节计算一个奇偶校验位(它将在1个字节的基础上增加1位)。我们将使用“偶数”奇偶校验，其中奇偶校验位只是所有8位数据位的异或。\n\n**Solution1**：\n\n```verilog\nmodule top_module (\n    input [7:0] in,\n    output parity); \n\tassign parity = ^ in;\nendmodule\n```\n\n**题目描述2**：构建一个组合电路，包括100个输入，in[99:0]；\n\n3个输出：\n\n- out_and：100个与门的输出\n- out_or：100个或门的输出\n- out_xor：100个异或门的输出\n\n**Solution2**：\n\n```verilog\nmodule top_module( \n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor \n);\n\tassign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\nendmodule\n```\n\n------\n\n## for循环的组合逻辑：向量顺序翻转\n\n**题目描述**：\n\n给定一个100位的输入向量，翻转它的位顺序。\n\n**Solution**：\n\n```verilog\nmodule top_module( \n    input [99:0] in,\n    output [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for(i=0;i<100;i++) begin\n            out[i]=in[99-i];\n        end\n    end\nendmodule\n```\n\n------\n\n## for循环的组合逻辑：255bit的数1操作\n\n**题目描述**：\n\n“计数”电路对输入向量中的1进行计数。为一个255位输入向量建立一个“计数”电路。\n\n**Solution**：\n\n```verilog\nmodule top_module( \n    input [254:0] in,\n    output [7:0] out );\n    \n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for(i=0;i<255;i++) begin\n            out = out + in[i];\n        end\n    end\nendmodule\n```\n\n锁存器会对电路产生哪些影响呢？\n\n1. 锁存器对毛刺敏感，无异步复位端，不能让芯片在上电时处在确定的状态；\n2. 锁存器会使静态时序分析变得很复杂，不利于设计的可重用。\n\n所以，在ASIC设计中，除了CPU高速电路，或者RAM这种对面积很敏感的电路，一般不提倡用锁存器。\n\n------\n\n## 循环生成语句\n\ntips：Verilog中的generate语句常用于编写可配置的、可综合的RTL的设计结构。它可用于创建模块的多个实例化，或者有条件的实例化代码块。\n\ngenerate循环的语法与for循环语句的语法很相似。但是在使用时必须先在**genvar**声明中声明循环中使用的索引变量名，然后才能使用它。**genvar**声明的索引变量被用作整数用来判断generate循环。**genvar**声明可以是generate结构的内部或外部区域，并且相同的循环索引变量可以在多个generate循环中，只要这些环不嵌套。genvar只有在建模的时候才会出现，在仿真时就已经消失了。\n\nVerilog中generate循环中的generate块可以命名也可以不命名。如果已命名，则会创建一个generate块实例数组。如果未命名，则有些仿真工具会出现警告，因此，**最好始终对它们进行命名。**\n\n**题目描述1**：\n\n通过实例化100个全加法器，创建一个100位行波进位加法器。\n\n**Solution1**：\n\n```verilog\nmodule top_module( \n    input [99:0] a, b,\n    input cin,\n    output [99:0] cout,\n    output [99:0] sum );\n\tgenvar i;\n    generate\n        for(i=0;i<100;i++) begin:adder\n            if(i==0)\n                assign{cout[0],sum[0]}=a[0]+b[0]+cin;\n            else\n                assign{cout[i],sum[i]}=a[i]+b[i]+cout[i-1];\n        end           \n    endgenerate\nendmodule\n```\n\n**题目描述2**：\n\n为您提供了一个名为bcd_fadd的BCD一位加法器，它的输入为两个BCD数字和进位输入信号，并生成求和输出和进位输出信号。\n\n```verilog\nmodule bcd_fadd {\n    input [3:0] a,\n    input [3:0] b,\n    input     cin,\n    output   cout,\n    output [3:0] sum );\n```\n\n实例化bcd_fadd的100个副本，以创建一个100位的BCD行波进位加法器。\n\n**Solution2**：\n\n```verilog\nmodule top_module( \n    input [399:0] a, b,\n    input cin,\n    output cout,\n    output [399:0] sum );\n    wire [99:0] cout_temp;\n\tgenvar i;\n    generate\n        for(i=0;i<100;i++) begin:bcd_fadd\n            if(i == 0)\n                bcd_fadd bcd_inst(a[3:0],b[3:0],cin,cout_temp[0],sum[3:0]);\n            else\n                bcd_fadd bcd_inst(a[4*i+3:4*i],b[4*i+3:4*i],cout_temp[i-1],cout_temp[i],sum[4*i+3:4*i]);\n        end\n        assign cout=cout_temp[99];\n    endgenerate\nendmodule\n```\n\n------\n\n## 总结\n\n本节设计大量的设计技巧，如for循环的巧用，批量进行例程的例化，这些可以在设计过程中简化工作量。\n\n","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(4)_如何避免生成锁存器","url":"/2022/09/03/IC/HDLBits/HDLBits答案(4)_如何避免生成锁存器/","content":"\n# HDLBits_Verilog Language_Procedures\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 组合逻辑的always块\n\ntips：考虑到硬件的可综合性，有两种always块是有意义的：\n\n- 组合：`always @(*)`\n- 时序：`always @(posedge clk)`\n\n组合逻辑的always块和assign赋值是等价的，使用哪一种完全看哪一种更方便。always块内可有更丰富的状态，如if-then，case等，但不能有连续赋值语句assign。\n\n如果在always块内指定了特定的信号，但没有的话，和always(*)综合结果相同，此时功能仿真结果和硬件结果就有所差异。\n\nassign赋值语句的左边一般为wire类型，always块中左边的变量一般为reg类型。<u>这些类型与硬件综合无关，仅是verilog语法的要求。</u>\n\n**题目描述**：\n\n使用赋值语句和组合always块两种方式构建与门。\n\n**Solution**：\n\n```verilog\nmodule top_module(\n    input a, \n    input b,\n    output wire out_assign,\n    output reg out_alwaysblock\n);\n    assign out_assign = a & b;\n    always @(*) begin\n        out_alwaysblock = a & b; \n    end\nendmodule\n```\n\n------\n\n## 时序逻辑的always块\n\ntips：时序always块可像组合always块那样生成电路，同时也会生成一系列的触发器，寄存器等，因为输出要等到下个时钟延才能输出。\n\n**阻塞赋值 vs 非阻塞赋值**\n\nverilog中有三种赋值方式：\n\n- 连续赋值(assign x=y;)，只能在always块外使用。\n- 阻塞赋值(x=y;)，只能在always块内使用。\n- 非阻塞赋值(x<=y;)只能在always块内使用。\n\n在**组合逻辑**的always块中(always @(*))使用**阻塞赋值**语句；\n\n在**时序逻辑**的always块中(always @(posedge clk))使用**非阻塞赋值**语句。\n\n**题目描述**：\n\n使用赋值语句、组合always块和时序always块三种方式构建一个异或门。\n\n**Solution**:\n\n```verilog\nmodule top_module(\n    input clk,\n    input a,\n    input b,\n    output wire out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff   );\n\tassign out_assign = a ^ b;\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\nendmodule\n```\n\n------\n\n## IF选择器\n\ntips：一个if语句会产生一个2选1的数据选择器，需注意的是，并不是if选择的那路数据才被实现成电路模式，而是if和else两路都被实现为电路形式然后用选择器选择输出。\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232147733.png)\n\nif的两种方式：\n\n```verilog\nalways @(*) begin\n    if (condition) begin\n        out = x;\n    end\n    else begin\n        out = y;\n    end\nend\n```\n\n```verilog\nassign out = (condition) ? x : y;\n```\n\n**题目描述**：\n\n2-1选择器\n\n| sel_b1 | sel_b2 | out_assign/out_always |\n| :----: | :----: | :-------------------: |\n|   0    |   0    |           a           |\n|   0    |   1    |           a           |\n|   1    |   0    |           a           |\n|   1    |   1    |           b           |\n\n**Solution**:\n\n```verilog\nmodule top_module(\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output wire out_assign,\n    output reg out_always   ); \n    assign out_assign=(sel_b1&sel_b2)?b:a;\n    always @(*) begin\n        if(sel_b2&sel_b1) begin\n            out_always = b;\n        end\n        else begin\n            out_always = a;\n        end\n    end\nendmodule\n```\n\n------\n\n## IF中锁存器问题\n\ntips：如何避免在使用if语句时生成锁存器？\n\n**tip**：锁存器与触发器的区别？\n\n- **锁存器是一种对脉冲电平（也就是0或者1）敏感的存储单元电路，而触发器是一种对脉冲边沿（即上升沿或者下降沿）敏感的存储电路。**\n\n当我们在设计电路时，不能直接先写成代码然后期望它直接生成为合适的电路，如下典型错误所示：\n\n- If (cpu_overheated) then shut_off_computer = 1;\n- If (~arrived) then keep_driving = ~gas_tank_empty;\n\n语法上正确的代码并不意味着设计成的电路也是合理的。我们来思考这么一个问题，如上图的错误示例，如果if条件不满足，输出如何变化呢？Verilog给出的解决方法是：保持输出不变。因为组合逻辑电路不能记录当前的状态，所以就会综合出锁存器。\n\n所以当我们使用if语句或者case语句时，我们必须考虑到所有情况并给对应情况的输出进行赋值，就意味着我们要为else或者default中的输出赋值。\n\n**题目描述**：找BUG，解决下面的代码中包含的创建锁存的不正确行为。\n\n```verilog\nalways @(*) begin\n    if (cpu_overheated)\n       shut_off_computer = 1;\nend\n\nalways @(*) begin\n    if (~arrived)\n       keep_driving = ~gas_tank_empty;\nend\n```\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232148960.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input      cpu_overheated,\n    output reg shut_off_computer,\n    input      arrived,\n    input      gas_tank_empty,\n    output reg keep_driving  );\n\n    always @(*) begin\n        if (cpu_overheated) begin\n           shut_off_computer = 1;\n        end\n        else begin\n            shut_off_computer = 0;\n        end\n    end\n\n    always @(*) begin\n        if (~arrived) begin\n           keep_driving = ~gas_tank_empty;\n        end\n        else begin\n           keep_driving = 0;\n        end\n    end\n    \nendmodule\n```\n\n------\n\n## Case语句\n\ntips：在Verilog中，case语句与if-elseif-else相近，与c语言中的switch差别较大，示例如下：\n\n```verilog\nalways @(*) begin     // This is a combinational circuit\n    case (in)\n      1'b1: begin \n               out = 1'b1;  // begin-end if statement >1\n            end\n      1'b0: out = 1'b0;\n      default: out = 1'bx;\n    endcase\nend\n```\n\n- case语句以case开始，每个case的选项以分号结束。\n- 每个case的选项中只能执行一个statement，所以就无需break语句。但如果我们想在一个case选项中执行多个statement，就需要使用`begin...end`\n- case中可以有重复的case item，首次匹配的将会被执行。\n\n**题目描述**：6-1数据选择器\n\n*Be careful of inferring latches！*(需添加Default)\n\n**Solution**：\n\n```verilog\nmodule top_module ( \n    input [2:0] sel, \n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out   );//\n\n    always@(*) begin  // This is a combinational circuit\n        case(sel)\n            3'b000:out=data0;\n            3'b001:out=data1;\n            3'b010:out=data2;\n            3'b011:out=data3;\n            3'b100:out=data4;\n            3'b101:out=data5;\n            default:out=3'b0;\n        endcase\n    end\n\nendmodule\n```\n\n------\n\n## 优先编码器\n\n**题目描述**：优先编码器是一种组合电路，当给定输入位向量时，输出该向量中第一个1的位置。 例如，给定输入8'b10010000的8位优先级编码器将输出3'd4，因为bit [4]是高的第一位。\n\n构建一个4位优先级编码器。 对于此问题，如果所有输入位都不为高（即输入为零），则输出零。 请注意，一个4位数字具有16种可能的组合。\n\n**Solution**：\n\n1、根据惯性思维使用case语法，列出每一种情况，然后列出其对应的输出。\n\n```verilog\ncase(input)\n\n4'b0001: output = 1;\n\n.......\n\n4'b1111:output = 1;\n\ndefault: output = 0;\n\nendcase\n```\n\n2、如果按上述思路来写，那么更多位的优先编码器如何实现呢？其实有更简单的方法，目前既不用casex也不用casez，这两位要在后面出场。来看另一种思路：\n\n```verilog\nmodule top_module (\n    input [3:0] in,\n    output reg [1:0] pos  );\n    always @(*) begin\n        case(1)\n            in[0]:pos = 0;\n            in[1]:pos = 1;\n            in[2]:pos = 2;\n            in[3]:pos = 3;\n            default:pos = 0;\n        endcase\n    end\nendmodule\n```\n\n根据上面所说的case的性质，case中可以有重复的case item，但首次匹配的才会被执行。再看上面的case语句，即从低到高位去比较in中是否有数据位为1，下面即使有重复为1的也只会执行首次匹配的操作。如此，N位优先编码器只需要N个case分支即可，大大简化代码量。\n\n------\n\n## casez实现优先编码器\n\n**题目描述**：\n\n为8位输入构建优先级编码器。当给定输入位向量时，输出该向量中第一个1的位置。如果输入向量没有高位，则报告为零。 例如，给定输入8'b10010000的8位优先级编码器将输出3'd4，因为bit [4]是高的第一位。\n\ntips：由上一个练习我们知道，case语句中将有256种case item，使用casez以后，我们可以减少需比较的case item，这就是casez的目的，在比较中，将值z的位视作无关位。\n\n所以上题的另一种解法为：\n\n```verilog\nalways @(*) begin\n    casez (in[3:0])\n        4'bzzz1: out = 0;   // in[3:1] can be anything\n        4'bzz1z: out = 1;\n        4'bz1zz: out = 2;\n        4'b1zzz: out = 3;\n        default: out = 0;\n    endcase\nend\n```\n\ncase语句的行为就好像是按顺序检查每个项一样(实际上，它所做的事情更像是生成一个巨大的真值表，然后进行门操作)。注意某些输入(例如4’b1111)是如何匹配多个case项的。选择第一个匹配项(因此4'b1111匹配第一个项目，out = 0，但不匹配后面的任何项目)。\n\n- 还有类似的`casex`，它将x和z均无视掉。\n- 符号?是z的同义词，所以2‘bz0=2'b?0\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [7:0] in,\n    output reg [2:0] pos  );\n    always @(*) begin\n        casez(in)\n            8'bzzzzzzz1:pos=0;\n            8'bzzzzzz1z:pos=1;\n            8'bzzzzz1zz:pos=2;\n            8'bzzzz1zzz:pos=3;\n            8'bzzz1zzzz:pos=4;\n            8'bzz1zzzzz:pos=5;\n            8'bz1zzzzzz:pos=6;\n            8'b1zzzzzzz:pos=7;\n            default:pos=0;\n        endcase\n    end\nendmodule\n```\n\n该题也可以按Priority encoder中的解法2来写，复杂度甚至更低。\n\n------\n\n## 去锁存器\n\n**题目描述**：\n\n假设构建一个电路来处理游戏的PS/2键盘上的扫描代码。对于收到的最后两个字节的扫描码，我们需要指示是否按下了键盘上的一个方向键。这涉及到一个相当简单的映射，它可以实现为一个case语句(或if-elseif)，包含四个case。\n\n电路有一个16位输入和四个输出。建立能识别这四种扫描码并正确输出的电路。\n\n| Scancode[15:0] |  Arrow key  |\n| :------------: | :---------: |\n|    16'he06b    | left arrow  |\n|    16'he072    | down arrow  |\n|    16'he074    | right arrow |\n|    16'he075    |  up arrow   |\n| Anything else  |    none     |\n\ntips：为避免生成锁存器，所有的输入情况必须要被考虑到。但仅有一个简单的default是不够的，我们必须在case item和default中为4个输出进行赋值，这会导致很多不必要的代码编写。\n\n一种简单的方式就是**对输出先进行赋初值的操作**，这种类型的代码确保在所有可能的情况下输出都被赋值，除非case语句覆盖了赋值。这也意味着不再需要缺省的default项。如下面示例代码：\n\n```verilog\nalways @(*) begin\n    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;\n    case (scancode)\n        ... // Set to 1 as necessary.\n    endcase\nend\n```\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up  ); \n    always @(*) begin\n        left=0;down=0;right=0;up=0;\n        case(scancode)\n            16'he06b:left=1;\n            16'he072:down=1;\n            16'he074:right=1;\n            16'he075:up=1;\n        endcase\n    end\nendmodule\n```\n\n------\n\n## 总结：\n\n- 学习了组合和时序两种always块，并知晓了两种类型的always块中变量的类型即赋值方式。何时使用wire与reg，何时用阻塞和非阻塞赋值。\n\n- 学习了如何<u>在组合逻辑中</u>使用if和case语句时**避免生成锁存器**：\n\n  将所有状态均考虑到并为其输出赋值，考虑不全可用else/default。\n\n  在case之前为所有输出赋初值，这样可以不用使用default，除非满足case item进行覆盖赋值，否则仍保持初值。\n\n  <u>时序逻辑下不会生成锁存器。</u>\n\n- 学习了case语句的妙用，以及使用casez忽略无关位，更简便的实现优先编码器。\n\n\n\n","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(3)_Verilog模块的例化与调用","url":"/2022/09/03/IC/HDLBits/HDLBits答案(3)_Verilog模块的例化与调用/","content":"\n# HDLBits_Verilog模块的例化与调用\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 模块\n\n只要使用的所有模块都属于同一个项目，就可以通过在模块内部实例化一个模块来创建模块的层次结构。一个模块的代码不能在另一个模块的主体中编写(不同模块的代码不是嵌套的)。\n\n有两种常见的方式将wire信号连接到端口上，分别是按位置和按名称连接。\n\n按位置：`mod_a instance1 ( wa, wb, wc );`\n\n按名称：`mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );`\n\n- By position:` mod_a instance1 ( wa, wb, wc );`\n\n  \n\n**题目描述**：完成mod_a模块的调用\n\n**Solution**：\n\n```verilog\nmodule top_module ( input a, input b, output out );\n    mod_a david(.out(out),.in1(a),.in2(b));\nendmodule\n```\n\ntips：模块调用两种方式：按位置调(简洁但不稳，顺序不可乱)，按名称调(繁琐但很稳，顺序可变)\n\n------\n\n## 按位置连接端口\n\n**题目描述**：\n\n已有一个名为mod_a的模块，它有2个输出和4个输入。您必须按位置将这6个端口连接到顶层模块的端口out1、out2、a、b、c和d，并按顺序进行连接。\n\n给定如下的模块:\n\n```verilog\nmodule mod_a ( output, output, input, input, input, input );\n```\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232146270.png)\n\n**Solution**:\n\n```verilog\nmodule top_module ( \n    input a, \n    input b, \n    input c,\n    input d,\n    output out1,\n    output out2\n);\n    mod_a david(out1,out2,a,b,c,d);\nendmodule\n```\n\n------\n\n## 按名称连接端口\n\n**题目描述**：按名称调模块mod_a\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232146990.png)\n\n```verilog\nmodule top_module ( \n    input a, \n    input b, \n    input c,\n    input d,\n    output out1,\n    output out2\n);\n    mod_a(.out1(out1),.out2(out2),.in1(a),.in2(b),.in3(c),.in4(d));\nendmodule\n```\n\n------\n\n## 三个模块的调用\n\n**题目描述**：\n\n已有一个模块my_dff，其中有两个输入和一个输出(D触发器)。实例化三个D触发器然后将它们连接在一起，实现一个长度为3的移位寄存器。clk端口需要连接到所有my_dff实例。\n\n已有模块: `module my_dff ( input clk, input d, output q );`\n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232146559.png)\n\n**Solution**：\n\n```verilog\nmodule top_module ( input clk, input d, output q );\n\twire temp1;\n    wire temp2;\n    my_dff block1(clk,d,temp1);\n    my_dff block2(clk,temp1,temp2);\n    my_dff block3(clk,temp2,q);\nendmodule\n```\n\ntips：内部调用多个模块时，定义合理的wire信号连接内部的模块。\n\n------\n\n## 模块输入为向量\n\n**题目描述**：\n\n已有一个模块my_dff8，它具有两个输入和一个输出(实现一组8位的D触发器)。实例化其中的三个，然后将它们连接在一起，实现一个长度为3的8位宽移位寄存器。另外，构造一个4-1多路选择器，根据sel[1:0]选择输出值。本质上，sel选择的是延迟输入的周期。\n\n已有模块: `module my_dff8 ( input clk, input [7:0] d, output [7:0] q );`\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232147248.png)\n\n**Solution**：\n\n```verilog\nmodule top_module ( \n    input clk, \n    input [7:0] d, \n    input [1:0] sel, \n    output [7:0] q \n);\n    wire [7:0] out1;\n    wire [7:0] out2;\n    wire [7:0] out3;\n    \n    my_dff8 block1(clk,d,out1);\n    my_dff8 block2(clk,out1,out2);\n    my_dff8 block3(clk,out2,out3);\n    \n    always @(*) begin\n        case(sel)\n            2'b00:\n                q=d;\n            2'b01:\n                q=out1;                \n            2'b10:\n                q=out2;                \n            2'b11:\n                q=out3;                \n        endcase\n    end\nendmodule\n```\n\ntips：组合逻辑用非阻塞赋值连接即可。\n\n------\n\n## 加法器模块1\n\n**题目描述**：用两个带进位的16bit加法器组成一个32bit加法器。\n\n`module add16 (input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout);`\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232147719.png)\n\n**Solution**：\n\n```verilog\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    wire [15:0] low_out;\n    wire [15:0] high_out;\n    wire temp_cout;\n    wire cout;\n    \n    add16 low (a[15:0],b[15:0],0,low_out,temp_cout);\n    add16 high(a[31:16],b[31:16],temp_cout,high_out,cout);\n    \n    assign sum={high_out,low_out};    \nendmodule\n```\n\ntips：注意采用流拼接简化代码，无用信号接口作为输出也可以不进行管脚信号的定义。\n\n------\n\n## 加法器模块2\n\n**题目描述**：\n\n自定义一个1bit的全加器，构成一个16bit全加器，然后用两个16bit全加器完成32bit加法模块的搭建，忽略进位。\n\n1、定义一个1bit全加器。2、在顶层完成两个16bit全加器的调用。\n\n![6](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232147068.png)\n\n**Solution**：\n\n```verilog\nmodule top_module (\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    wire temp_cout;\n  \n    add16 low (a[15:0],b[15:0],0,sum[15:0],temp_cout);\n    add16 high(a[31:16],b[31:16],temp_cout,sum[31:16]);\nendmodule\n\nmodule add1 ( input a, input b, input cin,   output sum, output cout );\n    assign {cout,sum} = a + b + cin;\nendmodule\n```\n\n------\n\n## 进位选择加法器\n\n**题目描述**：\n\n在这个练习中，已有和上一个练习相同的模块add16，本题将两个带进位的16位数字相加，并生成一个输出进位和16位的和。需构造一个16位2-1多路选择器。\n\n`module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );`\n\n![7](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232147602.png)\n\ntips：提前计算加法器的进位，用资源换速度。\n\n**Solution**:\n\n```verilog\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    wire [15:0] highout0;\n    wire [15:0] highout1;\n    wire cout;\n    \n    add16 low(a[15:0],b[15:0],0,sum[15:0],cout);\n    add16 high0(a[31:16],b[31:16],0,highout0);\n    add16 high1(a[31:16],b[31:16],1,highout1);\n    \n    assign sum[31:16]=cout? highout1:highout0;\nendmodule\n```\n\n------\n\n## 加法器→减法器\n\n**题目描述**：利用sub信号和两个16bit的全加器，实现32bit的加减法运算。\n\n对输入的sub信号进行判断，如果sub=0，则输出(a + b + 0)；如果sub=1，则输出(a + ~b + 1)。\n\n已有模块：\n\n`module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0]sum, output cout );`\n\ntip: **Use a 32-bit wide XOR gate to invert the `b` input whenever `sub` is 1.** \n\n![8](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232147120.png)\n\n**Solution**:\n\n```verilog\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n    wire [31:0] b_processed;\n    wire cout_temp;\n    assign b_processed = b ^ {32{sub}};\n    \n    add16 lower(a[15:0],b_processed[15:0],sub,sum[15:0],cout_temp);\n    add16 higher(a[31:16],b_processed[31:16],cout_temp,sum[31:16]);\nendmodule\n```\n\ntips：巧用sub信号对输入b处理，妙！\n\n------\n\n## 总结：\n\n学习了模块的例化与调用，深刻理解了对着电路图写HDL这句话。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"HDLBits答案(2)_Verilog向量基础知识","url":"/2022/09/03/IC/HDLBits/HDLBits答案(2)_Verilog向量基础/","content":"\n# HDLBits_Verilog向量基础知识\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n------\n\n## 向量\n\n在Verilog中，对向量维度的声明在向量名之前，这点与C语言有所差异，但使用向量的时候维度信息仍在向量名后。\n\n```verilog\nwire [99:0] my_vector;      // Declare a 100-element vector\nassign out = my_vector[10]; // Part-select one bit out of the vector\n```\n\n------\n\n## 向量的更多知识\n\n### 声明向量\n\n`type [upper:lower] vector_name;`\n\n`type` 指定了向量的数据类型，通常为reg或wire类型。如果声明的是输入、输出向量的话，类型前还可以加上input和output，如下所示：\n\n```verilog\nwire [7:0] w;         // 8-bit wire\nreg  [4:1] x;         // 4-bit reg\noutput reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)\ninput wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)\noutput [3:0] a;       // 4-bit output wire. Type is 'wire' unless specified otherwise.\nwire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.\n```\n\n向量的大小端是指最不重要的位具有较低的索引([3:0])还是较高的索引([0:3])，一旦用特定的索引规则定义了向量，就要**用相同的方式去使用它**。\n\ntips：向量声明时数字的顺序很重要，它决定了向量是以大端存储或者小端存储。举例说明，若声明`wire [3:0] w`，则`w[0]`为w的最低位，`w[3]`为w的最高位；若声明为`wire [0:3] w`，则与上述结果相反。**所以在向量的定义和使用时一定要保持大小端一致！**\n\n#### 未定义的中间变量容易出错\n\n使用wire型变量前请先声明，不要图一时之便直接未定义就拿来做中间变量，这样导致的错误会很难发现。\n\n```verilog\nwire [2:0] a, c;   // Two vectors\nassign a = 3'b101;  // a = 101\nassign b = a;       // b =   1  implicitly-created wire\nassign c = b;       // c = 001  <-- bug\nmy_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.\n                    // This could be a bug if the port was intended to be a vector.\n```\n\n向量名前为维度，向量名后为数目，不写统统视作1。(可类比C语言中的数组，向量名前为数组元素的数据类型，向量名后为数组长度；或者形象化的表述为：维度即为每个房子的大小，数目为房子的总数目)\n\n```verilog\nreg [7:0] mem [255:0];   // 256 unpacked elements, each of which is a 8-bit packed vector of reg.\nreg mem2 [28:0];         // 29 unpacked elements, each of which is a 1-bit reg.\n```\n\n### 获取向量元素：部分选择\n\n访问整个向量是使用向量名完成的，如:`assign w = a;`如果左右两边的长度不匹配，则根据情况对向量进行补零或截断。\n\n向量的部分选择操作可以访问向量的一部分。(向量声明来自上面\"声明向量\"部分)\n\n```verilog\nw[3:0]      // Only the lower 4 bits of w\nx[1]        // The lowest bit of x\nx[1:1]      // ...also the lowest bit of x\nz[-1:-2]    // Two lowest bits of z\nb[3:0]      // Illegal. Vector part-select must match the direction of the declaration.\nb[0:3]      // The upper 4 bits of b.\nassign w[3:0] = b[0:3];    // Assign upper 4 bits of b to lower 4 bits of w. w[3]=b[0], w[2]=b[1], etc.\n```\n\ntips：取用向量中特定维度的数时一定注意要与向量的定义一致，注意大小端匹配的问题。\n\n**题目描述**：\n\n构建一个电路将一个4byte的数中的字节顺序调转，常用于数据的大小端转换。\n\n`AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa`\n\n**Solution:**\n\n```verilog\nmodule top_module( \n    input [31:0] in,\n    output [31:0] out );\n\n    assign out[31:24] = in[7:0];\n    assign out[23:16] = in[15:8];\n    assign out[15:8] = in[23:16];\n    assign out[7:0] = in[31:24];\n\nendmodule\n```\n\ntips：在向量赋值的左右两端都可以选择对部分数据进行操作。\n\n------\n\n## 对向量进行门操作\n\n**位操作运算符VS逻辑操作运算符**\n\n对两个Nbit位宽的向量而言，按位操作输出为Nbit位宽向量；而逻辑操作将整个向量视为布尔值(true =非零，false =零)并产生一个1bit的输出。\n\n**题目描述1：**对向量特定部分的数据进行按位操作和逻辑操作。\n\n**Solution1：**\n\n```verilog\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\tassign out_or_logical = a || b;\n    assign out_or_bitwise = a | b;\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\nendmodule\n```\n\n**题目描述2：**\n\n对输入向量进行按位的与、或和异或操作。\n\n**Solution2:**\n\n```verilog\nmodule top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // &in = in[3]&in[2]&in[1]&in[0]\n    assign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n```\n\ntips：合理利用缩位运算符精简代码，按位进行逻辑运算，结果为1bit数。\n\n- 与缩位运算符：& \n- 或缩位运算符：| \n- 异或缩位运算符：^ \n- 与、或、异或运算符和非运算符组成的**复合运算符**：&，|， ~，^\n\n------\n\n## 向量拼接操作\n\n向量拼接操作需要知道待拼接的各向量的位宽，否则你怎么知道结果的位宽？所以{1,2,3}是无效的，因为你未指定向量位宽。\n\n向量的拼接操作在赋值的左右两端均可使用。\n\n```verilog\ninput [15:0] in;\noutput [23:0] out;\nassign {out[7:0], out[15:8]} = in;         // Swap two bytes. Right side and left side are both 16-bit vectors.\nassign out[15:0] = {in[7:0], in[15:8]};    // This is the same thing.\nassign out = {in[7:0], in[15:8]};       // This is different. The 16-bit vector on the right is extended to\n                                        // match the 24-bit vector on the left, so out[23:16] are zero.\n                                        // In the first two examples, out[23:16] are not assigned.\n```\n\ntips：1、位宽合并需知道各成分的确切位宽，否则结果位宽不定。2、位宽合并时在assign两端均可实现，最好左右两端位宽相同，否则未被指定的数据会被置零。\n\n**题目描述：**\n\n给定几个输入向量，将它们拼接在一起，然后将它们分割成几个输出向量。有6个5位输入向量:a, b, c, d, e, f，总共30位输入。对于32位的输出，有4个8位的输出向量:w、x、y和z。输出应该是输入向量与两个“1”位的串联:\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232146021.png)\n\n**Solution：**\n\n```verilog\nmodule top_module (\n    input [4:0] a, b, c, d, e, f,\n    output [7:0] w, x, y, z );\n    wire [31:0] temp;\n    assign temp = {a,b,c,d,e,f,2'b11};\n    assign {w,x,y,z}=temp;\nendmodule\n```\n\n------\n\n## 向量翻转\n\n**题目描述：**\n\n给定一个8位输入向量[7:0]，颠倒它的位顺序。\n\n**Solution1:**\n\n```verilog\nmodule top_module( \n    input [7:0] in,\n    output [7:0] out\n);\n    assign out={in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};\nendmodule\n```\n\n**Solution2:**\n\n```verilog\nmodule top_module( \n    input [7:0] in,\n    output [7:0] out\n);\n\tinteger i;\n    always@(*)begin\n        for(i = 0;i < 8;i = i + 1)begin\n            out[i]=in[7-i];\n        end\n    end\nendmodule\n```\n\ntips：建议使用Solution2实现，可扩展性强。\n\n------\n\n## 向量复制操作\n\n向量复制操作允许重复一个向量并将它们连接在一起:`{num{vector}}`\n\n例如:\n\n```verilog\n{5{1'b1}}           // 5'b11111 (or 5'd31 or 5'h1f)\n{2{a,b,c}}          // The same as {a,b,c,a,b,c}\n{3'd5, {2{3'd6}}}   // 9'b101_110_110. It's a concatenation of 101 with\n                    // the second vector, which is two copies of 3'b110.\n```\n\ntips：复制向量有捷径，花括外面带数字。主要用于符号位的拓展。如4'b**0**101带符号拓展为8bit的话为8'b**0000**0101，4'b1101带符号拓展为8bit数为8'b**1111**1101。\n\n**题目描述：**建立一个电路，将8位数字扩展到32位。这需要将符号位的24个副本(即将位[7]复制24次)与8位数字本身连接起来。\n\n**Solution：**\n\n```verilog\nmodule top_module (\n    input [7:0] in,\n    output [31:0] out );\n\n    assign out = { {24{in[7]}} , in };\n\nendmodule\n```\n\n**题目描述2：**给定5个1位信号(a、b、c、d和e)，计算25位输出向量中所有25个成对的1位比较。如果两个被比较的位相等，输出应该是1。\n\n```verilog\nout[24] = ~a ^ a;   // a == a, so out[24] is always 1.\nout[23] = ~a ^ b;\nout[22] = ~a ^ c;\n...\nout[ 1] = ~e ^ d;\nout[ 0] = ~e ^ e;\n```\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232146896.png)\n\ntips：该操作可以定位特定signal所在位置，两向量重复数据有规律可循，可用复制的方式来产生，简化代码。\n\n**Solution:**\n\n```verilog\nmodule top_module (\n    input a, b, c, d, e,\n    output [24:0] out );\n\n    assign out = ~{5{a,b,c,d,e}} ^ {{5{a}},{5{b}},{5{c}},{5{d}},{5{e}}};\n\nendmodule\n```\n\n------\n\n## 总结：\n\n学习了向量操作的相关知识，包括声明、选择部分数据、合并、复制等操作。\n\n","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"Synplify中如何调用Xilinx网表IP","url":"/2022/09/02/FPGA/Synplify中如何调用Xilinx网表IP/","content":"\n## 背景\n\n在做项目时需要将Xilinx工具生成的IP导入到自己的项目工程中，布局布线由ISE完成，综合由Synplify完成；难点在于如何通过ISE调用Synplify综合工具以及如何让工具识别IP。\n\n## 解决方式\n\n首先搜索Synplify家的UG查看解决思路。\n\n![image-20221007151502051](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071515122.png)\n\n在Chapter13发现跟Xilinx家的IP相关内容；\n\n![image-20221007151552458](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071603375.png)\n\n下图列出了Xilinx提供的各种类型的网表\n\n![image-20221007151644377](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071516520.png)\n\n我们项目中用到的是NGC文件，应该是Non-seure版本，直接将NGC文件添加到ISE项目工程中即可。\n\n![image-20221007151924599](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071519672.png)\n\n至于ISE调用Synplify进行仿真的步骤，示意如下：\n\n![image-20221007152021821](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071520886.png)\n\n![image-20221007152050373](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202210071520446.png)\n\n","tags":["FPGA_Tools"],"categories":["FPGA","FPGA_Tools"]},{"title":"HDLBits答案(1)_Verilog语法基础","url":"/2022/09/02/IC/HDLBits/HDLBits答案(1)_Verilog语法基础/","content":"\n# HDLBits_Verilog语法基础\n\n[HDLBits链接](https://hdlbits.01xz.net/wiki/Main_Page)\n\n---\n\n## 线信号\n\n与物理电线不同，Verilog中的线信号(和其他信号)是“方向性的”。这意味着信息只向一个方向流动，从驱动程序流向接收器。在Verilog“连续赋值”(`assign left_side = right_side; `)中，右侧信号的值被驱动到左侧的连接上。assign赋值是“连续的”，右侧的值发生变化时左边的值立马发生变化。\n\n这时我们就会理解：一个线信号不能有两个驱动程序来驱动；线信号如果没有驱动程序的话那么输出就是未知的。\n\n当存在多个assign语句时，**assign出现的顺序和位置不影响**，也就相当于连线的顺序不影响最终结果，这个要和软件的思维区别开。\n\n## 基础的门操作\n\n### 区分按位取反(~) 和逻辑取反(!)\n\n![1](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232145528.png)\n\n### 区分按位与(&)和逻辑与(&&)\n\n![2](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232145668.png)\n\n### 区分按位或(|)和逻辑或(||)\n\n​\t *A NOR gate is an OR gate with its output inverted.* \n\n![3](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232145667.png)\n\n### 按位异或\n\n![4](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232145196.png)\n\n## 7458芯片\n\n![5](https://cdn.jsdelivr.net/gh/XduDavid/Blog_Img@main/img/202303232145215.png)\n\n**题目描述**：\n\n按照电路图，用verilog语言描述输入输出间的关系。\n\n**Solution1：**\n\n```verilog\nmodule top_module ( \n    input p1a, p1b, p1c, p1d, p1e, p1f,\n    output p1y,\n    input p2a, p2b, p2c, p2d,\n    output p2y );\n        wire and1_out,and2_out,and3_out,and4_out;\n        assign and1_out=p2a&p2b;\n        assign and2_out=p2c&p2d;\n        assign and3_out=p1a&p1c&p1b;\n        assign and4_out=p1f&p1e&p1d;\n        assign p2y=and1_out|and2_out;\n        assign p1y=and3_out|and4_out;\nendmodule\n```\n\n**Soluton2：**\n\n```verilog\nmodule top_module ( \n    input p1a, p1b, p1c, p1d, p1e, p1f,\n    output p1y,\n    input p2a, p2b, p2c, p2d,\n    output p2y );\n    assign p2y=(p2a&p2b)|(p2c&p2d);\n    assign p1y=(p1a&p1c&p1b)|(p1f&p1e&p1d);\nendmodule\n```\n\n## 总结\n\n1、assign为连续赋值，赋值顺序不影响。\n\n2、一个wire有且仅能有一个driver。\n\n3、学习了基础的门操作。","tags":["HDLBits"],"categories":["IC","HDLBits"]},{"title":"本科毕设小结","url":"/2020/06/23/Proj/基于PYNQ-Z2实现BNN硬件加速/","content":"\n## 本科毕设小结—基于HLS的BNN加速\n\n **本文主要是本人本科毕业设计的主要工作。**\n　　主要工作有两部分，一是使用Vivado HLS工具实现二值卷积神经网络模型并完成硬件加速工作，二是将二值神经网络的前向计算过程部署到PYNQ-Z2板上，并在Jupyter Notebook上实现IP核的调用。\n　　BNN参考论文《Binarized Neural Networks Training Neural Networks with Weights and Activations Constrainedto +1 or −1》、《FINN A Framework for Fast, Scalable Binarized Neural Network Inference》。因为毕设要求实现云图像分类的功能，所以训练集由灰度云图组成，格式与mnist数据集相同。训练采用深度学习框架theano，导出训练好的参数，然后在Vivado HLS上实现BNN前向计算的加速过程。\n　　![开发流程](https://img-blog.csdnimg.cn/2020062221433088.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70)\nBNN由卷积层、池化层和全连接层组成，主要问题其实只有一个：**如何加速卷积？**（全连接层主要是乘累加运算，此处可参考卷积层的加速)\n\n### 卷积加速\n卷积的加速主要分为4个层面：位宽加速、算法加速、HLS优化指令加速、访存加速。\n#### 位宽加速\n位宽加速其实就是**用数据精度换取计算速度**，这也是二值神经网络参数二值化的主要作用，参数二值化后大大降低了参数量。参数二值化是指我们在训练网络的时候将前向计算的权重进行二值化处理，但反向传播过程中会出现梯度消失的问题(sign函数的导数几乎处处为0)，所以反向传播时会进行松弛化处理，将符号函数Sign变为可导函数Htanh，并更新全精度的权重，这里的相关内容可以参考XNOR-NET的论文或者相关文献。主要过程如下图所示：\n![训练](https://img-blog.csdnimg.cn/20200622214942896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70)\n\n#### 算法加速\n\n - **乘加优化**\n\n算法方面的加速其实就是充分使用二值神经网络的特点进行运算符优化，因为前面我们已经将参数二值化，所以在进行卷积操作的时候可以利用同或操作和计数器代替乘加运算，即使用XNOR和PopCount实现乘加运算，具体可以参考XNOR-Net。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622223605481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70)\n\n以A=[1,-1,1,1,-1]和W=[-1,1,1,-1,-1]两个向量进行内积运算为例:\n正常的乘法运算为1×(-1)+(-1)×1+1×1+1×(-1)+(-1)×(-1)= -1；\n\n从同或运算的角度来看，A=[1,0,1,1,0],W=[0,1,1,0,0]\nA 与W 进行异或的结果为A^W=[1,1,0,1,0]（HLS 中不存在同或操作，需对异或取反进行同或操作）\nPopCount 的作用是计算1的个数来对二进制的乘积进行求和。所以PopCount(A^W)= 3,即结果中有3个-1；所以最终二进制的乘积的结果为(5-PopCount)×1+PopCount×(-1)= 5-2×PopCount= -1.\n伪代码如下，其中F 为卷积窗口大小，window_result 为当前卷积窗口的计算结果，weight_buff 为卷积核参数，bit_num 为卷积窗口内数据的总位数。\n\n```c\nfor (int c = 0; c < F; c++) {\n\tfor (int r = 0; r < F; r++) {\n\t\tbit32 tmp = weight_buff[r][c]^window_buff[r][c];\n\t\tcount += popcount(tmp);\n\t}\n}\n\twindow_result = bit_num – (count << 1);\n}\n```\n\n - **池化优化**\n普通的最大值池化就是对滑动窗口内的数据进行比较，将其中最大的数据作为该滑动窗口的结果。在BNN计算过程中，最大值池化后还要对输出结果再次进行二值化操作\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622224603468.png#pic_center)\n因为滑动窗口内任意一个值满足大于s 的条件都可以使当前滑动窗口的输出为1，即最大池化操作与计算顺序没有关系，因此二值神经网络的最大值池化操作可以简化为或运算\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622224631261.png#pic_center)\n#### 访存加速\n引入缓存，将缓存置于访存速度更快的内存块中，从而加速整个卷积层的计算速度。同时相邻的卷积窗口的数据重复率较高，无需读取大量重复使用的数据。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622225118806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n本文使用了行缓存器和窗缓存器实现了卷积窗口的流水操作，下图为窗口缓存结构示意图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622225309203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n参数更新过程如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622232414651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n伪代码如下：\n\n```c\nfor (int i = 0; i < F; i++) {\n\tfor (int j = 0; j < F - 1; j++) {\n\t\twindow_buff[i][j] = window_buff[i][j + 1];\n\t\twindow_buff[i][F-1] = line_buff[i][next_x];\n\t}\n}\nfor (int i = 0; i < F-1; i++) {\n\tline_buff[i][next_x] = line_buff[i + 1][next_x];\n\tline_buff[F-1][next_x] = input[y + F][next_x];\n}\n```\n\n #### HLS优化指令加速\n本文中主要用到的HLS的优化指令主要包括以下三个方面：(详细过程可参考Xilinx官方文档UG902)\n\n - **循环展开**\n 循环展开是指将一个循环函数分为多个独立操作，对应的优化指令为#pragma HLS UNROLL。一般来说，对内层循环采用循环展开优化较合适，若对外层循环进行循环展开的话，会显著提高资源的使用率。\n\n![循环展开的优化效果](https://img-blog.csdnimg.cn/20200622230051734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n - **流水优化**\n 在HLS 中，循环结构默认是折叠的，即只使用一组相同的硬件资源进行计算。流水线操作可以改善启动间隔与时延，对应的优化指令为#pragma HLS PIPELINE。\n    ![函数流水优化](https://img-blog.csdnimg.cn/20200622230314195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n    上图所示的函数，每三个时钟周期读取一个输入，两个时钟周期后输出一个值。使用Pipeline 优化指令后，每个时钟周期都可以读取一个新的输入，但输出的延迟不变。\n - **数组分割**\n在进行上述优化后仍存在部分问题—**读写操作的瓶颈问题**。之前所示的循环展开中，对每个数组而言，每个时钟周期需要执行3个读操作或3个写操作，但是一个BRAM 最多只有两个端口，即一个时钟周期内最多执行两个读或写操作。\n![读写瓶颈](https://img-blog.csdnimg.cn/20200622230620148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n数组分割是通过将一个块RAM 资源分割成多个较小的阵列，从而提高带宽，有效增加端口的数量，**提高读/写密集型算法的吞吐量**。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622230723552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n改进后的Resource Viewer如下，此时不存在读写瓶颈。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622230828921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70#pic_center)\n### 实验结果\n**硬件系统模块的Block Design**：\n![1.png](https://img-blog.csdnimg.cn/img_convert/6f64df2db08ca9eefa73f092866cbad4.png)\nJupyter Notebook结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062223134521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzM0MDcy,size_16,color_FFFFFF,t_70)\nPYNQ-Z2板硬件加速效果：\n|硬件平台|图像数|时间/ms\n|:----:|:----:|:----:|\n|CPU|100|8032.8|\n|FPGA|100|2.2|\n### 小结\n论文前期用了一段时间学习HDL，用Verilog语言搭建了一些小模块熟悉硬件搭建流程，熟悉PYNQ-Z2开发板的开发流程。后来参考[BNN-PYNQ](https://github.com/Xilinx/BNN-PYNQ)在PYNQ-Z2板上跑通了BNN的例程，参考[HLS-BNN](https://github.com/Stuart0l/BNN)学习BNN各模块在HLS的搭建及加速过程，实现BNN各模块的加速。\n同时，毕设选择硬件开发时，可参考的中文资料较少，靠谱的英文文献有UG871（官方提供的HLS例程，建议跟着步骤都做一遍）以及UG902（当工具书查询）\n论文中提及的工作占时不是很多 ，主要时间都在熟悉HDL、HLS开发工具以及PYNQ-Z2的开发流程，期间也遇到了很多问题，比如如何定义接口类型、如何调用板子以及如何在Jupyter Notebook进行数据格式转换等。\n\n完成大部分毕设工作已是立夏，回顾大学四年，我努力着，付出着。\n在此十分感谢女友，同我交流感受，为我加油打气；\n非常感谢我的家人，替我烧水煮饭，唤我添衣保暖；\n也很感谢大学挚友，与我交流思路，携我共同进步。\n\n### 参考资料\n[PYNQ-Z2板卡简介与资源整理](http://bbs.elecfans.com/jishu_1710246_1_1.html)\n[Xilinx/BNN-PYNQ](https://github.com/Xilinx/BNN-PYNQ)\n[板卡镜像下载地址](http://www.pynq.io/board.html)\n[PYNQ官方Getting Started](https://pynq.readthedocs.io/en/latest/getting_started.html)\n[PYNQ官方例程—熟悉PYNQ的开发流程](https://github.com/sazczmh/PYNQ_Workshop)\n[PYNQ入门中文资料](https://github.com/louisliuwei/PynqDocs)\n[HLS生成IP进行硬件加速](https://github.com/sazczmh/High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS)\n[FPGA并行编程](https://xupsh.gitbook.io/pp4fpgas-cn/)\n[BitCount函数解释](https://blog.csdn.net/Elmo66/article/details/78858120?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158641757219724839243619%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158641757219724839243619&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-all_SOOPENSEARCH-3)\n[BNN-PYNQ安装](https://blog.csdn.net/WAWAWALALALA/article/details/94396331)\n[模仿mnist制作数据集](https://blog.csdn.net/YF_Li123/article/details/76731697)\n[FINN_Documentation](https://finn.readthedocs.io/en/latest/index.html)\n[吴恩达深度学习课程第四课 — 卷积神经网络](https://www.bilibili.com/video/BV1F4411y7o7)\n[HLS入门视频](https://www.bilibili.com/video/BV1bt41187RW)\n[正点原子ZYNQ系列](https://www.bilibili.com/video/BV1TJ411R7YY)\n\n**[2020.8.27更新，添加BNN的HLS和Vivado工程复现教程]**\n[BNN工程复现教程](https://blog.csdn.net/qq_42334072/article/details/107966278)\n**[2020.11.26更新，更新Block Design框图]**\n","tags":["Proj"],"categories":["Proj"]}]